{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/6329af87bb9ae8003eec0d77",
  "data": {
    "id": "6329af87bb9ae8003eec0d77",
    "name": "Lazily Grouping",
    "slug": "lazily-grouping",
    "category": "algorithms",
    "publishedAt": "2022-09-22T09:44:36.562Z",
    "approvedAt": null,
    "languages": [
      "haskell"
    ],
    "url": "https://www.codewars.com/kata/6329af87bb9ae8003eec0d77",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2022-09-20T12:18:15.239Z",
    "createdBy": {
      "username": "oisdk",
      "url": "https://www.codewars.com/users/oisdk"
    },
    "description": "# Lazy Grouping\n\nThis task is about implementing a `groupOn` function.\n\n```haskell\n>>> groupOnOrd head [\"cat\", \"car\", \"apple\", \"croissant\", \"battery\"]\n[('c',[\"cat\",\"car\",\"croissant\"]),('a',[\"apple\"]),('b',[\"battery\"])]\n```\n\nThe function you need to implement is called `groupOnOrd :: Ord k => (a -> k) -> [a] -> [(k,[a])]`. Given a \"key\" function, which generates the key for each group, your function should put each of the elements of the input list into a list paired with its key. This function should obey some properties:\n\n* The order of the groups in the output list should be the same as the order in the input. For instance, above `'c'` is encountered first, so it is the first group.\n* There should be no duplicate groups. Again, using the above output as an example, even though `\"croissant\"` is disjoint from `\"cat\"` and `\"car\"`, it is put in the same group as them because it starts with the same letter.\n\nYour solution should be fully lazy. That means that the following should be well defined:\n\n```haskell\n>>> map fst . groupOnOrd id $ [1..]\n[1..]\n\n>>> groupOnOrd id $ cycle [1,2,3]\n(1,repeat 1):(2,repeat 2):(3,repeat 3):⊥\n\n>>> groupOnOrd (`rem` 3) [1..]\n(1,[1,4..]):(2,[2,5..]):(0,[3,6..]):⊥\n```\n\nFinally, while all of the properties above can be satisfied by implementing a function with just an `Eq` constraint, in order for your function to be efficient you will have to make use of `Ord` somehow.",
    "totalAttempts": 38,
    "totalCompleted": 8,
    "totalStars": 2,
    "voteScore": 3,
    "tags": [
      "Algorithms",
      "Functional Programming",
      "Lists"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 0,
      "suggestions": 1
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}