{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5e137d134dfa4d0014402026",
  "data": {
    "id": "5e137d134dfa4d0014402026",
    "name": "Placing new objects in memory",
    "slug": "placing-new-objects-in-memory",
    "category": "reference",
    "publishedAt": "2020-01-06T18:40:41.519Z",
    "approvedAt": null,
    "languages": [
      "cpp"
    ],
    "url": "https://www.codewars.com/kata/5e137d134dfa4d0014402026",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2020-01-06T18:31:47.683Z",
    "createdBy": {
      "username": "de-passage",
      "url": "https://www.codewars.com/users/de-passage"
    },
    "description": "In this kata we'll explore a lesser-known feature of C++ : building objects at specific memory locations. \n\n---\n\n# First Task : construct\n\nImplement a template function called `construct` which takes a buffer and some parameters and construct inside of the buffer as many well-aligned instances of a given type as possible.\n\n`construct` takes several template parameters : the type `Type` of the objects to build, the type `Buffer` of some contiguous range of memory, and a parameter pack.\nThe first parameter of `construct` will be a reference to the object _on_ which you'll build the desired `Type` objects, the rest are the parameters you need to give to the constructor of `Type`.\n\nWarning ! You may be required to leave some space inside of `buffer` unused! Pay also attention to the alignment of `Buffer` with respect to `Type`!\n\n`Type` will never be an array or pointer type, no need to worry about that. It may be non trivial and have constructors/destructors with side effects though!\n\n# Second Task : destruct\n\nImplement a template function called `destruct` taking a buffer filled with as many objects as possible and empties it of its content (destroys the objects). Memory doesn't need to be rewritten explicitely.\n`destruct` takes two template parameters : `Type`, the type of the objects contained in the buffer, and `Buffer`, the type of the buffer itself.\n\nThe buffers given to `destruct` can be considered as having been through `construct` beforehand. The same rules apply.\n\n---\n\n# Trivia \n\nThe techniques used to solve this kata are somewhat obscure and rarely useful, so do not abuse them ! They are however an indispensable part of C++, making possible things like std::optional (which doesn't make any dynamic memory allocation) or std::vector with non-copyable/non-default-constructible types. It is also the basis for the need for allocators, which are omnipresent in the standard library.\n\n# Hints\n\n### First hint\nMost people understand what type size is, but you may need to read up on [alignment](https://en.cppreference.com/w/cpp/language/object#Alignment)!\n\n### Second hint\nYou are probably aware of the `new` operator, which does two things : allocating a block of memory fitting the type of the object that you are trying to construct and then calls the constructor of the given type. \nWhat many people are not aware of is that `new` is not a magical language construct. It is an operator with several overloads !\n\nFor example `new` normally throws an exception of type `std::bad_alloc` if memory allocation failed, but there is also a version of `new` returning `nullptr` on failure!\n```cpp\nMyClass* my_object = new(std::nothrow) MyClass;\n\nif (my_object == nullptr) {\n  std::terminate();\n}\n```\n\nTo solve this kata, you'll need one of the many versions of `new`. I leave it to you to find it and understand how to use it. For all things C++, [cppreference](https://en.cppreference.com/w/cpp/memory/new/operator_new) is a good place to start.\n\n",
    "totalAttempts": 225,
    "totalCompleted": 11,
    "totalStars": 6,
    "voteScore": 16,
    "tags": [
      "Fundamentals"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}