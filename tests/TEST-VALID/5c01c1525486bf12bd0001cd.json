{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5c01c1525486bf12bd0001cd",
  "data": {
    "id": "5c01c1525486bf12bd0001cd",
    "name": "Max number of people and year in a specific place",
    "slug": "max-number-of-people-and-year-in-a-specific-place",
    "category": "algorithms",
    "publishedAt": "2018-12-01T06:55:27.191Z",
    "approvedAt": null,
    "languages": [
      "javascript",
      "ruby",
      "python",
      "cpp",
      "crystal"
    ],
    "url": "https://www.codewars.com/kata/5c01c1525486bf12bd0001cd",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2018-11-30T23:01:39.016Z",
    "createdBy": {
      "username": "GiacomoSorbi",
      "url": "https://www.codewars.com/users/GiacomoSorbi"
    },
    "description": "As a historian, you wonder how many people ever lived in a specific area.\n\nGiven an amount of records as an array/vector/list of arrays/pairs/tuples representing the year of arrival/birth and departure/death from a given area, your task is to write a function that returns the maximum for that area and the year in which said maximum was achieved.\n\nIf more years have that maximum, just return the first one of them.\n\nIf you have both people entering and exiting the territory in the same year, consider that all new comers arrived/were born before anyone left/died for the sake of computing when the maximum was achieved\n\nYou will always be given at least one record of beginning/ending of a presence on the territory in valid format (ie: the first value will be lesser than or equal to the second).\n\n```cpp\nyearMaxPeople({{1978, 1978}, {1969, 1998}}) == {2, 1978}\nyearMaxPeople({{1980, 2010}, {1979, 1985}, {1986, 1995}, {1987, 2008}}) == {3, 1987}\nyearMaxPeople({{1980, 2010}, {1979, 1986}, {1986, 1995}, {1987, 2008}}) == {3, 1986}\n```\n```javascript\nyearMaxPeople([[1978, 1978], [1969, 1998]]) === [2, 1978]\nyearMaxPeople([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) === [3, 1987]\nyearMaxPeople([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) === [3, 1986]\n```\n```python\nyear_max_people([(1978, 1978), (1969, 1998)]) == (2, 1978)\nyear_max_people([(1980, 2010), (1979, 1985), (1986, 1995), (1987, 2008)]) == (3, 1987)\nyear_max_people([(1980, 2010), (1979, 1985), (1986, 1995), (1987, 2008)]) == (3, 1986)\n```\n```ruby\nyear_max_people([[1978, 1978], [1969, 1998]]) == [2, 1978]\nyear_max_people([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) == [3, 1987]\nyear_max_people([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) == [3, 1986]\n```\n```crystal\nyear_max_people([[1978, 1978], [1969, 1998]]) == [2, 1978]\nyear_max_people([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) == [3, 1987]\nyear_max_people([[1980, 2010], [1979, 1985], [1986, 1995], [1987, 2008]]) == [3, 1986]\n```\nMore examples in the test cases and be warned that you need to do things in a rather performing way in order to pass.",
    "totalAttempts": 414,
    "totalCompleted": 98,
    "totalStars": 11,
    "voteScore": 125,
    "tags": [
      "Performance",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 4
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}