{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/6501424a0038a69297098bab",
  "data": {
    "id": "6501424a0038a69297098bab",
    "name": "Chinese Remainders",
    "slug": "chinese-remainders",
    "category": "algorithms",
    "publishedAt": "2023-09-13T05:21:10.827Z",
    "approvedAt": null,
    "languages": [
      "python"
    ],
    "url": "https://www.codewars.com/kata/6501424a0038a69297098bab",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2023-09-13T05:02:02.185Z",
    "createdBy": {
      "username": "saudiGuy",
      "url": "https://www.codewars.com/users/saudiGuy"
    },
    "description": "Create a function that finds a number _n_ so that _n mod y = x_,  given an array of _x-y pairs_, where (0 ≤ _n_ ≤ product of all _y_'s).\n\nThis challenge is related to the [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem), which states that there is one and only one integer _n_ that is congruent with a number of divisors (called _moduli_) and their remainders for _n_ so long as those moduli are coprime, where _n_ is comprised between 0 and the product of all moduli.\n\nFor example, there is only one value between 0 and 3 × 4 × 5 = 60 for _n_ so that:\n- n mod 3 = 0\n- n mod 4 = 3\n- n mod 5 = 4\n\nHere, _n_ = 39 because 39 mod 3 = 0, 39 mod 4 = 3, and 39 mod 5 = 4, and 3 and 4 are coprime, and so are 3 and 5, and 4 and 5.  The numbers -21 and 99 would also be congruent with the moduli and remainders given, but we will not be considering those as they aren't in the range (0, 60).\n\nYour input will be an array with a number of tuples in the form `(remainder, modulo)` and the output should be a number _n_ congruent with those moduli and remainders.\n\n### Examples\n```\n[[0, 3], [3, 4], [4, 5]] ➞ 39\n// 39 mod 3 = 0, 39 mod 4 = 3 and 39 mod 5 = 4\n\n[[1, 2],  [8, 9]] ➞ 17\n// 17 mod 2 = 1 and 17 mod 9 = 8\n\n[[0, 15], [7, 16], [2, 17]] ➞ 2535\n// 2535 mod 15 = 0, 2535 mod 16 = 7 and 2535 mod 17 = 2\n```\n\n### Notes\n- You don't need to check for co-primality. Assume all moduli in the input will be coprime.\n- An input will be at least one tuple.\n- 2 <= x, y <= 100\n- 2 <= len(lst) <= 20",
    "totalAttempts": 2,
    "totalCompleted": 2,
    "totalStars": 0,
    "voteScore": 0,
    "tags": [
      "Performance"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}