{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/648365a0e4e521001c5c829d",
  "data": {
    "id": "648365a0e4e521001c5c829d",
    "name": "Normalizing State Shape #1",
    "slug": "normalizing-state-shape-number-1",
    "category": "reference",
    "publishedAt": "2023-06-09T20:26:10.595Z",
    "approvedAt": null,
    "languages": [
      "javascript"
    ],
    "url": "https://www.codewars.com/kata/648365a0e4e521001c5c829d",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2023-06-09T17:47:12.812Z",
    "createdBy": {
      "username": "PrVille",
      "url": "https://www.codewars.com/users/PrVille"
    },
    "description": "### `Normalizing State Shape Part 1`\n\nIn web application development, managing state is crucial, especially when dealing with complex data structures. In this kata, you'll be tasked with normalizing the state of a blog application, specifically focusing on blog posts, comments, and users.\n\nThe input data represents a collection of blog posts with associated authors and comments. Your goal is to transform this data into a normalized state object, following the principles of database design.\n\nTo achieve this, you need to create a function called `normalizeState(blogPosts)`, where `blogPosts` is an array of objects representing the blog posts.\n\n### Input\n\nThe input data `blogPosts` looks like this:\n\n```javascript\n[\n  {\n    id: String,\n    author: {\n      username: String,\n      name: String,\n    },\n    body: String,\n    comments: [\n      {\n        id: String,\n        author: {\n          username: String,\n          name: String,\n        },\n        comment: String,\n      },\n      // Repeat for more comments\n    ],\n  },\n  // Repeat for more blog posts\n]\n```\n\n- The `blogPosts` array will always be provided as a valid array of objects representing blog posts.\n\n- Each blog post object will have the properties `id` (string), `author` (object), `body` (string), and `comments` (array).\n\n- The `author` property in each blog post object will have the properties `username` (string) and `name` (string).\n\n- The `comments` property in each blog post object will be an array of objects representing comments.\n\n- The `comments` array can be an empty array.\n\n- Each comment object will have the properties `id` (string), `author` (object), and `comment` (string).\n\n- The `author` property in each comment object will have the properties `username` (string) and `name` (string).\n\n- The `username` property in the author objects will be unique across the entire `blogPosts` array.\n\n- The `id` property in the blog post objects and the comment objects will be unique across the entire `blogPosts` array.\n\n### Output\n\nThe function should return a normalized state object according to the following schema:\n\n```javascript\n{\n  entities: {\n    authors: {\n      byId: {\n        [username: String]: {\n          username: String,\n          name: String,\n        },\n      },\n      allIds: [String],\n    },\n    posts: {\n      byId: {\n        [postId: String]: {\n          id: String,\n          author: String,\n          body: String,\n          comments: [String],\n        },\n      },\n      allIds: [String],\n    },\n    comments: {\n      byId: {\n        [commentId: String]: {\n          id: String,\n          author: String,\n          comment: String,\n        },\n      },\n      allIds: [String],\n    },\n    authorPosts: {\n      byId: {\n        [username: String]: [String],\n      },\n      allIds: [String],\n    },\n  },\n}\n```\n\n- The `authors` object represents all authors (posts and comments).\n\n- Each blog post should be represented as an object in the `posts` object, using the post's `id` as the key. Each post object should have the properties `id`, `author`, `body`, and `comments`.\n\n- The `author` property in the post object should be a string representing the author's `username`.\n\n- The `comments` property in the post object should be an array of comment IDs associated with that post.\n\n- Each comment should be represented as an object in the `comments` object, using the comment's `id` as the key. Each comment object should have the properties `id`, `author`, and `comment`.\n\n- The `author` property in the comment object should be a string representing the author's `username`.\n\n- The `authorPosts` object should represent the relationship between authors and posts. The `authorPosts` object has two properties:\n\n  - `byId`: An object where each key is an author's username and the corresponding value is an array of post IDs authored by that user.\n\n  - `allIds`: An array containing all the usernames of authors.\n\n- The `allIds` arrays in each object should contain the IDs of the respective entities in the same order as they appear.\n\n- The `byId` objects can be ordered how you like. The ordering doesn't matter.\n\n### Example\n\nInput:\n\n```javascript\nconst blogPosts = [\n  {\n    id: \"post1\",\n    author: { username: \"user1\", name: \"User 1\" },\n    body: \"......\",\n    comments: [\n      {\n        id: \"comment1\",\n        author: { username: \"user2\", name: \"User 2\" },\n        comment: \".....\",\n      },\n    ],\n  },\n  {\n    id: \"post2\",\n    author: { username: \"user2\", name: \"User 2\" },\n    body: \"......\",\n    comments: [],\n  },\n  {\n    id: \"post3\",\n    author: { username: \"user3\", name: \"User 3\" },\n    body: \"......\",\n    comments: [\n      {\n        id: \"comment2\",\n        author: { username: \"user1\", name: \"User 1\" },\n        comment: \".....\",\n      },\n      {\n        id: \"comment3\",\n        author: { username: \"user3\", name: \"User 3\" },\n        comment: \".....\",\n      },\n    ],\n  },\n]\n```\n\nOutput:\n\n```javascript\n{\n  entities: {\n    authors: {\n      byId: {\n        user1: { username: \"user1\", name: \"User 1\" },\n        user2: { username: \"user2\", name: \"User 2\" },\n        user3: { username: \"user3\", name: \"User 3\" },\n      },\n      allIds: [\"user1\", \"user2\", \"user3\"],\n    },\n    posts: {\n      byId: {\n        post1: {\n          id: \"post1\",\n          author: \"user1\",\n          body: \"......\",\n          comments: [\"comment1\"],\n        },\n        post2: {\n          id: \"post2\",\n          author: \"user2\",\n          body: \"......\",\n          comments: [],\n        },\n        post3: {\n          id: \"post3\",\n          author: \"user3\",\n          body: \"......\",\n          comments: [\"comment2\", \"comment3\"],\n        },\n      },\n      allIds: [\"post1\", \"post2\", \"post3\"],\n    },\n    comments: {\n      byId: {\n        comment1: {\n          id: \"comment1\",\n          author: \"user2\",\n          comment: \".....\",\n        },\n        comment2: {\n          id: \"comment2\",\n          author: \"user1\",\n          comment: \".....\",\n        },\n        comment3: {\n          id: \"comment3\",\n          author: \"user3\",\n          comment: \".....\",\n        },\n      },\n      allIds: [\"comment1\", \"comment2\", \"comment3\"],\n    },\n    authorPosts: {\n      byId: {\n        user1: [\"post1\"],\n        user2: [\"post2\"],\n        user3: [\"post3\"],\n      },\n      allIds: [\"user1\", \"user2\", \"user3\"],\n    },\n  },\n}\n```\n\nBy organizing the state in this normalized structure, we can easily access and update specific entities and establish relationships between them. It provides efficient data retrieval and avoids data duplication, resulting in a more manageable and scalable state management solution.\n\n`In Part 2 (coming soon) we will be looking at CRUD operations on the normalized state.`\n",
    "totalAttempts": 150,
    "totalCompleted": 13,
    "totalStars": 2,
    "voteScore": 25,
    "tags": [
      "Data Structures"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}