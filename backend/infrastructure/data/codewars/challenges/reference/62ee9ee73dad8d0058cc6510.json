{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/62ee9ee73dad8d0058cc6510",
  "data": {
    "id": "62ee9ee73dad8d0058cc6510",
    "name": "Whitespace is fun!",
    "slug": "whitespace-is-fun",
    "category": "games",
    "publishedAt": "2022-08-06T21:56:29.236Z",
    "approvedAt": null,
    "languages": [
      "java"
    ],
    "url": "https://www.codewars.com/kata/62ee9ee73dad8d0058cc6510",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2022-08-06T17:03:35.476Z",
    "createdBy": {
      "username": "koba1996",
      "url": "https://www.codewars.com/users/koba1996"
    },
    "description": "## Backstory\n\nI love esoteric programming languages, and started to write codes in whitespace. Sadly, I cannot chose Whitespace, as a programming language to practice here on Codewars. I wish I could! So I just started solving the simple tasks with my own interpreter, when something popped into my mind: we could have a kata, where we solve these tasks using whitespace code.\n\n## Description\n\nWhat is whitespace? It is an estoreric programming language which contains only three characters: space (\" \"), tab (\"\\t\"), and line feed (\"\\n\"). How does that even possible?\n\nThe official guide for whitespace:\n\nhttps://hackage.haskell.org/package/whitespace-0.4/src/docs/tutorial.html\n\nI was requested to provide a more detailed description, because the original is somewhat vague. I will involve qoutes from the original page, since many parts of the description is well written. From now on LF stands for Line Feed, the character with ASCII value of 10.\n\n\"The only lexical tokens in the whitespace language are Space (ASCII 32), Tab (ASCII 9) and Line Feed (ASCII 10). ... The language itself is an imperative, stack based language. Each command consists of a series of tokens, beginning with the Instruction Modification Parameter (IMP).\"\n\nHow does it look life in real life? \n\n```[IMP] [Command] [Number|Label, if the command needs it]```\n\nIMP is just a way of better sorting between the commands. There are actually 5 different groups of operations:\n\n - [Space] : Stack manipulation\n - [Tab][Space] : Arithmetic operation\n - [Tab][Tab] : Heap operation\n - [Tab][LF] : I/O operation\n - [LF] : Flow manipulation commands\n \n If it is not 100% clear yet, I recommend you to not give up. Once we reach the commands, I will show you many examples, to make everything clear. But first we really need to talk about labels and numbers, as some of the functionalities need a label or a number as argument.\n \n \"Numbers can be any number of bits wide, and are simply represented as a series of [Space] and [Tab], terminated by a [LF]. [Space] represents the binary digit 0, [Tab] represents 1. The sign of a number is given by its first character, [Space] for positive and [Tab] for negative.\"\n \n Let's see those examples!\n The label is pretty straightforward. You just use a combination of Tabs and Spaces to create a unique key for your label, and LF to mark the end of it. Valid labels:\n \n ```\n \" \\t\\n\"\n \"    \\n\"\n \" \\t \\t \\t \\t \\t\\n\"\n \"\\n\" //even this is valid, the key of your label is an empty string \"\"\n ```\n \n Invalid labels:\n \n ```\n \"\\t\\t\" //no \\n at the end\n \"\\t \\n \\t \\n\" //key cannot contain \\n, it only used for ending the key\n ```\n \n Numbers are more interesting. First you have a [Tab] for negative, and [Space] for positive number. Then you write your number in binary, every 1 is a [Tab], and every 0 is a [Space]. Numbers also end with LF. Valid numbers:\n \n ```\n \"\\t\\t\\n\" // Starts with [Tab], so negative, then a [Tab] means 1, so our number is -1\n \" \\t \\t\\n\" //Starts with [Space], so positive, then [Tab][Space][Tab] means 101 = 7.\n \"\\t\\t    \\n\" // - 16\n \" \\t\\t\\t \\n\" // 14\n \" \\n\" // 0\n \"\\t\\n\" // also 0\n ```\n \n Invalid numbers:\n \n ```\n \"\\n\" //numbers need to contain the sign byte, otherwise they are invalid, even if you want to write 0\n \" \\t\\t\" //no '\\n' at the end\n ```\n \n Please note: if you forgot to use \\n at the end, the compiler will continue to evaluate your code as a number or label until it finds a LF, that can and will cause malfuncationing in the code.\n \n And finally the commands! If you did not give up until this point, everything will be much cleaner from now on, we will actually write code and use what learned earlier.\n \n Stack manipulation [Space] :\n - [Space] (Number) : Place the Number given on the top of your stack.\n - [LF][Space] : Duplicate the item on the top of your stack (the original and the duplication will be the top two elements of your stack after this operation)\n - [LF][Tab] : Swap the two elements at the top of your stack.\n - [LF][LF] : Remove the element from the top of your stack.\n \n Example time! For readability, let me replace [Space] with s, [Tab] with t, and [LF] with n.\n ```\n // [IMP] [Command] [Possibly a number, if required]\n \"ssstn\" // [Space] because it is a stack manipulation, [Space] command means push number into the stack, and the rest is just a number [Space][Tab][LF] = 1. The command pushes a 1 into the stack.\n \"ssstsn\" // Same IMP, same command, but the number is 2. Now the element on the top is a 2.\n \"snt\" // Swapping the top two elements, now the 1 is at the top of our stack\n \"sns\" // Duplicating the top element, our stack is (from top to bottom): 1, 1, 2\n \"snn\" // Top element got discarded, our stack remains: 1, 2\n ```\n \n Piece of cake! Let's do some math now! Please keep in mind in the next section: every arithmetic operation works the same way: replace the top two values from the stack with the result of the operation. The top value is always the second operand.\n \n Arithmetic operations [Tab][Space] :\n - [Space][Space] : Addition\n - [Space][Tab] : Subtraction\n - [Space][LF] : Multiplication\n - [Tab][Space] : Division\n - [Tab][Tab] : Modulo\n \n Interesting facts: whitespace works with whole numbers only at the moment, so ```7 / 3``` will provide ```2```. It also uses floor division, so ```-7 / 3``` will provide ```-3```. The sign of the modulo is always the same as the divisor. ```7 % 3 = 1``` and ```7 % -3 = -1```.\n \n Examples:\n \n ```\n //Let's use the already existing stack: 1, 2\n \"tsss\" //remove the top two elements, and push their sum instead: 3\n \"ssstn\" //push 1 at the top: 1, 3\n \"tsst\" //3 - 1, the stack becomes: 2\n \"ssttssn\" // push -8 into the stack: -8, 2\n \"tssn\" // 2 * -8 = -16, the stack is: -16\n \"ssststn\" // push 5\n \"tsts\" // -16 / 5 will result -4\n \"sssttn\" // push 3\n \"tstt\" // -4 % 3 will result 1, since 3 is positive. At the end of the day our stack is: 1\n ```\n \n I really hope these parts were clear, because it is going to get exciting after this.\n \n \"Heap access commands look at the stack to find the address of items to be stored or retrieved. To store an item, push the address then the value and run the store command. To retrieve an item, push the address and run the retrieve command, which will place the value stored in the location at the top of the stack.\"\n \n Heap access [Tab][Tab] :\n - [Space] : removes the top two elements from your stack (let's say from top to bottom ```a```, ```b```), then place ```a``` at the heap address ```b```\n - [Tab] : removes the top element from your stack (let's say ```a```), then push the value stored on heap address ```a``` into the stack\n \n Example:\n \n ```\n // Our stack is empty\n \"ssstn\" // push 1\n \"ssstsstsn\" // push 18\n \"tts\" // congrats, the value 18 is stored at the address 1! If you need it...\n \"ssstn\" // push 1\n \"ttt\" // your stack: 18 (1 popped, value at heap address 1 pushed)\n \"ssstn\" // push 1, stack: 1, 18\n \"ttt\" // retrieve 18, your stack: 18, 18\n \"ssstn\" // push 1\n \"ssstssttn\" // push 19\n \"tts\" // 19 stored at address 1\n \"ssstn\" // push 1\n \"ttt\" // your stack 19, 18, 18\n ```\n \n That's a long one, but I wanted to make 2 things clear: you can retrieve a value multiple times, and you can override the value of an address (although the previous value will be lost then).\n \n I/O operations [Tab][LF] :\n - [Space][Space] : output a character from the top of your stack\n - [Space][Tab] : output a number from the top of your stack\n - [Tab][Space] : read a character from your input (let's say ```a```), pops the value from the top of your stack (let's say ```b```) and place ```a``` at the heap address ```b```.\n - [Tab][Tab] : read a number from your input (let's say ```a```), pops the value from the top of your stack (let's say ```b```) and place ```a``` at the heap address ```b```.\n \n That sounds confusing! But I promise you it really is not. Example:\n \n ```\n // Our input is 10, 97\n // Our stack is empty\n \"ssstn\" // push 1\n \"tntt\" // the first input 10 is stored at address 1, you can retrieve it any time with the heap access retrieve method\n \"ssstsn\" // push 2\n \"tntt\" // 97 is stored at address 2\n \"ssstsn\" // push 2\n \"ttt\" // retrieve value from address 2, your stack is: 97\n \"ssstn\" // push 1\n \"ttt\" // retrieve value from address 1, your stack: 10, 97\n \"tnst\" // output 10 as a number, stack is: 97\n \"tnss\" // output 'a', since the character value of 97 is 'a'\n ```\n \n Maybe I overexmplained it, but it is really truly important that for heap acces operations and reading you need the relevant values at the top of your stack.\n \n Finally, the flow control operations.\n \n \"Flow control operations are also common. Subroutines are marked by labels, as well as the targets of conditional and unconditional jumps, by which loops can be implemented. Programs must be ended by means of [LF][LF][LF] so that the interpreter can exit cleanly.\"\n \n Flow control operations [LF] :\n - [Space][Space](label) : Mark a location at the program with a label passed as argument\n - [Space][Tab](label) : Call the subroutine marked by the label passed as argument\n - [Space][LF](label) : Jump unconditionally to the location marked by the label passed as argument\n - [Tab][Space](label) : If the top value of your stack is zero, jump to the location marked by the label passed as argument (it also removes the top value from your stack, while checking its value)\n - [Tab][Tab](label) : If the top value of your stack is negative, jump to the location marked by the label passed as argument (it also removes the top value from your stack, while checking its value)\n - [Tab][LF] : end of subroutine\n - [LF][LF] : exit the program\n \n I am not gonna give you examples this time, there is one really good at the page linked above, the explanation can be understood, and it shows how to write a for loop using labels and conditions. \n \n There is one topic I want to discuss here, which was maybe not clear: what is the difference between calling a subroutine and jumping to somewhere? When you jump to somewhere, the point you came from will not be stored in any ways, and from location of the jump your code will be evaluated till the end of the program or another jump. Calling a subroutine means you jump to a location, while your original position is stored, and once the subroutine ended (with [Tab][LF], end of subroutine) you jump back to the position, where you were, before calling the subroutine.\n \n I hope I made many things a bit more clear with this detailed description, and made it easier for you to start coding in whitespace. I will give you one final example of a full code, but please keep in mind: you cannot learn a programming language by descriptions and examples, the only way if you start solving tasks using that language. In the next section, I provided some really easy, and some not so easy ones to help you with that. But first, I will show you a code, that has two numbers as input, and the output is the sum of those numbers (I am not using s, n, t anymore, this is a real whitespace code):\n \n ```\n // input is a, b\n \"   \\t\\n\" // push 1, stack is: 1\n \" \\n \" // duplicate top value, stack is: 1, 1\n \"\\t\\n\\t\\t\" // read first value, place it at address 1, stack is: 1\n \"\\t\\t\\t\" // retrieve the value from address 1, stack is: a\n \"   \\t \\n\" // push 2, stack is: 2, a\n \" \\n \" // duplicate top value, stack is: 2, 2, a\n \"\\t\\n\\t\\t\" // read second value, place it at address 2, stack is: 2, a\n \"\\t\\t\\t\" // retrieve the value from address 2, stack is: b, a\n \"\\t   \" // sum the top two values, stack is: a+b\n \"\\t\\n \\t\" // output the top of the stack as a number, output is the value of a+b, stack is empty\n \"\\n\\n\\n\" // properly terminate the program, otherwise it will throw an error\n ```\n \nI hope you will enjoy this language as much as I do!\n\nThe interpreter translating your code will know only the commands listed above, but it will know all of those, so feel free to use them!\n\nAlso, please note that the language contains three character (space, tab, line feed), every other character is considered to be a comment. You can use comments, if you like to, the interpreter will remove those before parsing your code (naturally, if you use space, tab, or line feed inside your comment, it will cause an error or malfunction).\n\n## The tasks\n\nI brought some classics to you today!\n\n### Multiply\n\nEveryone loves this one! If you are here, that means you solved it. You will be provided two inputs, two whole numbers, and your code should return the multiplication of those, as a number. Too easy? Well, we need some warmup, right?\n\n### Return negative\n\nYou maybe remember this one. Your input is a whole number, and your code should output the \"negative version\" of that number. If the number is positive, return the opposite of the number, if it is negative, just return it unchanged.\n\n### Even or odd?\n\nAnother classic 8 kyu kata, if you had a childhood, you probably solved it as well. Your input will be a whole number, and the code should return \"Even\", if the number is even, and \"Odd\", if it is odd. Your code should write the words to the output.\n\n### Sum of positive\n\nThis one right here, this kata just meant to be written in whitespace. The moment I saw it I knew I want it to be the part of this collection, because you can utilize whitespace flow control operations so nicely here. In the original task you are given an array of numbers, and your code should return the sum of the positive numbers (ignore the negative ones). To make it more whitespace-friendly, I made a few modifications: your input is a bunch of numbers, and in every case the last number is a zero. Return the sum of the positive ones, and ignore the negatives.\n\n### Reversed strings\n\nThe previous ones operate only with numbers, I thought it would be fun to have one about strings. Your input is a word, in every case it will end with a SPACE character. Your code should return the word in reversed character order: ```word``` -> ```drow```.\n\nHave fun!\n\nFeel free to contact me, if you think your code should pass, but the interpreter is throwing an exception (but please first validate your solution using another whitespace compiler).",
    "totalAttempts": 24,
    "totalCompleted": 6,
    "totalStars": 3,
    "voteScore": 12,
    "tags": [
      "Algorithms",
      "Esoteric Languages"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 0,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}