{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5265b0885fda8eac5900093b",
  "data": {
    "id": "5265b0885fda8eac5900093b",
    "name": "Tiny Three-Pass Compiler",
    "slug": "tiny-three-pass-compiler",
    "category": "algorithms",
    "publishedAt": "2013-10-22T00:00:11.356Z",
    "approvedAt": null,
    "languages": [
      "javascript",
      "coffeescript",
      "python",
      "haskell",
      "java",
      "csharp",
      "cpp",
      "ocaml",
      "ruby",
      "c",
      "rust",
      "php",
      "dart"
    ],
    "url": "https://www.codewars.com/kata/5265b0885fda8eac5900093b",
    "rank": {
      "id": -1,
      "name": "1 kyu",
      "color": "purple"
    },
    "createdAt": "2013-10-21T22:54:00.473Z",
    "createdBy": {
      "username": "nklein",
      "url": "https://www.codewars.com/users/nklein"
    },
    "description": "You are writing a three-pass compiler for a simple programming language into a small assembly language.\n\nThe programming language has this syntax:\n\n```\n    function   ::= '[' arg-list ']' expression\n\n    arg-list   ::= /* nothing */\n                 | variable arg-list\n\n    expression ::= term\n                 | expression '+' term\n                 | expression '-' term\n\n    term       ::= factor\n                 | term '*' factor\n                 | term '/' factor\n\n    factor     ::= number\n                 | variable\n                 | '(' expression ')'\n```\n\nVariables are strings of alphabetic characters.  Numbers are strings of decimal digits representing integers.  So, for example, a function which computes a<sup>2</sup> + b<sup>2</sup> might look like:\n\n```\n    [ a b ] a*a + b*b\n```\n\nA function which computes the average of two numbers might look like:\n\n```\n    [ first second ] (first + second) / 2\n```\n\nYou need write a three-pass compiler.  All test cases will be valid programs, so you needn't concentrate on error-handling.\n\nThe first pass will be the method `pass1` which takes a string representing a function in the original programming language and will return a (JSON) object that represents that Abstract Syntax Tree.  The Abstract Syntax Tree must use the following representations:\n\n```javascript\n    { 'op': '+', 'a': a, 'b': b }    // add subtree a to subtree b\n    { 'op': '-', 'a': a, 'b': b }    // subtract subtree b from subtree a\n    { 'op': '*', 'a': a, 'b': b }    // multiply subtree a by subtree b\n    { 'op': '/', 'a': a, 'b': b }    // divide subtree a from subtree b\n    { 'op': 'arg', 'n': n }          // reference to n-th argument, n integer\n    { 'op': 'imm', 'n': n }          // immediate value n, n integer\n```\n```coffeescript\n    { 'op': '+', 'a': a, 'b': b }    // add subtree a to subtree b\n    { 'op': '-', 'a': a, 'b': b }    // subtract subtree b from subtree a\n    { 'op': '*', 'a': a, 'b': b }    // multiply subtree a by subtree b\n    { 'op': '/', 'a': a, 'b': b }    // divide subtree a from subtree b\n    { 'op': 'arg', 'n': n }          // reference to n-th argument, n integer\n    { 'op': 'imm', 'n': n }          // immediate value n, n integer\n```\n```python\n    { 'op': '+', 'a': a, 'b': b }    // add subtree a to subtree b\n    { 'op': '-', 'a': a, 'b': b }    // subtract subtree b from subtree a\n    { 'op': '*', 'a': a, 'b': b }    // multiply subtree a by subtree b\n    { 'op': '/', 'a': a, 'b': b }    // divide subtree a from subtree b\n    { 'op': 'arg', 'n': n }          // reference to n-th argument, n integer\n    { 'op': 'imm', 'n': n }          // immediate value n, n integer\n```\n```ruby\n    { 'op': '+', 'a': a, 'b': b }    // add subtree a to subtree b\n    { 'op': '-', 'a': a, 'b': b }    // subtract subtree b from subtree a\n    { 'op': '*', 'a': a, 'b': b }    // multiply subtree a by subtree b\n    { 'op': '/', 'a': a, 'b': b }    // divide subtree a from subtree b\n    { 'op': 'arg', 'n': n }          // reference to n-th argument, n integer\n    { 'op': 'imm', 'n': n }          // immediate value n, n integer\n```\n```php\n    { 'op': '+', 'a': a, 'b': b }    // add subtree a to subtree b\n    { 'op': '-', 'a': a, 'b': b }    // subtract subtree b from subtree a\n    { 'op': '*', 'a': a, 'b': b }    // multiply subtree a by subtree b\n    { 'op': '/', 'a': a, 'b': b }    // divide subtree a from subtree b\n    { 'op': 'arg', 'n': n }          // reference to n-th argument, n integer\n    { 'op': 'imm', 'n': n }          // immediate value n, n integer\n```\n```haskell\ndata AST = Imm Int      -- immediate value\n         | Arg Int      -- reference to n-th argument\n         | Add AST AST  -- add first to second\n         | Sub AST AST  -- subtract second from first\n         | Mul AST AST  -- multiply first by second\n         | Div AST AST  -- divide first by second\n```\n```java\n  // Each node type implements interface 'Ast' and has the\n  // following methods:\n  // interface Ast has method 'op()' returning 'String'\n  // BinOp has methods 'a()' and 'b()', both return 'Ast'\n  // UnOp has method 'n()' returning 'int'\n  new BinOp('+', a, b)       // add subtree a to subtree b\n  new BinOp('-', a, b)       // subtract subtree b from subtree a\n  new BinOp('*', a, b)       // multiply subtree a by subtree b\n  new BinOp('/', a, b)       // divide subtree a from subtree b\n  new UnOp('arg', n)         // reference to n-th argument, n integer\n  new UnOp('imm', n)         // immediate value n, n integer\n```\n```dart\n  // Each node type implements interface 'Ast' and has the\n  // following methods:\n  // interface Ast has method 'op()' returning 'String'\n  // BinOp has methods 'a()' and 'b()', both return 'Ast'\n  // UnOp has method 'n()' returning 'int'\n  new BinOp('+', a, b)       // add subtree a to subtree b\n  new BinOp('-', a, b)       // subtract subtree b from subtree a\n  new BinOp('*', a, b)       // multiply subtree a by subtree b\n  new BinOp('/', a, b)       // divide subtree a from subtree b\n  new UnOp('arg', n)         // reference to n-th argument, n integer\n  new UnOp('imm', n)         // immediate value n, n integer\n```\n\n```csharp\n  // Each node is of type 'Ast' and has the following methods:\n  // Ast has method 'op()' returning 'String'\n  // BinOp has methods 'a()' and 'b()', both return 'Ast'\n  // UnOp has method 'n()' returning 'int'\n  new BinOp('+', a, b)       // add subtree a to subtree b\n  new BinOp('-', a, b)       // subtract subtree b from subtree a\n  new BinOp('*', a, b)       // multiply subtree a by subtree b\n  new BinOp('/', a, b)       // divide subtree a from subtree b\n  new UnOp('arg', n)         // reference to n-th argument, n integer\n  new UnOp('imm', n)         // immediate value n, n integer\n```\n\n```cpp\n  // Each node is of type 'AST' and has the following fields:\n  // 'string op', 'AST* a', 'AST* b', and 'int n'\n  AST (\"+\", a, b)       // add subtree a to subtree b\n  AST (\"-\", a, b)       // subtract subtree b from subtree a\n  AST (\"*\", a, b)       // multiply subtree a by subtree b\n  AST (\"/\", a, b)       // divide subtree a from subtree b\n  AST (\"arg\", n)        // reference to n-th argument, n integer\n  AST (\"imm\", n)        // immediate value n, n integer\n```\n```ocaml\ntype ast =\n  | Imm of int  (* immediate value *)\n  | Arg of int  (* reference to n-th argument *)\n  | Add of (ast * ast) (* add first to second *)\n  | Sub of (ast * ast) (* subtract second from first *)\n  | Mul of (ast * ast) (* multiply first by second *)\n  | Div of (ast * ast) (* divide first by second *)\n```\n\n```c\n  // Each node is a struct of type 'AST' and has the following fields:\n  // 'enum op op', 'AST* a', 'AST* b', and 'int n' (unused fields are 0)\n  Bin (add, a, b)       // add subtree a to subtree b\n  Bin (sub, a, b)       // subtract subtree b from subtree a\n  Bin (mul, a, b)       // multiply subtree a by subtree b\n  Bin (div, a, b)       // divide subtree a from subtree b\n  Arg (n)               // reference to n-th argument, n integer\n  Imm (n)               // immediate value n, n integer\n```\n```rust\n// Each node is an enum of type `AST` with the following fields:\nAst::BinOp(Operator::Add, Box::new(a), Box::new(b)) // add subtree a to subtree b\nAst::BinOp(Operator::Sub, Box::new(a), Box::new(b)) // subtract subtree b from subtree a\nAst::BinOp(Operator::Mul, Box::new(a), Box::new(b)) // multiply subtree a by subtree b\nAst::BinOp(Operator::Div, Box::new(a), Box::new(b)) // divide subtree a from subtree b\nAst::Value(Source::Arg, n) // reference to n-th argument, n integer\nAst::Value(Source::Imm, n) // immediate value n, n integer\n// Note: A convenience method Ast::binop(op, a, b) is provided that will box the two\n// subtrees.\n```\n\n\nNote: arguments are indexed from zero.  So, for example, the function\n\n`[ x y ] ( x + y ) / 2` would look like:\n\n```javascript\n    { 'op': '/', 'a': { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                                   'b': { 'op': 'arg', 'n': 1 } },\n                 'b': { 'op': 'imm', 'n': 2 } }\n```\n```coffeescript\n    { 'op': '/', 'a': { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                                   'b': { 'op': 'arg', 'n': 1 } },\n                 'b': { 'op': 'imm', 'n': 2 } }\n```\n```python\n    { 'op': '/', 'a': { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                                   'b': { 'op': 'arg', 'n': 1 } },\n                 'b': { 'op': 'imm', 'n': 2 } }\n```\n```ruby\n    { 'op': '/', 'a': { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                                   'b': { 'op': 'arg', 'n': 1 } },\n                 'b': { 'op': 'imm', 'n': 2 } }\n```\n```php\n    { 'op': '/', 'a': { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                                   'b': { 'op': 'arg', 'n': 1 } },\n                 'b': { 'op': 'imm', 'n': 2 } }\n```\n```haskell\n(Div (Add (Arg 0) (Arg 1))\n     (Imm 2))\n```\n```java\n  new BinOp(\"/\", new BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"arg\", 1)), new UnOp(\"imm\", 2))\n```\n```dart\n  new BinOp(\"/\", new BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"arg\", 1)), new UnOp(\"imm\", 2))\n```\n```csharp\n  new BinOp(\"/\", new BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"arg\", 1)), new UnOp(\"imm\", 2))\n```\n```cpp\n  new AST (\"/\", new AST (\"+\", new AST (\"arg\", 0), new AST (\"arg\", 1)), new AST (\"imm\", 2))\n```\n```ocaml\nDiv(Add(Arg 0,Arg 1), Imm 2)\n```\n```c\n  Bin (div, Bin (add, Arg (0), Arg (1)), Imm (2))\n```\n```rust\nuse {Operator::*, Source::*};\nAst::binop(\n    Div,\n    Ast::binop(Add, Ast::Value(Arg, 0), Ast::Value(Arg, 1)),\n    Ast::Value(Imm, 2),\n)\n```\n\n\nThe second pass of the compiler will be called `pass2`.  This pass will take the output from `pass1` and return a new Abstract Syntax Tree (with the same format) with all constant expressions reduced as much as possible.  So, if for example, the function is `[ x ] x + 2*5`, the result of `pass1` would be:\n\n```javascript\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': '*', 'a': { 'op': 'imm', 'n': 2 },\n                                   'b': { 'op': 'imm', 'n': 5 } } }\n```\n```coffeescript\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': '*', 'a': { 'op': 'imm', 'n': 2 },\n                                   'b': { 'op': 'imm', 'n': 5 } } }\n```\n```python\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': '*', 'a': { 'op': 'imm', 'n': 2 },\n                                   'b': { 'op': 'imm', 'n': 5 } } }\n```\n```ruby\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': '*', 'a': { 'op': 'imm', 'n': 2 },\n                                   'b': { 'op': 'imm', 'n': 5 } } }\n```\n```php\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': '*', 'a': { 'op': 'imm', 'n': 2 },\n                                   'b': { 'op': 'imm', 'n': 5 } } }\n```\n```haskell\n(Add (Arg 0)\n     (Mul (Imm 2) (Imm 5)))\n```\n```java\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new BinOp(\"*\", new UnOp(\"imm\", 2), new UnOp(\"imm\", 5)))\n```\n```dart\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new BinOp(\"*\", new UnOp(\"imm\", 2), new UnOp(\"imm\", 5)))\n```\n```csharp\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new BinOp(\"*\", new UnOp(\"imm\", 2), new UnOp(\"imm\", 5)))\n```\n```cpp\nnew AST (\"+\", new AST (\"arg\", 0), new AST (\"*\", new AST (\"imm\", 2), new AST (\"imm\", 5)))\n```\n```ocaml\nAdd(Arg 0, Mul(Imm 2, Imm 5))\n```\n```c\n  Bin (add, Arg (0), Bin (mul, Imm (2), Imm (5)))\n```\n```rust\nuse {Operator::*, Source::*};\nAst::binop(\n    Add,\n    Ast::Value(Arg, 0),\n    Ast::binop(Mul, Ast::Value(Imm, 2), Ast::Value(Imm, 5)),\n)\n```\n\nThis would be passed into `pass2` which would return:\n\n```javascript\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': 'imm', 'n': 10 } }\n```\n```coffeescript\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': 'imm', 'n': 10 } }\n```\n```python\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': 'imm', 'n': 10 } }\n```\n```ruby\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': 'imm', 'n': 10 } }\n```\n```php\n    { 'op': '+', 'a': { 'op': 'arg', 'n': 0 },\n                 'b': { 'op': 'imm', 'n': 10 } }\n```\n```haskell\n(Add (Arg 0) (Imm 10))\n```\n```java\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"imm\", 10))\n```\n```dart\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"imm\", 10))\n```\n```csharp\nnew BinOp(\"+\", new UnOp(\"arg\", 0), new UnOp(\"imm\", 10))\n```\n```cpp\nnew AST (\"+\", new AST (\"arg\", 0), new AST (\"imm\", 10))\n```\n```ocaml\nAdd(Arg 0, Imm 10)\n```\n```c\n  Bin (add, Arg (0), Imm (10))\n```\n```rust\nuse {Operator::*, Source::*};\nAst::binop(Add, Ast::Value(Arg, 0), Ast::Value(Imm, 10))\n```\n\n\nThe third pass of the compiler is `pass3`.  The `pass3` method takes in an Abstract Syntax Tree and returns an array of strings.  Each string is an assembly directive.  You are working on a small processor with two registers (`R0` and `R1`), a stack, and an array of input arguments.  The result of a function is expected to be in `R0`.  The processor supports the following instructions:\n\n```\n    \"IM n\"     // load the constant value n into R0\n    \"AR n\"     // load the n-th input argument into R0\n    \"SW\"       // swap R0 and R1\n    \"PU\"       // push R0 onto the stack\n    \"PO\"       // pop the top value off of the stack into R0\n    \"AD\"       // add R1 to R0 and put the result in R0\n    \"SU\"       // subtract R1 from R0 and put the result in R0\n    \"MU\"       // multiply R0 by R1 and put the result in R0\n    \"DI\"       // divide R0 by R1 and put the result in R0\n```\n\nSo, one possible return value from `pass3` given the Abstract Syntax Tree shown above from `pass2` is:\n\n```\n    [ \"IM 10\", \"SW\", \"AR 0\", \"AD\" ]\n```\n\nHere is a simulator for the target machine.  It takes an array of assembly instructions and an array of arguments and returns the result.\n```javascript\nfunction simulate(asm, args) {\n\t  var r0 = undefined;\n\t  var r1 = undefined;\n\t  var stack = [];\n\t  asm.forEach(function (instruct) {\n\t    var match = instruct.match(/(IM|AR)\\s+(\\d+)/) || [ 0, instruct, 0 ];\n\t    var ins = match[1];\n\t    var n = match[2] | 0;\n\t\n\t    if (ins == 'IM')   { r0 = n; }\n\t    else if (ins == 'AR') { r0 = args[n]; }\n\t    else if (ins == 'SW') { var tmp = r0; r0 = r1; r1 = tmp; }\n\t    else if (ins == 'PU') { stack.push(r0); }\n\t    else if (ins == 'PO') { r0 = stack.pop(); }\n\t    else if (ins == 'AD') { r0 += r1; }\n\t    else if (ins == 'SU') { r0 -= r1; }\n\t    else if (ins == 'MU') { r0 *= r1; }\n\t    else if (ins == 'DI') { r0 /= r1; }\n\t  });\n\t  return r0;\n\t}\n```\n```coffeescript\nsimulate = (asm, args) ->\n  r0 = undefined;\n  r1 = undefined;\n  stack = [];\n  swap = () -> tmp = r0; r0 = r1; r1 = tmp;\n  for instruct in asm\n    match = instruct.match(/(IM|AR)\\s+(\\d+)/) || [ 0, instruct, 0 ];\n    ins = match[1];\n    n = match[2] | 0;\n\n    if (ins == 'IM')      then r0 = n\n    else if (ins == 'AR') then r0 = args[n]\n    else if (ins == 'SW') then swap()\n    else if (ins == 'PU') then stack.push(r0)\n    else if (ins == 'PO') then r0 = stack.pop()\n    else if (ins == 'AD') then r0 += r1\n    else if (ins == 'SU') then r0 -= r1\n    else if (ins == 'MU') then r0 *= r1\n    else if (ins == 'DI') then r0 /= r1\n  r0\n```\n```python\ndef simulate(asm, argv):\n    r0, r1 = None, None\n    stack = []\n    for ins in asm:\n        if ins[:2] == 'IM' or ins[:2] == 'AR':\n            ins, n = ins[:2], int(ins[2:])\n        if ins == 'IM':   r0 = n\n        elif ins == 'AR': r0 = argv[n]\n        elif ins == 'SW': r0, r1 = r1, r0\n        elif ins == 'PU': stack.append(r0)\n        elif ins == 'PO': r0 = stack.pop()\n        elif ins == 'AD': r0 += r1\n        elif ins == 'SU': r0 -= r1\n        elif ins == 'MU': r0 *= r1\n        elif ins == 'DI': r0 /= r1\n    return r0\n```\n```ruby\ndef simulate(asm, argv)\n    r0, r1 = 0, 0\n    stack = []\n    asm.each do |ins|\n        if ins[0..1] == 'IM' or ins[0..1] == 'AR'\n            ins, n = ins[0..1], ins[2..-1].to_i\n        end\n        if ins == 'IM'    then r0 = n\n        elsif ins == 'AR' then r0 = argv[n]\n        elsif ins == 'SW' then r0, r1 = r1, r0\n        elsif ins == 'PU' then stack.push(r0)\n        elsif ins == 'PO' then r0 = stack.pop()\n        elsif ins == 'AD' then r0 += r1\n        elsif ins == 'SU' then r0 -= r1\n        elsif ins == 'MU' then r0 *= r1\n        elsif ins == 'DI' then r0 /= r1\n        end\n    end\n    return r0\nend\n```\n```php\nfunction simulate($asm, $argv) {\n    list($r0, $r1) = [0, 0];\n    $stack = [];\n    foreach ($asm as $ins) {\n        if (substr($ins, 0, 2) == 'IM' || substr($ins, 0, 2) == 'AR') {\n            list($ins, $n) = [substr($ins, 0, 2), intval(substr($ins, 2))];\n        }\n        if ($ins == 'IM')      $r0 = $n;\n        else if ($ins == 'AR') $r0 = $argv[$n];\n        else if ($ins == 'SW') list($r0, $r1) = [$r1, $r0];\n        else if ($ins == 'PU') array_push($stack, $r0);\n        else if ($ins == 'PO') $r0 = array_pop($stack);\n        else if ($ins == 'AD') $r0 += $r1;\n        else if ($ins == 'SU') $r0 -= $r1;\n        else if ($ins == 'MU') $r0 *= $r1;\n        else if ($ins == 'DI') $r0 /= $r1;\n    }\n    return $r0;\n}\n```\n```haskell\nsimulate :: [String] -> [Int] -> Int\nsimulate asm argv = takeR0 $ foldl' step (0, 0, []) asm where\n  step (r0,r1,stack) ins =\n    case ins of\n      ('I':'M':xs) -> (read xs, r1, stack)\n      ('A':'R':xs) -> (argv !! n, r1, stack) where n = read xs\n      \"SW\" -> (r1, r0, stack)\n      \"PU\" -> (r0, r1, r0:stack)\n      \"PO\" -> (head stack, r1, tail stack)\n      \"AD\" -> (r0 + r1, r1, stack)\n      \"SU\" -> (r0 - r1, r1, stack)\n      \"MU\" -> (r0 * r1, r1, stack)\n      \"DI\" -> (r0 `div` r1, r1, stack)\n  takeR0 (r0,_,_) = r0\n```\n```dart\n\nclass Simulator {\n  static int simulate(List<String> asm, List<int> argv) {\n    int r0 = 0;\n    int r1 = 0;\n    List<int> stack = new List();\n    asm.forEach((ins) {\n      switch (ins.substring(0, 2)) {\n        case \"IM\":\n          r0 = int.parse(ins.substring(2).trim());\n          break;\n        case \"AR\":\n          r0 = argv[int.parse(ins.substring(2).trim())];\n          break;\n        case \"SW\":\n          int tmp = r0;\n          r0 = r1;\n          r1 = tmp;\n          break;\n        case \"PU\":\n          stack.add(r0);\n          break;\n        case \"PO\":\n          r0 = stack.removeLast();\n          break;\n        case \"AD\":\n          r0 += r1;\n          break;\n        case \"SU\":\n          r0 -= r1;\n          break;\n        case \"MU\":\n          r0 *= r1;\n          break;\n        case \"DI\":\n          r0 ~/= r1;\n          break;\n      }\n    });\n    return r0;\n  }\n}\n```\n```java\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\n\nclass Simulator {\n  public static int simulate(List<String> asm, int... argv) {\n    int r0 = 0;\n    int r1 = 0;\n    Deque<Integer> stack = new LinkedList<>();\n    for (String ins : asm) {\n      String code = ins.replaceAll(\"\\\\s+[0-9]+\", \"\");\n      switch (code) {\n        case \"IM\": r0 = Integer.parseInt(ins.substring(2).trim()); break;\n        case \"AR\": r0 = argv[Integer.parseInt(ins.substring(2).trim())]; break;\n        case \"SW\": int tmp = r0; r0 = r1; r1 = tmp; break;\n        case \"PU\": stack.addLast(r0); break;\n        case \"PO\": r0 = stack.removeLast(); break;\n        case \"AD\": r0 += r1; break;\n        case \"SU\": r0 -= r1; break;\n        case \"MU\": r0 *= r1; break;\n        case \"DI\": r0 /= r1; break;\n      }\n    }\n    return r0;\n  }\n}\n```\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Simulator\n{\n  public static int simulate(List<string> asm, int[] argv)\n  {\n    int r0 = 0;\n    int r1 = 0;\n    List<int> stack = new List<int>();\n    foreach (string ins in asm)\n    {\n      string code = ins.Substring(0,2);\n      switch (code)\n      {\n        case \"IM\": r0 = Int32.Parse(ins.Substring(2).Trim()); break;\n        case \"AR\": r0 = argv[Int32.Parse(ins.Substring(2).Trim())]; break;\n        case \"SW\": int tmp = r0; r0 = r1; r1 = tmp; break;\n        case \"PU\": stack.Add(r0); break;\n        case \"PO\": r0 = stack[stack.Count - 1]; stack.RemoveAt(stack.Count - 1); break;\n        case \"AD\": r0 += r1; break;\n        case \"SU\": r0 -= r1; break;\n        case \"MU\": r0 *= r1; break;\n        case \"DI\": r0 /= r1; break;\n      }\n    }\n    return r0;\n  }\n}\n```\n```cpp\n#include <vector>\n#include <stack>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nint simulate (const vector <string> &assembly, const vector <int> &argv) {\n  int r0 = 0, r1 = 0;\n  stack <int> istack;\n  for (auto &ins : assembly) {\n    string code = ins.substr (0, 2);\n         if (code == \"IM\") { r0 = stoi (ins.substr (3)); }\n    else if (code == \"AR\") { r0 = argv.at (stoi (ins.substr (3))); }\n    else if (code == \"SW\") { swap (r0, r1); }\n    else if (code == \"PU\") { istack.push (r0); }\n    else if (code == \"PO\") { r0 = istack.top (); istack.pop (); }\n    else if (code == \"AD\") { r0 += r1; }\n    else if (code == \"SU\") { r0 -= r1; }\n    else if (code == \"MU\") { r0 *= r1; }\n    else if (code == \"DI\") { r0 /= r1; }\n  }\n  return r0;\n}\n```\n```ocaml\nlet rec simualte : string list * int list -> int =\n  let stack = Stack.create () in\n  let r0 = ref 0 in\n  let r1 = ref 0 in\n  function\n  | ([],argumets) -> !r0\n  | (\"SU\"::lst,argumets) ->\n     r0 := !r0 - !r1;\n     simualte(lst,argumets)\n  | (\"DI\"::lst,argumets) ->\n     r0 := !r0 / !r1;\n     simualte(lst,argumets)\n  | (\"MU\"::lst,argumets) ->\n     r0 := !r0 * !r1;\n     simualte(lst,argumets)\n  | (\"AD\"::lst,argumets) ->\n     r0 := !r0 + !r1;\n     simualte(lst,argumets)\n  | (\"PU\"::lst,argumets) ->\n     Stack.push !r0 stack;\n     simualte(lst,argumets)\n  | (\"PO\"::lst,argumets) ->\n     r0 := (Stack.pop stack);\n     simualte(lst,argumets)\n  | (\"SW\"::lst,argumets) ->\n     let tmp = !r0 in\n     r0 := !r1;\n     r1 := tmp;\n     simualte(lst,argumets)\n  | (op::lst,argumets) ->\n     let op_code = String.sub op 0 2 in\n     let value =\n       int_of_string\n         (String.sub op 3 ((String.length op) - 3))\n     in\n     match op_code with\n     | \"IM\" ->\n        r0 := value;\n        simualte(lst,argumets)\n     | \"AR\" ->\n        r0 := List.nth argumets value;\n        simualte(lst,argumets)\n     | _ -> raise (CompilerError \"bad assembly\")\n\n```\n\n```c\n#include <stdlib.h>\n#include <string.h>\n\n// stack push (int) and pop () function defintions\n\nint simulate (const char *ins, const int *args) {\n  int r0 = 0, r1 = 0, t;\n  for (; ins && *ins; (ins = strchr (ins, '\\n')) ? ++ins : 0x60d1510f)\n         if (!memcmp (ins, \"IM\", 2)) r0 = atoi (ins+3);\n    else if (!memcmp (ins, \"AR\", 2)) r0 = args[atoi (ins+3)];\n    else if (!memcmp (ins, \"SW\", 2)) t = r0, r0 = r1, r1 = t;\n    else if (!memcmp (ins, \"PU\", 2)) push (r0);\n    else if (!memcmp (ins, \"PO\", 2)) r0 = pop ();\n    else if (!memcmp (ins, \"AD\", 2)) r0 += r1;\n    else if (!memcmp (ins, \"SU\", 2)) r0 -= r1;\n    else if (!memcmp (ins, \"MU\", 2)) r0 *= r1;\n    else if (!memcmp (ins, \"DI\", 2)) r0 /= r1;\n  return r0;\n}\n```\n```rust\nfn simulate(assembly: &Vec<String>, argv: Vec<i32>) -> i32 {\n    let mut r = (0, 0);\n    let mut stack: Vec<i32> = vec![];\n    let num = |opt: Option<&str>| opt.unwrap().parse::<i32>().unwrap();\n\n    for ins in assembly {\n        let mut ws = ins.split_whitespace();\n        match ws.next() {\n            Some(\"IM\") => r.0 = num(ws.next()),\n            Some(\"AR\") => r.0 = argv[num(ws.next()) as usize],\n            Some(\"SW\") => r = (r.1, r.0),\n            Some(\"PU\") => stack.push(r.0),\n            Some(\"PO\") => r.0 = stack.pop().unwrap(),\n            Some(\"AD\") => r.0 += r.1,\n            Some(\"SU\") => r.0 -= r.1,\n            Some(\"MU\") => r.0 *= r.1,\n            Some(\"DI\") => r.0 /= r.1,\n            _ => panic!(\"Invalid instruction encountered\"),\n        }\n    }\n    r.0\n}\n```\n",
    "totalAttempts": 31867,
    "totalCompleted": 2952,
    "totalStars": 1190,
    "voteScore": 560,
    "tags": [
      "Compilers",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 18,
      "suggestions": 12
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}