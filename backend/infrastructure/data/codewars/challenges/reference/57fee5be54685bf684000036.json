{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/57fee5be54685bf684000036",
  "data": {
    "id": "57fee5be54685bf684000036",
    "name": "Practical Interview Prep: Binary Search Tree .contains()",
    "slug": "practical-interview-prep-binary-search-tree-contains",
    "category": "reference",
    "publishedAt": "2016-10-13T01:39:12.540Z",
    "approvedAt": null,
    "languages": [
      "javascript"
    ],
    "url": "https://www.codewars.com/kata/57fee5be54685bf684000036",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2016-10-13T01:39:10.550Z",
    "createdBy": {
      "username": "ish2f4f",
      "url": "https://www.codewars.com/users/ish2f4f"
    },
    "description": "# Binary Search Trees - Create .contains\n## The Problem\nThe contains function will check whether a value exists inside the binary search tree.  \nWrite the `contains` function for Binary Search Trees given the following code:\n\n```\nfunction Node(val){\n  this.val = val;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BST(){\n  this.root = null;\n}\n```\n\n**NOTE: this problem uses the left child if a value is equal**\n\n## The Data Structure\nBinary Search Trees (BSTs) are data structures that provide for fast lookup, addition, and removal.\n\nAt each node in the tree, there are three values: the value stored at that node, the left child, and the right child. Each node has a left and a right child that are also nodes. Each left child's value is less than the value of its parent's value and the right child's value is greater than the value of its parent. Because of this, when traversing the tree from the root node to a specific node, the nodes required to search reduce in half -- thereby performing binary search.\n\nBSTs have the advantage of not needing to reserve more memory than necessary, as would be the case for hashtables or arrays.\n\n## Run Time Analysis\nAverage:  \nSpace: O(n)  \nSearch: O(log n)  \nInsert: O(log n)  \nDelete: O(log n)\n\n## Strengths\n* Store in sorted order\n* Efficiently support range queries\n* Efficiently support nearest-neighbor queries\n* Better worst-case guarantees\n\n[More Information on BST Strengths/Applications](http://stackoverflow.com/questions/5010854/concrete-examples-of-using-binary-search-trees?noredirect=1&lq=1)",
    "totalAttempts": 337,
    "totalCompleted": 31,
    "totalStars": 2,
    "voteScore": 6,
    "tags": [
      "Binary Search Trees",
      "Data Structures",
      "Trees",
      "Fundamentals"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 3,
      "suggestions": 1
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}