{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/53efa66adcb09cd1cd00003e",
  "data": {
    "id": "53efa66adcb09cd1cd00003e",
    "name": "Look-and-Say Numbers",
    "slug": "look-and-say-numbers-1",
    "category": "games",
    "publishedAt": "2014-08-16T19:08:13.039Z",
    "approvedAt": null,
    "languages": [
      "javascript",
      "coffeescript"
    ],
    "url": "https://www.codewars.com/kata/53efa66adcb09cd1cd00003e",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2014-08-16T18:43:54.901Z",
    "createdBy": {
      "username": "nooga",
      "url": "https://www.codewars.com/users/nooga"
    },
    "description": "Consider the following sequence:\n\n```\n1. 1\n2. 1 1\n3. 2 1\n4. 1 2 1 1\n5. 1 1 1 2 2 1 \n   ...\n```\nThink for a while and try to find the pattern which makes subsequent elements from their predecesors.\n\nOnce you're done with thinking - write function `las` that, given the previous sequence element, returns the next sequence element.\n\nHere are some examples:\n```\nlas()   ==    las(1)    == []    // Return [] if the argument is not an array\nlas([\"\", 1, \"a\", -1, 0])== [1,1] // Ignore everything that's not a positive number\nlas([])                 == []\nlas([1])                == [1, 1]\nlas([1, 1, 1, 2, 2, 1]) == [3, 1, 2, 2, 1, 1]\n```",
    "totalAttempts": 508,
    "totalCompleted": 52,
    "totalStars": 1,
    "voteScore": 69,
    "tags": [
      "Puzzles",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 2,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}