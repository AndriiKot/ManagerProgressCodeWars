{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5840bf7d6312ce9a2000017f",
  "data": {
    "id": "5840bf7d6312ce9a2000017f",
    "name": "Auto program generation",
    "slug": "auto-program-generation",
    "category": "algorithms",
    "publishedAt": "2016-12-02T02:47:10.894Z",
    "approvedAt": null,
    "languages": [
      "haskell"
    ],
    "url": "https://www.codewars.com/kata/5840bf7d6312ce9a2000017f",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2016-12-02T00:25:33.360Z",
    "createdBy": {
      "username": "surtich",
      "url": "https://www.codewars.com/users/surtich"
    },
    "description": "Consider a machine with registers *r<sub>1</sub>* up to *r<sub>n</sub>*, organized in a ring. This machine\nhas only two instructions:\n\n  * `move(i)` copies the contents of *r<sub>i</sub>* to *r<sub>i+1</sub>* for *1 ≤ i < n*, and from *r<sub>n</sub>* to *r<sub>1</sub>* for i = n.\n  * `swap(i,j)` swaps the contents of *r<sub>i</sub>* and *r<sub>j</sub>* for *1 ≤ i < j ≤ n*.\n\n  You get the initial contents of all registers (some can be wild cards) and the\ndesired final contents of all registers (again some can be wild cards). Generate\nall shortest instruction sequences of `move` and `swap` that transforms the initial\ncontents into the final contents.\n\n  Write the function `codegen` whose first argument is a list of the initial\ncontents of the registers, and whose second argument is their final contents. The result is the\nsequence of instructions that effectuate the transition, as in\n\n```haskell\ncodegen([a,b,c],[b,b,c], [[swap(1,2),move(1)]])\n```\nWild cards are represented as a *. Initially, their meaning is \"don’t know the\ncontents\"; in the description of the final contents, they mean \"don’t care about the\ncontents\". Accordingly:\n\n```haskell\ncodegen(['a',*,'c'], ['c','a',*], [[move(1),move(3)],[move(1),swap(1,3)],[swap(1,2),move(3)],[swap(1,2),swap(1,3)],[swap(1,3),swap(2,3)],[swap(2,3),swap(1,2)]]) -- there are six correct answers.\n```\n\nOne more example:\n\n```haskell\ncodegen(['a','b','c'], ['a','a',*], [[move(1)]])\n\n```\n\nAnd the last one:\n\n```haskell\ncodegen([*,*,*,*], ['a','a','a','a'], []) -- No solutions!!!\n```\n\nIn the code are defined the types and functions for Haskekll.",
    "totalAttempts": 102,
    "totalCompleted": 6,
    "totalStars": 6,
    "voteScore": 3,
    "tags": [
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 2
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}