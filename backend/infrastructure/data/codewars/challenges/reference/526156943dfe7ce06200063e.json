{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/526156943dfe7ce06200063e",
  "data": {
    "id": "526156943dfe7ce06200063e",
    "name": "My smallest code interpreter (aka Brainf**k)",
    "slug": "my-smallest-code-interpreter-aka-brainf-star-star-k",
    "category": "algorithms",
    "publishedAt": "2013-10-18T17:35:02.599Z",
    "approvedAt": null,
    "languages": [
      "javascript",
      "python",
      "ruby",
      "haskell",
      "clojure",
      "java",
      "crystal",
      "php",
      "cpp",
      "typescript",
      "rust",
      "c",
      "bf",
      "coffeescript",
      "swift",
      "csharp",
      "elixir",
      "dart",
      "groovy",
      "kotlin",
      "factor",
      "cobol"
    ],
    "url": "https://www.codewars.com/kata/526156943dfe7ce06200063e",
    "rank": {
      "id": -5,
      "name": "5 kyu",
      "color": "yellow"
    },
    "createdAt": "2013-10-18T15:41:08.014Z",
    "createdBy": {
      "username": "ssineriz",
      "url": "https://www.codewars.com/users/ssineriz"
    },
    "description": "Inspired from real-world [Brainf\\*\\*k](http://en.wikipedia.org/wiki/Brainfuck), we want to create an interpreter of that language which will support the following instructions:\n\n* `>` increment the data pointer (to point to the next cell to the right).\n* `<` decrement the data pointer (to point to the next cell to the left).\n* `+` increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.\n* `-` decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.\n* `.` output the byte at the data pointer.\n* `,` accept one byte of input, storing its value in the byte at the data pointer.\n* `[` if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching `]` command.\n* `]` if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching `[` command.\n\nThe function will take in input...\n\n* the program code, a string with the sequence of machine instructions,\n* the program input, a string, possibly empty, that will be interpreted as an array of bytes using each character's ASCII code and will be consumed by the `,` instruction\n\n... and will return ...\n\n* the output of the interpreted code (always as a string), produced by the `.` instruction.\n\nImplementation-specific details for this Kata:\n\n- Your memory tape should be large enough - the original implementation had 30,000 cells but a few thousand should suffice for this Kata\n- Each cell should hold an unsigned byte with wrapping behavior (i.e. 255 + 1 = 0, 0 - 1 = 255), initialized to 0\n- The memory pointer should initially point to a cell in the tape with a sufficient number (e.g. a few thousand or more) of cells to its right. For convenience, you may want to have it point to the leftmost cell initially\n- You may assume that the `,` command will never be invoked when the input stream is exhausted\n- Error-handling, e.g. unmatched square brackets and/or memory pointer going past the leftmost cell is not required in this Kata. If you see test cases that require you to perform error-handling then please open an Issue in the Discourse for this Kata (don't forget to state which programming language you are attempting this Kata in).\n\n~~~if:bf\nFor BF: The code and input are separated by `'!'`.\n~~~\n\n~~~if:rust\nFor Rust: Input and output are `Vec<u8>`.\n~~~\n",
    "totalAttempts": 77665,
    "totalCompleted": 8546,
    "totalStars": 1991,
    "voteScore": 1328,
    "tags": [
      "Interpreters",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 9,
      "suggestions": 9
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}