{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5bd4c8977645b9a02d00018c",
  "data": {
    "id": "5bd4c8977645b9a02d00018c",
    "name": "CS 208 - Binary Tree Insert",
    "slug": "cs-208-binary-tree-insert",
    "category": "algorithms",
    "publishedAt": "2018-10-29T17:37:37.435Z",
    "approvedAt": null,
    "languages": [
      "clojure"
    ],
    "url": "https://www.codewars.com/kata/5bd4c8977645b9a02d00018c",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2018-10-27T20:20:40.090Z",
    "createdBy": {
      "username": "spacdog",
      "url": "https://www.codewars.com/users/spacdog"
    },
    "description": "Insert values into a Binary Search Tree (BST).\n\nWe will represent a BST as a vector containing three elements: the value, the left subtree, and the right subtree.\n\nFor example, a tree with 5 as the root and no left child or right child would be written like this:\n\n`[5 nil nil]`\n\nThe BST with 5 at the root, 3 as the left child, and 7 as the right child would look like this:\n\n`[5 [3 nil nil] [7 nil nil]]`\n\nSome implementation details:\n\n* Your insert function should be able to insert 0 or more values. Inserting zero values just returns the tree, like this:\n\n`(insert [5 nil nil])` => `[5 nil nil]`\n\n* an empty tree is represented as `nil`\n\n* Assume that the list of numbers to be inserted does *not* contain duplicates\n\n* Remember you can use apply with insert.\n\n* Insert the values in the order they are given, or else the tree will be different.\n",
    "totalAttempts": 67,
    "totalCompleted": 28,
    "totalStars": 1,
    "voteScore": 2,
    "tags": [
      "Binary Search Trees",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 2,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}