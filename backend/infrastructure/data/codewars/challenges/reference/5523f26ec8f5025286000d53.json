{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5523f26ec8f5025286000d53",
  "data": {
    "id": "5523f26ec8f5025286000d53",
    "name": "The Enigma Machine - Part 3: The Reflector",
    "slug": "the-enigma-machine-part-3-the-reflector",
    "category": "algorithms",
    "publishedAt": "2015-04-07T16:01:27.917Z",
    "approvedAt": null,
    "languages": [
      "python"
    ],
    "url": "https://www.codewars.com/kata/5523f26ec8f5025286000d53",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2015-04-07T15:06:22.279Z",
    "createdBy": {
      "username": "ChristianECooper",
      "url": "https://www.codewars.com/users/ChristianECooper"
    },
    "description": "In this series of Kata, we will be implementing a software version of the [Enigma Machine](http://en.wikipedia.org/wiki/Enigma_machine).\n\nThe Enigma Machine was a message enciphering/deciphering machine used during the Second World War for disguising the content of military communications. [Alan Turing](http://en.wikipedia.org/wiki/Alan_Turing) - the father of computing - formulated and developed concepts that are the basis of all computers in use today, he did this in response to the vital need to break those military communications. Turing and his colleagues at [Bletchley Park](http://en.wikipedia.org/wiki/Bletchley_Park) are generally recognised as being responsible for shortening WWII by two years and saving an estimated 22 Mi`llion lives.\n\nThe Enigma Machine consisted of a number of parts: Keyboard for input, rotors and plugboard for enciphering, and lampboard for output.\n\nWe will simulate input and output with strings, and build the rotors, plugboard and mechanism that used them in software. As we progress the code will become more complex, so you are advised to attempt them in order.\n\nStep 1: The [Plugboard (Kata)](http://www.codewars.com/kata/5523b97ac8f5025c45000900)\n\nStep 2: A [Rotor (Kata)](http://www.codewars.com/kata/5523d69ec8f5025540000b47)\n\nStep 3: The [Reflector (Wikipedia)](http://en.wikipedia.org/wiki/Enigma_machine#Reflector)\n\nIn this Kata, you must implement the reflector component. The reflector is a device that acts like a plugboard, and can act like a rotor all at the same time. It cross-wires all letters together in pairs, so that an input of one letter *always* generated output as a different letter. The reflector was placed to the left of the left-most rotor in the Enigma Machine, modified the incoming signal and then reflected it back through the rotors in reverse order.\n\nThe reflector meant that with the same initial settings typing a plaintext message generated cipher-text on the lampboard and typing cipher-text generated plaintext. However, it would never allow a letter to be enciphered to itself, and it was this critical cryptographic flaw that enabled the reverse engineering of the Enigma Machine by Turing and his cohort.\n\n### Physical Description\nThe reflector was initially a very simple device. It had 13 fixed connections between 26 input/output terminals and did not move. However in later versions it could be configured in a number of ways, and its cryptographic value evolved with certain iterations of the Enigma Machine as it was improved.\n\nThe second version allowed the reflector to be inserted into the machine in either of two positions, the third version allowed for 26 positions, the fourth iteration allowed for additional rotation like the rotors and finally in a the fifth version, the reflector could be rewired internally, like a miniature 13-wire plugboard.\n\n### Nomenclature\nFor the sake of clarity we will denote:\n\n* a reflector input/output with *i*, and,\n* a rotational position of the reflector with *p*.\n\n### Initial Position Effect\nIf we have wiring so that in position *P*A, there is a mapping *r*A <-> *r*B, then inserting the same reflector in position *p*N would mean there is a mapping *r*N <-> *r*O.\n\n### Rotation Effect\nIf we have wiring so that in position *p*A, there is a mapping *r*A <-> *r*B, then after the first rotation we have a mapping *r*B <-> *r*C, after the second rotation we have a mapping *r*C <-> *r*D, and so on.\nAs with the rotors, rotation occurs before encipherment.\n\n### Note\nIn the actual usage of the original Enigma Machine, punctuation was encoded as words transmitted in the stream, in our code, anything that is not in the range A-Z will be returned unchanged.\n\n### Kata\nYou will attempt to support all the different types of reflector, so the constructor inputs will allow us to define the internal wiring, the valid starting positions, the actual start position and whether the rotation input from the external mechanism would cause the reflector to rotate.\n\nThe `Reflector` class you will implement, will:\n\n1. Construct with:\n* A list of wire pairs in the form of a 26 character string where each pair member maps to its opposite, e.g. \"ABCD...\" would map *r*A <-> *r*B, *r*C <-> *r*D, etc.,\n* A list a of valid starting positions, e.g. \"AC\" meaning the first and third positions,\n* The starting position, e.g. \"C\" meaning the third position\n* A boolean flag indicating if the reflector supports rotation.\n\n2.&nbsp;Validate the state is legitimate. If it is not, raise an exception.\n\n3.&nbsp;Implement the method to translate a single character of mechanism input into a mechanism output, and simulate rotation if supported.\n\n---\n\nPython example:\n\n    print \"Simpler\"\n    # A Non-rotating 2 position rotor, starting in the 2nd position\n    reflector = Reflector(\"AYBRCUDHEQFSGLIPJXKNMOTZVW\", \"AN\", \"N\", False)\n    print reflector.process(\"A\", True) # Rotation is ignored, this rotor does not rotate\n    print reflector.process(\"B\", True)\n    print reflector.process(\"X\", True)\n    print reflector.process(\"!\", True)\n\n    print \"More complex\"\n    # A Rotating 26 position rotor starting in the 8th position\n    reflector = Reflector(\"AYBRCUDHEQFSGLIPJXKNMOTZVW\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", \"H\", True)\n    print reflector.process(\"A\", True)\n    print reflector.process(\"B\", True)\n    print reflector.process(\"X\", True)\n    print reflector.process(\"!\", True)\n\nExpected output:\n\n    Simpler\n    X\n    Z\n    A\n    !\n    More complex\n    H\n    E\n    T\n    !\n",
    "totalAttempts": 137,
    "totalCompleted": 10,
    "totalStars": 17,
    "voteScore": 11,
    "tags": [
      "Fundamentals",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 3,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}