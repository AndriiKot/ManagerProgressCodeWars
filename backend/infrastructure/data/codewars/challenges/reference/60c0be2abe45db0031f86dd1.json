{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/60c0be2abe45db0031f86dd1",
  "data": {
    "id": "60c0be2abe45db0031f86dd1",
    "name": "Minimal Breadth-First Search",
    "slug": "minimal-breadth-first-search",
    "category": "algorithms",
    "publishedAt": "2021-08-03T16:53:59.038Z",
    "approvedAt": null,
    "languages": [
      "haskell"
    ],
    "url": "https://www.codewars.com/kata/60c0be2abe45db0031f86dd1",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2021-06-09T13:12:10.371Z",
    "createdBy": {
      "username": "oisdk",
      "url": "https://www.codewars.com/users/oisdk"
    },
    "description": "Your task is to implement a breadth-first search of a graph, given very limited information about the vertices in that graph.\n\nThe graph type we will work with is the following:\n\n```haskell\ntype Graph a = a -> [a]\n```\n\nThis is an adjacency-list representation of a graph. For instance, the following graph:\n\n```\n┌───▶ E ◀────────┐ \n│                 │ \n│                 │ \nF <─────┐    ┌─▶ D \n│        │   │    ▲ \n│    ┌─▶ C ──┘    │ \n│    │   ▲        │ \n│    │   └───────┤ \n│    │            │ \n│    ▼            │ \n└──▶ A ────────▶ B \n```\n  \nIs represented by the following function:\n  \n```haskell\ndata Vert = A | B | C | D | E | F\n\ngraph :: Graph Vert        \ngraph A  = [B,  C]\ngraph B  = [C,  D]\ngraph C  = [A,  D,  F]\ngraph D  = [E]\ngraph E  = []\ngraph F  = [A,  E]\n```\n\nYour task is to implement the following function, which performs a breadth-first search of the graph:\n\n```haskell\nbfs :: Nubs a => Graph a -> a -> [a]\n\nbfs graph A === [A,B,C,D,F,E]\n```\n\nYour solution should have linear complexity.\n\nThe only information you are given about the vertices of the graph is that they belong to the `Nubs` class: this class has one method, `nubs :: [[a]] -> [[a]]`, which removes duplicates from nested lists.\n\n```haskell\nclass Nubs a where nubs :: [[a]] -> [[a]]\n\nnubs [[a],[b]]     == [[a],[b]]\nnubs [[a],[a,b]]   == [[a],[b]]\nnubs [[a,a],[b]]   == [[a],[b]]\nnubs [[a,b],[a,b]] == [[a,b],[]]\nnubs [[a],[a],[b]] == [[a],[],[b]]\nnubs [[a],[],[b]]  == [[a],[],[b]]\n```\n\n`nubs` is lazy: it doesn't force any more of its input than it needs to.\n\n```haskell\nnubs ([a,b,c]: _|_) == [a,b,c] : _|_\nnubs ((a:b: _|_):xs) == (a:b : _|_) : _|_\n```\n\nYou may assume that `nubs` has linear complexity (`nubs xs` is in O(n), where `n == length (concat xs)`).\n\nYour solution should also be lazy. In other words, for an infinite graph like `\\n -> [n-1, n+1]`, your solution should produce an infinite list beginning with `[n,n-1,n+1,n-2,n+2,...`",
    "totalAttempts": 53,
    "totalCompleted": 10,
    "totalStars": 3,
    "voteScore": 20,
    "tags": [
      "Performance",
      "Algorithms",
      "Graph Theory"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 0,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}