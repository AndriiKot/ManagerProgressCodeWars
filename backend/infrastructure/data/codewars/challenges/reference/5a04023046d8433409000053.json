{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5a04023046d8433409000053",
  "data": {
    "id": "5a04023046d8433409000053",
    "name": "Functional programming in JS/TS -  Part 1: Projecting Arrays iteratively",
    "slug": "functional-programming-in-js-slash-ts-part-1-projecting-arrays-iteratively",
    "category": "reference",
    "publishedAt": "2017-12-05T09:39:49.982Z",
    "approvedAt": null,
    "languages": [
      "javascript",
      "typescript"
    ],
    "url": "https://www.codewars.com/kata/5a04023046d8433409000053",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2017-11-09T07:22:24.396Z",
    "createdBy": {
      "username": "jchapuis",
      "url": "https://www.codewars.com/users/jchapuis"
    },
    "description": "Functional programming provides developers with the tools to abstract common collection operations into reusable, composable building blocks. You'll be surprised to learn that most of the operations you perform on collections can be accomplished with **five simple functions**:\n\n- map\n- filter\n- flatMap\n- reduce\n- zip\n\nHere's my promise to you: if you learn these 5 functions your code will become shorter, more self-descriptive, and more durable.\n\n# Working with Arrays\nThe Array is Javascript's only collection type. Arrays are everywhere. We're going to add the five functions to the Array type, and in the process make it much more powerful and useful. As a matter of fact, Array already has the map, filter, and reduce functions! However we're going to reimplement these functions as a learning exercise.\n\nThis section will follow a pattern. First we'll solve problems the way you probably learned in school, or on your own by reading other people's code. In other words, we'll transform collections into new collections using loops and statements. Then we'll implement one of the five functions, and then use it to solve the same problem again without the loop. Once we've learned the five functions, you'll learn how to combine them to solve complex problems with very little code.\n\n## Traversing an array\nBelow you'll find a \"traditional\" way of traversing an array. When looking at this example, ask yourself this question: **is the *order* in which the names are printed relevant to printing all names?**. \n\n```javascript\nfunction printAllNames(names) {\n\tfor(var counter = 0; counter < names.length; counter++) {\n\t\tconsole.log(names[counter]);\n\t}\n}\nvar names = [\"Ben\", \"Jafar\", \"Matt\", \"Priya\", \"Brian\"]\nprintAllNames(names)\n```\nClearly, our function's purpose is not about printing the names in some specified order, but about printing all the names as-is. So it's in some sense counter-productive that we need to explicitely increment a counter to achieve our goals.\n\nLet's look at an alternative using the `forEach()` function:\n\n```javascript\nfunction printAllNames(names) {\n\tnames.forEach(function(name) {\n\t\tconsole.log(name);\n\t})\n}\nvar names = [\"Ben\", \"Jafar\", \"Matt\", \"Priya\", \"Brian\"]\nprintAllNames(names)\n```\nNotice how `forEach()` lets us specify *what* we want to happen to each item in the array, but hides *how* the array is traversed.\n\n## Projecting Arrays\nApplying a function to a value and creating a new value is called a *projection*. To project one array into another, we apply a projection function to each item in the rray and collect the results a new array.\n\nThis kata is going to look at implementing a projection of an array of some video descriptions into an indexed array: given an array of this shape:\n\n```javascript\nvar newReleases = [\n\t\t{\n\t\t\t\"id\": 70111470,\n\t\t\t\"title\": \"Die Hard\",\n\t\t\t\"boxart\": \"http://cdn-0.nflximg.com/images/2891/DieHard.jpg\",\n\t\t\t\"uri\": \"http://api.netflix.com/catalog/titles/movies/70111470\",\n\t\t\t\"rating\": [4.0],\n\t\t\t\"bookmark\": []\n\t\t},\n    ...\n```\n\nthe goal of this kata is to project this array into an array of `{id, title}` pairs using `forEach()`. The following kata (Part 2) will look at how to generalize this implementation into a `map()` function.\n\n## Note: Attribution\nThis kata is part of a series on functional programming in JS/TS. This series is an adaptation of the *Functional Programming in Javascript* online exercises: http://reactivex.io/learnrx/ (Apache 2 license).",
    "totalAttempts": 69,
    "totalCompleted": 5,
    "totalStars": 2,
    "voteScore": -2,
    "tags": [
      "Fundamentals",
      "Functional Programming",
      "Declarative Programming",
      "Programming Paradigms",
      "Higher-order Functions",
      "Functions",
      "Control Flow",
      "Basic Language Features"
    ],
    "contributorsWanted": false,
    "unresolved": {
      "issues": 3,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}