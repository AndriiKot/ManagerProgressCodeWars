{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5edfad4b32ebb000355347d2",
  "data": {
    "id": "5edfad4b32ebb000355347d2",
    "name": "Coping with NP-Hardness #2: Max Weight Independent Set of a Tree",
    "slug": "coping-with-np-hardness-number-2-max-weight-independent-set-of-a-tree",
    "category": "algorithms",
    "publishedAt": "2020-06-10T15:26:38.367Z",
    "approvedAt": null,
    "languages": [
      "python"
    ],
    "url": "https://www.codewars.com/kata/5edfad4b32ebb000355347d2",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2020-06-09T15:39:55.918Z",
    "createdBy": {
      "username": "ALowVerus",
      "url": "https://www.codewars.com/users/ALowVerus"
    },
    "description": "You have been tasked with generated an invite list for your christmas office party. You know several things: \n- You want to have the most fun party possible.\n- Every person invited to your party grants your party some level of person-dependent fun. Anna, being a jerk, grants your party only +3 fun points, while Jane, being a TOTAL BADASS, grants your party +999 fun points.\n- If any employee comes into contact with his/her boss, the two will fight, ruining the party for everyone. Think of that as a -infinity fun value.\n- Each person has at most 1 boss. Each boss has at most infinite employees. There are no circular arrangements of bosses, such as Jane is Bill's boss, Bill is Adam's boss, and Adam is Jane's boss: your company has a strict dominance heirarchy.\n- All given employees are from a single division of the company, meaning that they are all somehow connected to one another.\n- You have absolute freedom in who you decide to invite. If your boss or the head honcho aren't invited, they won't care, they'll be happy knowing the plebs are having fun.\n\nGiven the above criteria, you must find some subset of employees that, when brought together, will have the \n> `BEST RAGER EVER.`\n\nInputs are dictionaries containing boss-to-employees relationships, in the format '{name_string: list_of_employee_names}', and dictionaries of fun values, in the format '{name_string: fun_value}'. \n\nOutput is a lists of the names of your chosen subset of people. Your output will be checked to ensure that no contained people are in a boss-employee relationship and that the sum of their values is greater than or equal to the sum of the values of the baseline solution's answer. \n\nNote: The boss->employee dictionary might not contain all company members.\n\n## Kata in this Series\n\n1. [Coping with NP-Hardness #1: 2-SAT](https://www.codewars.com/kata/5edeaf45029c1f0018f26fa0)\n2. **Coping with NP-Hardness #2: Max Weight Independent Set of a Tree**\n3. [Coping with NP-Hardness #3: Finding the Minimum Hamiltonian Cycle](https://www.codewars.com/kata/5ee12f0a5c357700329a6f8d)\n4. [Coping with NP-Hardness #4: 3-Recoloring](https://www.codewars.com/kata/5ee17ff3c28ec6001f371b61)",
    "totalAttempts": 99,
    "totalCompleted": 7,
    "totalStars": 0,
    "voteScore": 0,
    "tags": [
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 0,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}