{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/64fd055e18692c693febbbd4",
  "data": {
    "id": "64fd055e18692c693febbbd4",
    "name": "Finger Trees/Sequences",
    "slug": "finger-trees-slash-sequences",
    "category": "algorithms",
    "publishedAt": "2023-09-13T20:14:17.103Z",
    "approvedAt": null,
    "languages": [
      "haskell"
    ],
    "url": "https://www.codewars.com/kata/64fd055e18692c693febbbd4",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2023-09-09T23:53:02.356Z",
    "createdBy": {
      "username": "Anteproperispomenon",
      "url": "https://www.codewars.com/users/Anteproperispomenon"
    },
    "description": "# Finger Trees\n\nFinger Trees are a functional data structure that are primarily used to represent sequences where insertion is allowed at either end. They are the data structure behind the `Sequence` data type found in the [containers](https://hackage.haskell.org/package/containers) package. They work very similarly to  double-ended queues, being designed to allow easy insertion/removal at either end, but not having an easy way to insert in/remove from the middle. \n\n## Before Starting\n\nTo be able to complete this kata, you should understand Functors, folds, and data types definitions. Knowing things like applicative functors, monads, and traversals will help, but are not necessary to complete the kata.\n\n## Definition\n\nA **FingerTree** is a recursive data structure, much like many other functional data structures. Unlike most other recursive data structures, however, the recursive portion of the data definition is not paramaterised on the same type.\n\n```haskell\ndata FingerTree a\n  = Empty\n  | Single a\n  | Deep (Digit a) (FingerTree (Node a)) (Digit a)\n\ndata Digit\n  = Digit1 a\n  | Digit2 a a\n  | Digit3 a a a\n  | Digit4 a a a a\n\ndata Node\n  = Node2 a a\n  | Node3 a a a\n```\n\nIn words, a **FingerTree** is either empty, a single element, or a FingerTree of nodes flanked by digits on either side. This means that, for a **FingerTree** paramaterised on type `a`, the main **FingerTree** is also paramaterised on `a`, but the next **FingerTree** is instead paramaterised on `Node a`. The next **FingerTree** after that is paramaterised on `Node (Node a)`, and so on the deeper you go. Thus, the deeper you go, the more deeply nested the values are. \n\nNote that `FingerTrees` are expected to work the same way as (finite) lists; that is, using equivalent `List`/`FingerTree` functions on equivalent `Lists`/`FingerTrees` should produce equivalent results. Most importantly, this means that items in a `FingerTree` are encountered in the same order that they are encountered in an equivalent list. This is important when writing folds and traversals.\n\n## Operations\n\n### Primitives\n\nThe main 'primitive' operations on Finger Trees are `cons` and `snoc`, often represented by their infix forms `<|` and `|>` respectively. `cons` is equivalent to `:` on lists, adding an element to the left end of a **FingerTree**. `snoc` is the opposite, adding the element to the right end of a **FingerTree**. In terms of stacks/deques, they are equivalent to pushing an element on the left or right side.\n\nThe other 'primitive' operations are `uncons` and `unsnoc`. They are very similar to the `uncons` function found in the `Data.List` module. If the **FingerTree** is empty, then both functions just return `Nothing`; otherwise, they look at the leftmost/rightmost element, and return it along with the result of removing it from the **FingerTree**. For example...\n\n```haskell\n-- FingerTrees here are represented as lists, to be more legible.\nuncons [] == Nothing\nuncons [1] == Just (1,[])\nuncons [4,7,2,3] == Just (4,[7,2,3])\nunsnoc [7,6,5,4] == Just ([7,6,5],4)\n```\n\nIn terms of stacks/deques, this would be equivalent to popping an element from either end.\n\nIf you can't figure out how to implement `cons` or `uncons`, you can try looking up the original paper on `FingerTrees`, *Finger Trees: a simple general-purpose data structure*, but it might spoil the answer for you.\n\n### Functor Instance\n\nFingerTrees are also an instance of `Functor`, like most data structures in Haskell. The `Functor` instance for `FingerTree` should work just like that for `List`; i.e. when using `fmap f` on a `FingerTree`, each element in the `FingerTree` has the function `f` applied to it exactly once. Note that `Digit` and `Node` already have `Functor` instances. You'll need them when writing `fmap` for `FingerTree`.\n\n### Folds\n\nFolds are probably the most important operations on `FingerTrees`. They allow you to define many important operations on `FingerTrees` simply, such as `reverse`, `length`, and `append`. In case you don't have a great handle on folds, here's a quick cheat sheet:\n\n```haskell\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr op z0 [a,b,c,d]\n  = a `op` (b `op` (c `op` (d `op` z0)))\n\nfoldl :: (b -> a -> b) -> b -> [a] -> b\nfoldl op z0 [a,b,c,d]\n  = ((((z0 `op` a) `op` b) `op` c) `op` d)\n```\n\nNote that using `Foldable` is disabled in this kata; this is because `Foldable` can give you an automatic definition for `foldl` when supplied with a definition for `foldr`. You'll have to write `foldl` yourself.\n\n### Specialised Folds\n\nAs stated above, you can write functions like `reverse`, `length`, etc... in terms of `foldrFT` and `foldlFT`. If you know how to write functions in terms of folds, this part should be pretty easy. If you have trouble here, try looking for resources about writing functions in terms of folds.\n\n### Traversals\n\nThe `Traversable` type class gives you functions that allow you to perform applicative/monadic actions on each element of a data structure. The most well-known function from `Traversable` is probably `mapM`. You'll have to implement its slightly more general version `traverse` for `FingerTrees`. `mapM_` and `traverse_` are like `mapM` and `traverse` respectively, but discard the results of the actions. This is useful when only the effects of the actions are important.\n\ne.g.\n\n```haskell\nmapM_ putStrLn [\"Hi.\", \"How are you?\", \"I'm busy.\"]\n```\n\nwould write each of the strings to `stdout`, with a newline after each string.\n\n### Zipping\n\n'Zipping' is a common way of combining two lists (or two of the same list-like data structure) together. `zip` pairs the n-th element of the first list with the n-th element of the second list to create a list of pairs. If one of the lists is longer than the other, then the trailing elements of the longer list are ignored.\n\ne.g.\n\n```haskell\nzip [1,2,3,4,5] ['a','b','c','d','e','f','g']\n  == [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e')]\n```\n\n`zipWith` is like `zip`, but combines the elements using a supplied binary function, rather than just pairing them up.\n\n## Hints\n\n### General Implementation\n\nUnfortunately, the code for the main operations of this kata require a lot of boilerplate. For the more important functions, you'll probably want to define simple versions of the function, but on `Node`/`Digit` instead of `FingerTree`. You can then use those functions in the main function for `FingerTree`.\n\n### Pattern Matching\n\nDirectly pattern matching on all possibilities of a `FingerTree` is difficult, since the main recursive constructor itself has constructors with multiple possibilities within it. One way to simplify writing code that pattern matches on `FingerTrees` is to use [Pattern Guards](https://wiki.haskell.org/Pattern_guard) (or `case` statements) instead, which allows you to pattern match on the results of applying functions to arguments by embedding them in guards.\n\nFor example, on lists...\n\n```haskell\ndeconstruct1 :: [a] -> ...\ndeconstruct1 []     = ...\ndeconstruct1 (x:xs) = deconstruct1 ...\n\ndeconstruct2 :: [a] -> ...\ndeconstruct2 lst\n  | Nothing <- uncons lst\n  = ...\n  | Just (x,xs) <- uncons lst\n  = deconstruct2 ...\n```\n\n... the first method is usually preferred (on lists), but is not generalisable to data structures that are more difficult (or impossible) to deconstruct directly. The second method, on the other hand, works great to deconstruct such data structures, and can also be used on any function on the data structure.\n\nThey can also be used to avoid extra cases any time you need to deconstruct a simple data structure. For example, if you want to remove the left-most element of a `Digit`, you can write a 'helper' deconstructor, and then re-use it any time you need to deconstruct a `Digit` in that way. \n\n```haskell\nunconsDig :: Digit a -> (a, Maybe (Digit a))\nunconsDig (Digit1 x)   = (x, Nothing)\nunconsDig (Digit2 x y) = (x, Just (Digit1 y))\nunconsDig ...\n\nworkOnDig :: Digit a -> ...\nworkOnDig dig\n  | (x, Nothing)   <- unconsDig dig\n  = ...\n  | (x, Just dig') <- unconsDig dig\n  = ...\n```\n\nUnfortunately, this can lead to a lot of boilerplate, but it separates the simpler logic from the more complex logic.\n\n### Folding\n\nAs given above, here's that `fold` cheat sheet again.\n\n```haskell\nfoldr :: (a -> b -> b) -> b -> [a] -> b\nfoldr op z0 [a,b,c,d]\n  = a `op` (b `op` (c `op` (d `op` z0)))\n\nfoldl :: (b -> a -> b) -> b -> [a] -> b\nfoldl op z0 [a,b,c,d]\n  = ((((z0 `op` a) `op` b) `op` c) `op` d)\n```\n\nBut there are many tricks you can do with folds. One example is 'chaining' folds; that is, instead of using a plain value as the \"starter\" value for a fold (`z0` in the above cheat sheet), using another fold in its place. for example...\n\n```haskell\ndfoldr :: (a -> b -> b) -> b -> [a] -> [a] -> b\ndfoldr op z0 lst1 lst2 = foldr op (foldr op z0 lst2) lst1\n```\n\nThe only problem with it is the awkward ordering of arguments. Of course, you can simply write a re-ordered version of `foldr` to help with that:\n\n```haskell\n{-# INLINE foldrC #-}\nfoldrC :: (a -> b -> b) -> [a] -> b -> b\nfoldrC op xs z0 = foldr op z0 xs\n\ndfoldr :: (a -> b -> b) -> b -> [a] -> [a] -> b\ndfoldr op z0 lst1 lst2 = foldrC op lst1 $ foldrC op z0 lst2\n```\n\nUsing this re-ordered version of `foldr` makes chaining folds much easier to write and understand. The other great thing about chaining folds is that the structures you're folding don't have to be the same. You can chain a fold on lists into a fold on trees, etc... You can also chain a fold onto a fold with a different element type, so long as the final type is the same.\n\n### Applicatives / Traversals\n\n`Applicative` effects are commonly combined with the following pattern:\n\n```haskell\ndata DataStruct = DataStruct Type1 Type2 Type3\n-- i.e. DataStruct :: Type1 -> Type2 -> Type3 -> DataStruct\n\ndataStruct :: (Applicative f) => f Type1 -> f Type2 -> f Type3 -> f DataStruct\ndataStruct ft1 ft2 ft3 = DataStruct <$> ft1 <*> ft2 <*> ft3\n```\n\n\n\ne.g.\n\n```haskell\ndata Person = Person {pName :: String , pAge :: Int, pLoc :: String} deriving (Show, Eq)\n-- so we have Person :: String -> Int -> String -> Person\n\ngetString :: IO String\ngetString = getLine\ngetInt :: IO Int\ngetInt = read <$> getString\n\ngetPerson :: IO Person\ngetPerson = Person <$> getString <*> getInt <*> getString\n```\nYou can use this pattern to write `Traversable` instances, e.g.\n\n```haskell\ntraverseT4 :: (a -> f b) -> (a,[a],[a],a) -> (b,[b],[b],b)\ntraverseT4 f (x,ys,zs,w) = (,,,) <$> f x <*> traverse f ys <*> traverse f zs <*> f w\n```\n\n## Acknowledgements\n\nFinger Trees are based on the paper *Finger Trees: a simple general-purpose data structure* by Ralf Hinze and Ross Paterson.\n\n",
    "totalAttempts": 13,
    "totalCompleted": 2,
    "totalStars": 0,
    "voteScore": -1,
    "tags": [
      "Data Structures",
      "Functional Programming"
    ],
    "contributorsWanted": false,
    "unresolved": {
      "issues": 3,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}