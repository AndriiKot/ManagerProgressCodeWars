{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5551718970fdd9bbb0000040",
  "data": {
    "id": "5551718970fdd9bbb0000040",
    "name": "Basic Router With Named Segments",
    "slug": "basic-router-with-named-segments",
    "category": "algorithms",
    "publishedAt": "2015-05-12T03:27:19.790Z",
    "approvedAt": null,
    "languages": [
      "ruby"
    ],
    "url": "https://www.codewars.com/kata/5551718970fdd9bbb0000040",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2015-05-12T03:20:41.913Z",
    "createdBy": {
      "username": "DiegoSalazar",
      "url": "https://www.codewars.com/users/DiegoSalazar"
    },
    "description": "At the forefront of most modern web servers is the Router. This class receives and appropriately handles every new HTTP request to the server. In this kata, we'll build a simple Router class for our fictional microframework Kwipper.\n\nOur router has three things it must accomplish to serve it's purpose:\n\n1. It determines if an incoming request's HTTP Method & Path match with a predefined route.\n2. It dispatches the request to the correct controller action.\n3. It prepares the correct parameters from any named segments in the request's path.\n\nFor this set of behavior, the Router class implements three methods: `route?`, `dispatch` and `segments`, respectively.\n\n```ruby\nclass Router\n  def route?(request_info)\n    # the request_info argument is an incoming URL string\n    # return true or false if it matches a key in ROUTES\n  end\n\n  def dispatch\n    # return the values from the matching route in ROUTES\n  end\n\n  def segments\n    # return a hash where the keys are the names of each segment \n    # as defined in the ROUTES hash and the values are the matched \n    # segments from the incoming request_info URL string\n  end\nend\n```\n\nThe Router will be initialized with a `ROUTES` hash representing the routes of our Kwipper app. This hash will be used by each of the methods above to accomplish thier goal. \n\n```ruby\nROUTES = {\n  # a static route\n  \"GET /home\" => [\"HomeController\", :index],\n  # a named segment route\n  \"GET /posts/:slug/comments/:id/edit\" => [\"CommentsController\", :edit]\n}\n```\n\nThe segments that begin with a colon are named segments. The strings following the colons are the segment names, these will be the keys of the hash returned from the segments method.\n\n## def route?\nWhen a request comes into our imaginary app, the `route?` method is the first method that will be called.  It will be called with a string argument, `request_info`. For example: `\"GET /path\"` where `/path` is _any path_. It should return `truthy` if the `request_info` string matches a route key in the `ROUTES` hash. Keep named segments in mind as well. Given a `request_info` string such as `\"GET /posts/test-post/comments/12/edit\"`, it should match the named segment route key `\"GET /posts/:slug/comments/:id/edit\"` from the `ROUTES` hash. \n\n## def dispatch\nSecond, the `dispatch` method is called to determine which controller action should handle the request. Notice the values in the `ROUTES` hash are Arrays containing a controller class and an action name. These are the controllers and actions that will be handling requests to their corresponding routes. The Router's dispatch method should return these two values when given a `request_info` string.\n\n## def segments\nFinally, the `segments` method comes into play. It's job is to return part of the \"params\" hash that is generated by named segments. When `route?` is called with a `request_info` string that matches a named segment route, subsequent calls to the segments method should return a hash. The keys of this hash are the names of the segments and the values are the parts of the path that correspond to each named segment.\n\nFor example, given that `route?` is called with a `request_info` string `\"GET /posts/test-post/comments/12/edit\"`, and a matching named segment route `\"GET /posts/:slug/comments/:id/edit\"` exists, a subsequent call to the `segments` method should return `{ slug: \"test-post\", id: \"12\" }`.",
    "totalAttempts": 779,
    "totalCompleted": 22,
    "totalStars": 2,
    "voteScore": 3,
    "tags": [
      "Data Structures",
      "Regular Expressions",
      "Algorithms"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 4,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}