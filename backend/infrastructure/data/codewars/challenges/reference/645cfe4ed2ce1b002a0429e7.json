{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/645cfe4ed2ce1b002a0429e7",
  "data": {
    "id": "645cfe4ed2ce1b002a0429e7",
    "name": "LFSR: Reverse Engineering",
    "slug": "lfsr-reverse-engineering",
    "category": "games",
    "publishedAt": "2023-05-11T22:27:02.058Z",
    "approvedAt": null,
    "languages": [
      "python"
    ],
    "url": "https://www.codewars.com/kata/645cfe4ed2ce1b002a0429e7",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2023-05-11T14:40:14.600Z",
    "createdBy": {
      "username": "LuggiStruggi",
      "url": "https://www.codewars.com/users/LuggiStruggi"
    },
    "description": "# Overview\n\nIn this kata you will be given the beginning of a sequence generated by an Linear Feedback Shift Register (LFSR) and must return a generator which emulates the LFSR by predicting th future values of that sequence. An LFSR is used to generate a stream of (pseudo) random numbers/bits.\n\n# How do the LSFRs in this kata work?\n\nA register has an XOR gate connected to certain bit-positions. The output of this gate will create a new bit. The register is shifted one to the right and the new bit is shifted in at the leftmost position of the register.\n\nHere is a visualisation of an LFSR with a size of 5 bits and the XOR connected to D and B.\n\n```\n +-<-(XOR)\n |    | |\n +-> ABCDE\n```\nThe following are the resulting states of the register, starting with seed `00010`:\n\n```\nABCDE   DECIMAL\n00010 |    2\n10001 |    17\n01000 |    8\n10100 |    20\n01010 |    10\n00101 |    5\n00010 |    2\n```\nAfter which it would loop.\n\n# Task\nAs said before you are given a sequence generated by a LFSR and must continue it.\n\nEasy? You will not know the size of the LFSR nor the XOR input positions!\n\nImplement the `function find_lfsr(sequence)` which returns a generator, which given a seed produces the correct stream of numbers, emulating the underlying LFSR. If you havent yet implemented an LFSR it might be helpful to first have a look at [this kata](https://www.codewars.com/kata/645797bd67ad1d92efea25a1).\n\n# More Specific\n\n- The function `find_lfsr` has to return a generator, which itself yields integers.\n- The `sequence` will be a list of integers.\n- It is not enough to return an generator which only copies the same `sequence` given. Every future element must also equal every element of the LFSR which created the `sequence`.\n- LFSRs with only one XOR connection just feed back the connected bit. There can be also LFSRs with no connections.\n- The `seed` from which to test need not be the initial seed of the `sequence` passed to `find_lfsr`. However in our tests every given `seed` is guaranteed to be one of the elements or a future element of the given `sequence`. The behavior of the returned generator for a `seed` which can not be \"reached\" from the initial `sequence` will not be tested and can be arbitrary.\n\n# Handling Multiple Possible LFSRs\n\nIn some cases, there may be multiple LFSRs that could have generated the same `sequence`.\n\nHowever, if you can determine the future behavior of all these LFSRs based on the given information, then return a generator that can emulate any/all of them;\n\nFor example, an LFSR with XOR input positions `ABCDE` may also produce the same `sequence` as the LFSR given in the description with connections `BD`. Both LFSRs will produce the same output infinitely, having the same seed of `2` (or any other number of that `sequence`), although they may produce different output for states that are not part of the `sequence` produced by that specific initial seed. For example, `BD` will produce output `0b00000` for input `0b10000`, while `ABCDE` will produce output `0b10000`. However, this does not matter because `0b10000` will never be part of the `sequence` generated by the original `2` seed and will therefore not be tested. \n<span style=\"font-size:larger;\"> We are only interested in predicting the future elements of the `sequence` not the complete underlying behavior of the LFSR that generated it!</span>\n\nIf one cannot uniquely predict the future elements of the initial `sequence`, because there are multiple solutions that would differ after a certain number of iterations (e.g., the initial `sequence` `[1]` or `[23, 11]`), then you must return `None`.\n\n# Examples:\n\n- 1. The input `sequence` `[2, 17, 8, 20, 10, 5]`. The `sequence`s future values can be predicted since every LFSR having this initial `sequence` (e.g. `BD`, `ABCDE`) will have the same future values. Therefore, the function `find_lfsr` should return a generator that will predict the behavior of any/all of these LFSRs, given that the `seed` is part of that `sequence` or one of its future values.\n- 2. The input `sequence` `[1]`. Any LFSR can generate this `sequence`, but they will not necessarily generate the same output after a given number of iterations. Therefore, the `find_lfsr` function should return `None`.\n- 3. The input `sequence` `[23, 11]`. There are several LFSRs that can produce this `sequence`, but they will not necessarily produce the same output after a certain number of iterations. Therefore the function `find_lfsr` should return `None`.\n\nGOOD LUCK!",
    "totalAttempts": 155,
    "totalCompleted": 5,
    "totalStars": 5,
    "voteScore": -1,
    "tags": [
      "Cryptography",
      "Bits"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}