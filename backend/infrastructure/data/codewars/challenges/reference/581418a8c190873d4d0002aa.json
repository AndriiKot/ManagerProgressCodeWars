{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/581418a8c190873d4d0002aa",
  "data": {
    "id": "581418a8c190873d4d0002aa",
    "name": "Find Ends of Each Paths",
    "slug": "find-ends-of-each-paths",
    "category": "algorithms",
    "publishedAt": "2016-10-31T22:15:35.138Z",
    "approvedAt": null,
    "languages": [
      "python"
    ],
    "url": "https://www.codewars.com/kata/581418a8c190873d4d0002aa",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2016-10-29T03:34:01.285Z",
    "createdBy": {
      "username": "A.Freeman",
      "url": "https://www.codewars.com/users/A.Freeman"
    },
    "description": "In this kata you will solve [directed graph](https://en.wikipedia.org/wiki/Directed_graph), that means count the chances of stopping in each terminal nodes - nodes without outgoing edges - as a result of a probabilistic graph traversal. Graph is defined by n*n matrix of integers, where each row describes weights (probabilities) of directed outgoing lines. First line describes start node. Example:\n\n```python\n# Simple graph with 2 terminal nodes\nm = [[0, 2, 3], # node 1\n     [0, 0, 0], # node 2\n     [0, 0, 0]] # node 3\n``` \n\nThat means you will go in 2 cases of 5 from start node #1 to node #2 and in 3 cases of 5 from #1 to #3.\n\nYou job is count the probabilities of ending at each terminal nodes as proportions in integers with denominator. For example above the answer is ```[2,3,5]```. But it would be too easy if graphs can't contains circle. You need to correctly handle such situations.\n\n# Input\n\nn*n matrix of integers, n <= 80.\n\n# Output\n\nlist of probabilities as number of nominators and denominator.\n\n# Examples\n\nGraph of 4 nodes with 2 terminal, without cycles:\n```python\nm = [[0, 5, 3, 0], \n     [0, 0, 4, 3], \n     [0, 0, 0, 0], \n     [0, 0, 0, 0]]\n\nEdges:\n  1->2 with p=5/8\n  1->3 with p=3/8\n  2->3 with p=4/7\n  2->4 with p=3/7\n  \nProbabilities:\n        1->3  1->2  2->3\n  p_3 = 3/8 + 5/8 * 4/7 = 21/56 + 20/56 = 41/56\n        1->2  2->4\n  p_4 = 5/8 * 3/7 = 1 - p_3 = 15/56\n  \nAnswer:\n  [41, 15, 56]\n``` \n\nGraph of 4 nodes with 2 terminal and 1 cycle:\n```\nm = [[0, 2, 1, 2], \n     [1, 0, 0, 4], \n     [0, 0, 0, 0], \n     [0, 0, 0, 0]]\n\nEdges:\n  1->2 with p=2/5 (cycle)\n  1->3 with p=1/5\n  1->4 with p=2/5\n  2->1 with p=1/5 (cycle)\n  2->4 with p=4/5\n  \nProbabilities:\n       1->3  1->2  2->1   1->3  1->2  2->1\n  p3 = 1/5 + 2/5 * 1/5 * (1/5 + 2/5 * 1/5 * (...)) => p3 = 1/5 + 2/25*p3 => 23/25*p3 = 1/5 => p3 = 5/23\n  p4 = 1 - p3 = 18/23\n  \nAnswer:\n  [5, 18, 23]\n```\n\n# P.S.\nI haven't validate all tests, and it is very unlikely, but there can be dead ends, such this:\n```\n  m = [[0, 1, 1],\n       [0, 1, 0],\n       [0, 0, 0]]\n\nProbabilities:\n  p3 = 1/2\n\nAnswer:\n  [1, 2]\n```\n\nGood luck!",
    "totalAttempts": 69,
    "totalCompleted": 15,
    "totalStars": 6,
    "voteScore": 10,
    "tags": [
      "Algorithms",
      "Graph Theory"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 3,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}