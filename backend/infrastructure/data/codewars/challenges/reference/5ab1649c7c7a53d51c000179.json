{
  "success": true,
  "url": "https://www.codewars.com/api/v1/code-challenges/5ab1649c7c7a53d51c000179",
  "data": {
    "id": "5ab1649c7c7a53d51c000179",
    "name": "Effeuiller la marguerite (loves me, loves me not)",
    "slug": "effeuiller-la-marguerite-loves-me-loves-me-not",
    "category": "algorithms",
    "publishedAt": "2018-03-20T22:06:18.282Z",
    "approvedAt": null,
    "languages": [
      "javascript"
    ],
    "url": "https://www.codewars.com/kata/5ab1649c7c7a53d51c000179",
    "rank": {
      "id": null,
      "name": null,
      "color": null
    },
    "createdAt": "2018-03-20T19:44:29.041Z",
    "createdBy": {
      "username": "user387193",
      "url": "https://www.codewars.com/users/user387193"
    },
    "description": "**He loves me, he loves me not** or **She loves me, she loves me not** is a game of French origin (originally called **effeuiller la marguerite** in French), in which one person seeks to determine whether the object of their affection returns that affection. A person playing the game alternately speaks the phrases \"He (or she) loves me,\" and \"He (or she) loves me not,\" while picking one petal off a flower for each phrase. The phrase they speak on picking off the last petal supposedly represents the truth between the object of their affection loving them or not.\n\nIn the original French version of the game, the petals do not simply indicate whether the object of the player's affection loves the player, but to what extent in this order: \"a little\", \"a lot\", \"passionately\", \"to madness\", \"not at all\".\n\nBuild a function of the French version of this game, that takes in two arguments (number of petals, gender (male or female)) and tells what the last petal says.",
    "totalAttempts": 154,
    "totalCompleted": 54,
    "totalStars": 1,
    "voteScore": 81,
    "tags": [
      "Algorithms",
      "Strings"
    ],
    "contributorsWanted": true,
    "unresolved": {
      "issues": 1,
      "suggestions": 0
    }
  },
  "error": null,
  "isValid": false,
  "validationErrors": [
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "rank.id",
      "message": "Expected integer, got object (not integer)"
    },
    {
      "path": "rank.name",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "rank.color",
      "message": "Expected type 'string', got 'object'"
    },
    {
      "path": "approvedBy",
      "message": "Required field 'approvedBy' is missing"
    },
    {
      "path": "approvedAt",
      "message": "Expected type 'string', got 'object'"
    }
  ]
}