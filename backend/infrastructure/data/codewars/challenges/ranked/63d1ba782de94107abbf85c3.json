{
  "id": "63d1ba782de94107abbf85c3",
  "name": "Scott Booleans",
  "slug": "scott-booleans",
  "category": "algorithms",
  "publishedAt": "2023-01-29T00:11:34.285Z",
  "approvedAt": "2023-01-29T11:14:05.808Z",
  "languages": [
    "javascript",
    "python"
  ],
  "url": "https://www.codewars.com/kata/63d1ba782de94107abbf85c3",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2023-01-25T23:25:44.546Z",
  "createdBy": {
    "username": "JohanWiltink",
    "url": "https://www.codewars.com/users/JohanWiltink"
  },
  "approvedBy": {
    "username": "dfhwze",
    "url": "https://www.codewars.com/users/dfhwze"
  },
  "description": "# Boole\n\n[Wikipedia](https://en.wikipedia.org/wiki/George_Boole): George Boole ( 1815 â€“ 1864 ) was a largely self-taught English mathematician, philosopher, and logician. He is best known as the author of _The Laws of Thought_ ( 1854 ), which contains Boolean algebra.\n\n[More Wikipedia](https://en.wikipedia.org/wiki/Boolean_data_type): The `Boolean` is a data type that has one of two possible values. It is named after George Boole.\n\nThis kata is about _encoding_ `Boolean`s. The above tells us the essence of a `Boolean` is that it can take on either one of exactly two values. Usually, these are named `True` and `False`, but they might be `Yes` and `No`, `\"True\"` and `\"False\"`, `0` and `1`, `spin up` and `spin down`, or any two distinct values you wish to use.\n\nComputers are commonly thought of as working in binary, but even the binary digits ( bits ) of your laptop are encodings. `0` might be a high voltage and `1` a low voltage, or `0` might be spin down and `1` spin up in your expensive latest IBM quantum-superlaptop.\n\nTaking things up another level of abstraction, your favourite programming language might have generic enumerated data types, like\n\n```\nColour = Red | Orange | Yellow | Green | Blue | Purple\n```\n\nor\n\n```\nAnswer = Yes | No\n```\n\nNotice how `Answer` looks exactly like a `Boolean` ? In actual fact, `Answer` _is_ a `Boolean` data type: it allows for exactly two values. `Answer` is an _encoding_ of a `Boolean`, though it is usually written as `Boolean = False | True`. The encoding of the, Platonian if you will, `Boolean` does not matter; the meaning we assign to the values means the encoding is for all practical purposes transparent; the encoded and the underlying values are identical as long as we agree on the encoding. In other words, an encoding is an isomorphism.\n\nLittle interlude on enumerated data types: `Red` .. `Purple`, `Yes` and `No` are called `Constructor`s. They can be nullary values, like here, or they might wrap ( an ) other value(s), adding information to their argument(s), as in `Pair Red Purple` or `Pair Yes Yes`. ( This kata will restrict itself to nullary `Constructor`s. ) Note that even a nullary `Constructor` adds information to its zero arguments; in this case, the `Constructor` itself is all the information. \n\n\"as long as we agree on the encoding\" means we are free to _choose_ an ( any ) encoding, as long as our audience agrees with us on it. Dear audience, let us agree to encode our `Boolean`s as functions, because (1) we can, (2) it works, and (3) it only requires very basic maths; it requires no hardware and no additional levels of encodings. Now invoke Dana Scott.\n\n# Scott\n\n[Wikipedia](https://en.wikipedia.org/wiki/Dana_Scott): Dana Scott ( 1932 - ) is an American logician. His work on automata theory earned him the Turing Award in 1976.\n\n[More Wikipedia](https://en.wikipedia.org/wiki/Mogensen%E2%80%93Scott_encoding): Scott encoding is a way to represent ( recursive ) data types in the lambda calculus. Church encoding performs a similar function.\n\nIn the lambda calculus, all we have are variables and functions, but fortunately we agreed on encoding `Boolean`s as functions, so we're good. So how does Scott encoding work?\n\nWe have `Boolean = False | True`. The `Constructor`s are `False` and `True`.  \nFor every `Constructor`, define a curried<sup>*</sup> function that takes as many arguments as there are `Constructor`s ( keeping arguments in order of their enumeration in the type definition ), and returns one of them:\n\n```javascript\nFalse = f => t => f\nTrue  = f => t => t\n```\n```python\nfalse = lambda f: lambda t: f\ntrue  = lambda f: lambda t: t\n```\n\n<sup>*</sup> [this kata](https://www.codewars.com/kata/currying-functions-multiply-all-elements-in-an-array), and the linked video, explain currying.\n\n`False` and `True` are _encodings of_ the two possible `Boolean`s, but in shorthand, they _are_ the two possible `Boolean`s. Whenever we encounter either value, we know there's an abstract Platonian Form of truthiness, and whenever we encounter the Platonian form, we know we can encode it. So from now on, let's ignore the difference between encoding and underlying value; whenever we speak of `Boolean`s, we mean the encodings. Because there is no real difference.\n\nStill, `False` and `True` are _functions_ here. Because they are encoded, we can call them, with arguments. If you write the functions `False` and `True`, the Example Tests will feed them arguments and inspect the answers.\n\n# Fire the Nukes or Keep the Peace ?\n\nSo what do you do with `Boolean`s? You make choices to do things.\n\n    if False then fire(nukes) else keep(peace) ;\n    if True then pay(bigMoney) else ridicule(seller) ;\n\nOr you choose between two simple values.\n\n    if False then Champagne else Water ;\n    if True then Rich else Poor ;\n\nIt doesn't matter what the options are, but it is convenient for them to be of the same type. In that case, the whole thing is an _expression,_ of the same type as the choices, be it `SideEffect` ( verb ), `Thing` ( noun ), or `Property` ( adjective ).\n\n`then` and `else` have no semantic meaning of their own, so it is possible to write a curried function call\n\n    if (boolean) (x) (y)\n\nwhere `boolean` is a `Boolean` variable and `x, y` are variables, arbitrarily but identically typed.\n\nHow would that `function if` look? Have a look at the Example Tests, see how it's used, what outputs it expects for what inputs, and write it.\n\n# This concludes today's lecture.\n\nBoolean algebra is left as an exercise for the reader. There is a [kata](https://www.codewars.com/kata/church-booleans) on it, which uses Church encoding instead of Scott encoding - for `Boolean`s the two differ only in the ordering of the `Constructor`s and thus the ordering of the arguments.\n\n[Next time](https://www.codewars.com/kata/scott-orderings-and-more): `Ordering`, `Unit` and `Void`. `Ordering`s have _three_ possible values ( `LT, EQ, GT` or `< 0, == 0, > 0` ); `Unit` has _one_ ( `Unit` or `()` ); `Void` has _none_ and is quite the brain-wrecker.",
  "totalAttempts": 1101,
  "totalCompleted": 220,
  "totalStars": 11,
  "voteScore": 71,
  "tags": [
    "Data Structures",
    "Functional Programming"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}