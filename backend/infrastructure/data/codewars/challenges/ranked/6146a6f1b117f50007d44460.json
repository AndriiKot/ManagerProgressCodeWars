{
  "id": "6146a6f1b117f50007d44460",
  "name": "Sequence Duality and \"Magical\" Extrapolation  (Binomial Transform)",
  "slug": "sequence-duality-and-magical-extrapolation-binomial-transform",
  "category": "algorithms",
  "publishedAt": "2021-09-19T19:39:44.465Z",
  "approvedAt": "2021-09-22T01:19:16.947Z",
  "languages": [
    "python",
    "ruby",
    "javascript",
    "haskell",
    "nim",
    "r",
    "csharp"
  ],
  "url": "https://www.codewars.com/kata/6146a6f1b117f50007d44460",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2021-09-19T02:56:50.191Z",
  "createdBy": {
    "username": "Quaternions",
    "url": "https://www.codewars.com/users/Quaternions"
  },
  "approvedBy": {
    "username": "Avanta",
    "url": "https://www.codewars.com/users/Avanta"
  },
  "description": "The goal of this Kata is to build a very simple, yet surprisingly powerful algorithm to extrapolate sequences of _numbers_*\n(* in fact, it would work with literally any \"[sequence of] _objects that can be added and subtracted_\"!)\n\nThis will be achieved by using a little Mathematical \"trick\" (Binomial Transform), which will be explained below; and by splitting the problem into 3 (simpler) tasks:\n\n* __Task1:__ Build a function `delta()`, which will take a number sequence (list) as an input and return the differences of its successive terms (see below for further explanation)\n\n* __Task2:__ Build a function `dual_seq()`, which will take a number sequence (list) and return its \"Dual\" (_Binomial Transform_; see information below)\n\n* __Task3:__ Finally, build a function `extra_pol()`, which will take a number sequence (list), as well as a positive integer \"n\" and return the sequence completed by the \"n\" following terms, according to the \"best possible polynomial extrapolation\" (don't worry: the code for this part should actually be (much) shorter than this sentence! ;) )\n\n___Some Theory:___\n\n\n__Differences__\n* Let   `(x_0, x_1, x_1, ..., x_{n-1}, x_n)`  be a finite sequence of length `n+1`, one can compute its successive differences in the following way: `(x_0 - x_1, x_1 - x_2, ..., x_{n-1}-x_{n})`, which will -obviously- be of length `n` . (This is what your function `delta()` will be expected to do!)\n\n__Dual Sequence (Binomial Transform)__\n* By iterating the process, one can compute its _Binomial Transform_, which will be given by: (y_0, y_1, ..., y_n), where:\n\n```math\ny_0 = x_0 \\\\\ny_1 = x_0 - x_1 \\\\\ny_2 = (x_0 - x_1) - (x_1 - x_2) = x_0 - 2x_1 + x_2 \\\\\ny_3 = (x_0 - 2x_1 + x_2) - (x_1 - 2x_2 + x_3) = x_0 - 3x_1 + 3x_2 -x_3 \\\\\ny_4 = (x_0 - 3x_1 + 3x_2 -x_3) - (x_1 - 3x_2 + 3x_3 -x_4) \\\\\n\\quad    = x_0 - 4x_1 + 6x_2 - 4x_3 +x_4 \\\\\netc \\quad etc...\n```\n(notice the binomial coefficients)\n\nThe Binomial transform possesses several useful properties; including:\n* `linearity` : if a _pointwise_ sum were defined on the sequences (NB: you are obviously NOT asked to implement this), we could easily see that `dual_seq(A+B) = dual_seq(A)+dual_seq(B)`\n* `involution`: as the name `dual` suggests, it is always true that `dual_seq(dual_seq(A)) = A` (this is not only \"elegant\" but also very useful!)\n* finally, it might be useful to notice that this tranform behaves in a particular way on `polynomials`: indeed, if a sequence `(x_n)` is obtained from a polynomial `p` of degree `d` i.e. such that\n```math\n\\forall n, \\quad x_n = p(n)\n```\nthen it follows that its Dual (Binomial Transform) will be of the form:\n```math\ny_0, y_1, y_2, ... y_d, 0, 0, 0, 0, ...\n```\n(i.e. only zeros after the term `y_d`)\n\n__Polynomial values__\n* Given a sequence `(x_0, x_1, ..., x_d)` of `d+1` points, there exists a unique polynomial `p_d` of degree (not higher than) `d`, which passes successively through those points; i.e. such that \n```math\np_{d}(0) = x_0, \\quad p_{d}(1) = x_1, \\quad ..., \\quad p_{d}(d) = x_d\n```\nIt is with respect to this polynomial that your function `extra_pol` is supposed to extrapolate: in other words, it will take:\n```math\n(x_0, x_1, ..., x_d)\n``` \nas well as a parameter `n` and return:\n```math\n(x_0, x_1, ..., x_d, p_{d}(d+1), p_{d}(d+2), ..., p_{d}(d+n))\n```\n\n(Again, _don't worry: the description is quite long but the code should be quite short!_ ;) )\n\n\n___Some Examples___\n\n`delta()` \n```python\ndelta([17,12]) #returns [5]\ndelta([1,4,9,16,25]) #returns [-3, -5, -7, -9]\ndelta([1,-2,4,-8,16,-32]) #returns [3, -6, 12, -24, 48]\n```\n```nim\ndelta(@[17,12]) #returns @[5]\ndelta(@[1,4,9,16,25]) #returns @[-3, -5, -7, -9]\ndelta(@[1,-2,4,-8,16,-32]) #returns @[3, -6, 12, -24, 48]\n```\n```ruby\ndelta([17,12]) #returns [5]\ndelta([1,4,9,16,25]) #returns [-3, -5, -7, -9]\ndelta([1,-2,4,-8,16,-32]) #returns [3, -6, 12, -24, 48]\n```\n```javascript\ndelta([17,12]) //returns [5]\ndelta([1,4,9,16,25]) //returns [-3, -5, -7, -9]\ndelta([1,-2,4,-8,16,-32]) //returns [3, -6, 12, -24, 48]\n```\n```haskell\ndelta [17, 12] -- [5]\ndelta [1, 4, 9, 16, 25] -- [-3, -5, -7, -9]\ndelta [1, -2, 4, -8, 16, -32] -- [3, -6, 12, -24, 48]\n```\n```r\ndelta(c(17,12)) #returns c(5)\ndelta(c(1,4,9,16,25)) #returns c(-3, -5, -7, -9)\ndelta(c(1,-2,4,-8,16,-32)) #returns c(3, -6, 12, -24, 48)\n```\n```csharp\nDelta(new int[] {17, 12}) // new int[] {5}\nDelta(new int[] {1, 4, 9, 16, 25}) // new int[] {-3, -5, -7, -9}\nDelta([new int[] {1, -2, 4, -8, 16, -32}) // new int[] {3, -6, 12, -24, 48}\n```\n\n`dual_seq()`\n```python\ndual_seq([1]) #returns [1]\ndual_seq([1,2,3,4,5]) #returns [1, -1, 0, 0, 0]\ndual_seq([1, -1, 0, 0, 0]) #returns [1, 2, 3, 4, 5]\ndual_seq([2,4,6,8,10]) #returns [2, -2, 0, 0, 0]\ndual_seq([1,3,5,7,9]) #returns [1, -2, 0, 0, 0]\ndual_seq([1,1,1,1,1]) #returns [1, 0, 0, 0, 0]\ndual_seq([1, 0, 0, 0, 0]) #returns [1, 1, 1, 1, 1]\ndual_seq([1, 4, 9, 16, 25, 36, 49]) #returns [1, -3, 2, 0, 0, 0, 0]\ndual_seq([1, -3, 2, 0, 0, 0, 0]) #return [1, 4, 9, 16, 25, 36, 49]\ndual_seq([1, -3, 2]) #returns [1, 4, 9]\ndual_seq([8, 27, 64, 125, 216]) #returns [8, -19, 18, -6, 0]\ndual_seq([1,2,4,8,16,32,64,128,256]) #returns [1, -1, 1, -1, 1, -1, 1, -1, 1]\ndual_seq([1, -1, 1, -1, 1, -1, 1, -1, 1]) #returns [1, 2, 4, 8, 16, 32, 64, 128, 256]\ndual_seq([1, 1, 2, 3, 5, 8, 13, 21]) #returns [1, 0, 1, 1, 2, 3, 5, 8]\ndual_seq([0, 1, 1, 2, 3, 5, 8, 13, 21]) #returns [0, -1, -1, -2, -3, -5, -8, -13, -21]\n```\n```nim\ndual_seq(@[1]) #returns @[1]\ndual_seq(@[1,2,3,4,5]) #returns @[1, -1, 0, 0, 0]\ndual_seq(@[1, -1, 0, 0, 0]) #returns @[1, 2, 3, 4, 5]\ndual_seq(@[2,4,6,8,10]) #returns @[2, -2, 0, 0, 0]\ndual_seq(@[1,3,5,7,9]) #returns @[1, -2, 0, 0, 0]\ndual_seq(@[1,1,1,1,1]) #returns @[1, 0, 0, 0, 0]\ndual_seq(@[1, 0, 0, 0, 0]) #returns @[1, 1, 1, 1, 1]\ndual_seq(@[1, 4, 9, 16, 25, 36, 49]) #returns @[1, -3, 2, 0, 0, 0, 0]\ndual_seq(@[1, -3, 2, 0, 0, 0, 0]) #return @[1, 4, 9, 16, 25, 36, 49]\ndual_seq(@[1, -3, 2]) #returns @[1, 4, 9]\ndual_seq(@[8, 27, 64, 125, 216]) #returns @[8, -19, 18, -6, 0]\ndual_seq(@[1,2,4,8,16,32,64,128,256]) #returns @[1, -1, 1, -1, 1, -1, 1, -1, 1]\ndual_seq(@[1, -1, 1, -1, 1, -1, 1, -1, 1]) #returns @[1, 2, 4, 8, 16, 32, 64, 128, 256]\ndual_seq(@[1, 1, 2, 3, 5, 8, 13, 21]) #returns @[1, 0, 1, 1, 2, 3, 5, 8]\ndual_seq(@[0, 1, 1, 2, 3, 5, 8, 13, 21]) #returns @[0, -1, -1, -2, -3, -5, -8, -13, -21]\n```\n```ruby\ndual_seq([1]) #returns [1]\ndual_seq([1,2,3,4,5]) #returns [1, -1, 0, 0, 0]\ndual_seq([1, -1, 0, 0, 0]) #returns [1, 2, 3, 4, 5]\ndual_seq([2,4,6,8,10]) #returns [2, -2, 0, 0, 0]\ndual_seq([1,3,5,7,9]) #returns [1, -2, 0, 0, 0]\ndual_seq([1,1,1,1,1]) #returns [1, 0, 0, 0, 0]\ndual_seq([1, 0, 0, 0, 0]) #returns [1, 1, 1, 1, 1]\ndual_seq([1, 4, 9, 16, 25, 36, 49]) #returns [1, -3, 2, 0, 0, 0, 0]\ndual_seq([1, -3, 2, 0, 0, 0, 0]) #return [1, 4, 9, 16, 25, 36, 49]\ndual_seq([1, -3, 2]) #returns [1, 4, 9]\ndual_seq([8, 27, 64, 125, 216]) #returns [8, -19, 18, -6, 0]\ndual_seq([1,2,4,8,16,32,64,128,256]) #returns [1, -1, 1, -1, 1, -1, 1, -1, 1]\ndual_seq([1, -1, 1, -1, 1, -1, 1, -1, 1]) #returns [1, 2, 4, 8, 16, 32, 64, 128, 256]\ndual_seq([1, 1, 2, 3, 5, 8, 13, 21]) #returns [1, 0, 1, 1, 2, 3, 5, 8]\ndual_seq([0, 1, 1, 2, 3, 5, 8, 13, 21]) #returns [0, -1, -1, -2, -3, -5, -8, -13, -21]\n```\n```javascript\ndualSeq([1]) //returns [1]\ndualSeq([1,2,3,4,5]) //returns [1, -1, 0, 0, 0]\ndualSeq([1, -1, 0, 0, 0]) //returns [1, 2, 3, 4, 5]\ndualSeq([2,4,6,8,10]) //returns [2, -2, 0, 0, 0]\ndualSeq([1,3,5,7,9]) //returns [1, -2, 0, 0, 0]\ndualSeq([1,1,1,1,1]) //returns [1, 0, 0, 0, 0]\ndualSeq([1, 0, 0, 0, 0]) //returns [1, 1, 1, 1, 1]\ndualSeq([1, 4, 9, 16, 25, 36, 49]) //returns [1, -3, 2, 0, 0, 0, 0]\ndualSeq([1, -3, 2, 0, 0, 0, 0]) //return [1, 4, 9, 16, 25, 36, 49]\ndualSeq([1, -3, 2]) //returns [1, 4, 9]\ndualSeq([8, 27, 64, 125, 216]) //returns [8, -19, 18, -6, 0]\ndualSeq([1,2,4,8,16,32,64,128,256]) //returns [1, -1, 1, -1, 1, -1, 1, -1, 1]\ndualSeq([1, -1, 1, -1, 1, -1, 1, -1, 1]) //returns [1, 2, 4, 8, 16, 32, 64, 128, 256]\ndualSeq([1, 1, 2, 3, 5, 8, 13, 21]) //returns [1, 0, 1, 1, 2, 3, 5, 8]\ndualSeq([0, 1, 1, 2, 3, 5, 8, 13, 21]) //returns [0, -1, -1, -2, -3, -5, -8, -13, -21]\n```\n```haskell\ndualSeq [1] -- [1]\ndualSeq [1, 2, 3, 4, 5] -- [1, -1, 0, 0, 0]\ndualSeq [1, -1, 0, 0, 0] -- [1, 2, 3, 4, 5]\ndualSeq [2, 4, 6, 8, 10] -- [2, -2, 0, 0, 0]\ndualSeq [1, 3, 5, 7, 9] -- [1, -2, 0, 0, 0]\ndualSeq [1, 1, 1, 1, 1] -- [1, 0, 0, 0, 0]\ndualSeq [1, 0, 0, 0, 0] -- [1, 1, 1, 1, 1]\ndualSeq [1, 4, 9, 16, 25, 36, 49] -- [1, -3, 2, 0, 0, 0, 0]\ndualSeq [1, -3, 2, 0, 0, 0, 0 -- [1, 4, 9, 16, 25, 36, 49]\ndualSeq [1, -3, 2] -- [1, 4, 9]\ndualSeq [8, 27, 64, 125, 216] -- [8, -19, 18, -6, 0]\ndualSeq [1, 2, 4, 8, 16, 32, 64, 128, 256] -- [1, -1, 1, -1, 1, -1, 1, -1, 1]\ndualSeq [1, -1, 1, -1, 1, -1, 1, -1, 1] -- [1, 2, 4, 8, 16, 32, 64, 128, 256]\ndualSeq [1, 1, 2, 3, 5, 8, 13, 21] -- [1, 0, 1, 1, 2, 3, 5, 8]\ndualSeq [0, 1, 1, 2, 3, 5, 8, 13, 21] -- [0, -1, -1, -2, -3, -5, -8, -13, -21]\n```\n```r\ndual_seq(c(1)) #returns c(1)\ndual_seq(c(1,2,3,4,5)) #returns c(1, -1, 0, 0, 0)\ndual_seq(c(1, -1, 0, 0, 0)) #returns c(1, 2, 3, 4, 5)\ndual_seq(c(2,4,6,8,10)) #returns c(2, -2, 0, 0, 0)\ndual_seq(c(1,3,5,7,9)) #returns c(1, -2, 0, 0, 0)\ndual_seq(c(1,1,1,1,1)) #returns c(1, 0, 0, 0, 0)\ndual_seq(c(1, 0, 0, 0, 0)) #returns c(1, 1, 1, 1, 1)\ndual_seq(c(1, 4, 9, 16, 25, 36, 49)) #returns c(1, -3, 2, 0, 0, 0, 0)\ndual_seq(c(1, -3, 2, 0, 0, 0, 0)) #return c(1, 4, 9, 16, 25, 36, 49)\ndual_seq(c(1, -3, 2)) #returns c(1, 4, 9)\ndual_seq(c(8, 27, 64, 125, 216)) #returns c(8, -19, 18, -6, 0)\ndual_seq(c(1,2,4,8,16,32,64,128,256)) #returns c(1, -1, 1, -1, 1, -1, 1, -1, 1)\ndual_seq(c(1, -1, 1, -1, 1, -1, 1, -1, 1)) #returns c(1, 2, 4, 8, 16, 32, 64, 128, 256)\ndual_seq(c(1, 1, 2, 3, 5, 8, 13, 21)) #returns c(1, 0, 1, 1, 2, 3, 5, 8)\ndual_seq(c(0, 1, 1, 2, 3, 5, 8, 13, 21)) #returns c(0, -1, -1, -2, -3, -5, -8, -13, -21)\n```\n```csharp\nDualSeq(new int[] {1}) //returns new int[] {1}\nDualSeq(new int[] {1,2,3,4,5}) //returns new int[] {1, -1, 0, 0, 0}\nDualSeq(new int[] {1, -1, 0, 0, 0}) //returns new int[] {1, 2, 3, 4, 5}\nDualSeq(new int[] {2,4,6,8,10}) //returns new int[] {2, -2, 0, 0, 0}\nDualSeq(new int[] {1,3,5,7,9}) //returns new int[] {1, -2, 0, 0, 0}\nDualSeq(new int[] {1,1,1,1,1}) //returns new int[] {1, 0, 0, 0, 0}\nDualSeq(new int[] {1, 0, 0, 0, 0}) //returns new int[] {1, 1, 1, 1, 1}\nDualSeq(new int[] {1, 4, 9, 16, 25, 36, 49}) //returns new int[] {1, -3, 2, 0, 0, 0, 0}\nDualSeq(new int[] {1, -3, 2, 0, 0, 0, 0}) //return new int[] {1, 4, 9, 16, 25, 36, 49}\nDualSeq(new int[] {1, -3, 2}) //returns new int[] {1, 4, 9}\nDualSeq(new int[] {8, 27, 64, 125, 216}) //returns new int[] {8, -19, 18, -6, 0}\nDualSeq(new int[] {1,2,4,8,16,32,64,128,256}) //returns new int[] {1, -1, 1, -1, 1, -1, 1, -1, 1}\nDualSeq(new int[] {1, -1, 1, -1, 1, -1, 1, -1, 1}) //returns new int[] {1, 2, 4, 8, 16, 32, 64, 128, 256}\nDualSeq(new int[] {1, 1, 2, 3, 5, 8, 13, 21}) //returns new int[] {1, 0, 1, 1, 2, 3, 5, 8}\nDualSeq(new int[] {0, 1, 1, 2, 3, 5, 8, 13, 21}) //returns new int[] {0, -1, -1, -2, -3, -5, -8, -13, -21}\n```\n\n`extra_pol()`\n```python\nextra_pol([1],0) #returns [1]\nextra_pol([1],5) #returns [1, 1, 1, 1, 1, 1]\nextra_pol([1,4],5) #returns [1, 4, 7, 10, 13, 16, 19]\nextra_pol([1,4,9],5) #returns [1, 4, 9, 16, 25, 36, 49, 64]\nextra_pol([4,16,36],5) #returns [4, 16, 36, 64, 100, 144, 196, 256]\nextra_pol([216, 125 ,64 ,27],7) #returns [216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64]\n```\n```nim\nextra_pol(@[1],0) #returns @[1]\nextra_pol(@[1],5) #returns @[1, 1, 1, 1, 1, 1]\nextra_pol(@[1,4],5) #returns @[1, 4, 7, 10, 13, 16, 19]\nextra_pol(@[1,4,9],5) #returns @[1, 4, 9, 16, 25, 36, 49, 64]\nextra_pol(@[4,16,36],5) #returns @[4, 16, 36, 64, 100, 144, 196, 256]\nextra_pol(@[216, 125 ,64 ,27],7) #returns @[216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64]\n```\n```ruby\nextra_pol([1],0) #returns [1]\nextra_pol([1],5) #returns [1, 1, 1, 1, 1, 1]\nextra_pol([1,4],5) #returns [1, 4, 7, 10, 13, 16, 19]\nextra_pol([1,4,9],5) #returns [1, 4, 9, 16, 25, 36, 49, 64]\nextra_pol([4,16,36],5) #returns [4, 16, 36, 64, 100, 144, 196, 256]\nextra_pol([216, 125 ,64 ,27],7) #returns [216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64]\n```\n```javascript\nextraPol([1],0) //returns [1]\nextraPol([1],5) //returns [1, 1, 1, 1, 1, 1]\nextraPol([1,4],5) //returns [1, 4, 7, 10, 13, 16, 19]\nextraPol([1,4,9],5) //returns [1, 4, 9, 16, 25, 36, 49, 64]\nextraPol([4,16,36],5) //returns [4, 16, 36, 64, 100, 144, 196, 256]\nextraPol([216, 125 ,64 ,27],7) //returns [216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64]\n```\n```haskell\nextraPol [1] 0 -- [1]\nextraPol [1] 5 -- [1, 1, 1, 1, 1, 1]\nextraPol [1, 4] 5 -- [1, 4, 7, 10, 13, 16, 19]\nextraPol [1, 4, 9] 5 -- [1, 4, 9, 16, 25, 36, 49, 64]\nextraPol [4, 16, 36] 5 -- [4, 16, 36, 64, 100, 144, 196, 256]\nextraPol [216, 125, 64, 27] 7 -- [216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64]\n```\n```r\nextra_pol(c(1),0) #returns c(1)\nextra_pol(c(1),5) #returns c(1, 1, 1, 1, 1, 1)\nextra_pol(c(1,4),5) #returns c(1, 4, 7, 10, 13, 16, 19)\nextra_pol(c(1,4,9),5) #returns c(1, 4, 9, 16, 25, 36, 49, 64)\nextra_pol(c(4,16,36),5) #returns c(4, 16, 36, 64, 100, 144, 196, 256)\nextra_pol(c(216, 125 ,64 ,27),7) #returns c(216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64)\n```\n```csharp\nExtraPol(new int[] {1},0) //returns new int[] {1}\nExtraPol(new int[] {1},5) //returns new int[] {1, 1, 1, 1, 1, 1}\nExtraPol(new int[] {1,4},5) //returns new int[] {1, 4, 7, 10, 13, 16, 19}\nExtraPol(new int[] {1,4,9},5) //returns new int[] {1, 4, 9, 16, 25, 36, 49, 64}\nExtraPol(new int[] {4,16,36},5) //returns new int[] {4, 16, 36, 64, 100, 144, 196, 256}\nExtraPol(new int[] {216, 125 ,64 ,27},7) //returns new int[] {216, 125, 64, 27, 8, 1, 0, -1, -8, -27, -64}\n```\n\n__Note:__ The _number sequences_ will be given by non-empty* `lists`; (* but possibly of size 1)\n((`lists` in the case of Python; other languages may use (dynamic) `Arrays` (JavaScript,Ruby), `sequences` (Nim), `vectors` (R) etc, but the context (Description and Solution Setup) should make it clear enough... ))",
  "totalAttempts": 858,
  "totalCompleted": 139,
  "totalStars": 41,
  "voteScore": 62,
  "tags": [
    "Mathematics",
    "Algebra",
    "Algorithms",
    "Tutorials"
  ],
  "contributorsWanted": false,
  "unresolved": {
    "issues": 0,
    "suggestions": 3
  }
}