{
  "id": "624fc787983b3500648faf11",
  "name": "Steganography Part 1",
  "slug": "steganography-part-1",
  "category": "reference",
  "publishedAt": "2022-04-09T06:42:15.402Z",
  "approvedAt": "2023-01-01T23:38:33.733Z",
  "languages": [
    "go",
    "python"
  ],
  "url": "https://www.codewars.com/kata/624fc787983b3500648faf11",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2022-04-08T05:26:31.420Z",
  "createdBy": {
    "username": "bshore",
    "url": "https://www.codewars.com/users/bshore"
  },
  "approvedBy": {
    "username": "Blind4Basics",
    "url": "https://www.codewars.com/users/Blind4Basics"
  },
  "description": "## Steganography Part 1\n\nPart 1 of a series using Steganography on RGB image pixels.  \nPart 2: https://www.codewars.com/kata/6251cba4629507b60a041b0e\n\n---\n\nSteganography is the practice of concealing a message within another medium.\n\nIn this case, we'll be taking a message string, and concealing it inside of RGB (Red, Green, Blue) Image Pixels using `Least Significant Bit` (LSB) *Insertion*.\n\nYour function will take the string `msg` and build a **Bitmask** array that is then applied to the `pixels` array, returning the modified pixel values.\n\n## Notes\n1. You can assume that the `pixels` inner arrays always have a length of 3 (for Red, Green, Blue).\n2. Your code should return `nil`/`None` if there aren't enough pixels to conceal the message.\n    - If the message has been fully concealed and there are remaining pixels, the remaining pixels should be left unmodified.\n3. Since bytes are 8 bits long and `pixels` are in groups of 3, the last color of every 3rd array/ group of pixels should not be modified.\n\n## Example\n\nWith the following inputs:\n```\nmsg = \"Hello\"\npixels = [\n  [255, 0, 0],[0, 255, 0],[0, 0, 255],\n  [255, 0, 0],[0, 255, 0],[0, 0, 255],\n  [169, 105, 71],[172, 211, 192],[181, 140, 38],\n  [108, 58, 63],[105, 235, 16],[204, 69, 21],\n  [24, 40, 224],[88, 84, 121],[123, 41, 163],\n]\n```\n\n### Bitmask Array\n\nThe `bitmask` array is a binary representation of each string character. For example with `\"Hello\"` the first character is `H`, and the `ASCII` value of `H` is `72`, which is is `01001000` in binary.\n\nA `bitmask` array for `H` will look like:\n```\n# 01001000 -> 72 -> 'H'\nbitmask = [0, 1, 0, 0, 1, 0, 0, 0]\n```\nExcept for the last color of every third pixel,  \neach bit of the bitmask is applied to one color value of the pixels array, using lsb insertion (which could actually be seen as a lsb _replacement_). \n\nEx:\n- The first color in the `pixels` array is `255` which is `11111111` in binary.\n- Our first bit in the `bitmask` array is `0`, we'll need to **insert** `0` as the `LSB` of `11111111` giving us `11111110`\n  - _Note: you can also think of this as _replacing_ the bit that is already there with a new bit._\n- This color has been modified to `254`, move on to the next color and next bit in the `bitmask` array\n\n### Example output:\n```\noutput = [\n  [254, 1, 0],[0, 255, 0],[0, 0, 255],           // <- 01001000 <- 72  <- 'H'\n  [254, 1, 1],[0, 254, 1],[0, 1, 255],           // <- 01100101 <- 101 <- 'e'\n  [168, 105, 71],[172, 211, 193],[180, 140, 38], // <- 01101100 <- 108 <- 'l'\n  [108, 59, 63],[104, 235, 17],[204, 68, 21],    // <- 01101100 <- 108 <- 'l'\n  [24, 41, 225],[88, 85, 121],[123, 41, 163],    // <- 01101111 <- 111 <- 'o'\n]\n```\n\nNotice how each RGB pixel group contains off-by-one differences, this is the `bitmask` array applied to the input pixels `LSB` bit-by-bit.",
  "totalAttempts": 346,
  "totalCompleted": 121,
  "totalStars": 23,
  "voteScore": 36,
  "tags": [
    "Cryptography",
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}