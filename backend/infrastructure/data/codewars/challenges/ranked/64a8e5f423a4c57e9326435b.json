{
  "id": "64a8e5f423a4c57e9326435b",
  "name": "Optimized Parity Check of Large Binary Words List",
  "slug": "optimized-parity-check-of-large-binary-words-list",
  "category": "algorithms",
  "publishedAt": "2023-07-08T04:28:55.017Z",
  "approvedAt": null,
  "languages": [
    "python"
  ],
  "url": "https://www.codewars.com/kata/64a8e5f423a4c57e9326435b",
  "rank": {
    "id": null,
    "name": null,
    "color": null
  },
  "createdAt": "2023-07-08T04:28:37.034Z",
  "createdBy": {
    "username": "wink01952",
    "url": "https://www.codewars.com/users/wink01952"
  },
  "description": "# Problem Statement\n\nCreate a function that efficiently calculates the parity of a substantial number of 64-bit binary words. The parity of a binary word is defined by the count of 1s in the word. If the number of 1s is odd, the parity is `1`; if it's even, the parity is `0`. Parity checks are frequently used to detect single bit errors in data storage and communication.\n\nYou are not allowed to utilize a brute-force algorithm that checks each bit of the word individually. Instead, you should devise a more resourceful solution that uses a lookup table, which doesn't necessitate `2^64` entries.\n\nMoreover, your function needs to meet a specific time complexity constraint. It should be capable of computing the parity of a list of `n` 64-bit words in `O(n)` time complexity.\n\n## Input \n\nYou will receive a list of 64-bit binary words represented as integers. Each word is symbolized by a non-negative integer in decimal format.\n\n## Output\n\nYour function should return a list of integers. Each integer in this list represents the parity of each corresponding word from the input. The parity value should be either `0` or `1`.\n\n## Constraints\n\nThe length of the input list (words) is between `1` and `10^6` (inclusive). Each word in the list is a 64-bit non-negative integer.\n\n## Note\n\nA brute-force algorithm for this problem is not acceptable. You are required to create a more efficient solution using a lookup table that doesn't require `2^64` entries. Furthermore, your solution should comply with the `O(n)` time complexity constraint.\n\n## Example\n\n```python\ncompute_parity([11, 136, 241, 512, 10001]) # This should return [1, 0, 1, 0, 0]\n```",
  "totalAttempts": 12,
  "totalCompleted": 7,
  "totalStars": 0,
  "voteScore": -5,
  "tags": [
    "Algorithms",
    "Binary",
    "Performance",
    "Data Structures"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}