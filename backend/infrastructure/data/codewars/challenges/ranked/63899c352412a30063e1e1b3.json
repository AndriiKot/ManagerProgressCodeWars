{
  "id": "63899c352412a30063e1e1b3",
  "name": "Activate a Node in a Tree",
  "slug": "activate-a-node-in-a-tree",
  "category": "algorithms",
  "publishedAt": "2022-12-02T09:41:59.589Z",
  "approvedAt": "2022-12-23T15:25:05.446Z",
  "languages": [
    "javascript"
  ],
  "url": "https://www.codewars.com/kata/63899c352412a30063e1e1b3",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2022-12-02T06:33:25.101Z",
  "createdBy": {
    "username": "dfhwze",
    "url": "https://www.codewars.com/users/dfhwze"
  },
  "approvedBy": {
    "username": "JohanWiltink",
    "url": "https://www.codewars.com/users/JohanWiltink"
  },
  "description": "<details open>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Preface</summary>\n\nIf you wish to use the LCA in your solution, I suggest you solve <a href=\"https://www.codewars.com/kata/63879b6208488f20befe8cc9/javascript\">Find the Lowest Common Ancestor\n</a> first.\n\n</details>\n\n<details open>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Task</summary>\n\n##### \"Given a node from a <a href=\"https://en.wikipedia.org/wiki/Tree_(data_structure)\">Tree</a>, return the <b>transition execution sequence</b> required to activate this node.\"\n\n**Input**\n\n*node*: the node requested to be active\n\n**Output**\n\nReturn the transition execution sequence required to activate this node, as an array of array of 2 elements, with the first element being the name of a node, and the second a flag indicating whether the node corresponding to that name got activated <code>1</code> or deactivated <code>0</code>. Return an empty array if the node is already active.\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Rules</summary>\n\nThe following rules are at all time present and are applied recursively to related nodes. All trees in this kata are valid.\n\n1.  Any node that is active, must have an active parent, except for the root note, which has no parent.\n2.  Any node that is inactive, cannot have any active children. (equivalent of rule #1, but from different perspective)\n3.  Any active node that has children, can have at most 1 active child.\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Transition Execution Sequence</summary>\n\nThe transition execution sequence consists of the nodes that have their status changed, in order of execution. We always start with a given node for which we request the status to get activated. Keeping the rules in mind, we can come up with the following behavior:\n\n1. Any node that requests to get activated, but which is active, should do nothing.\n2. Any node that requests to get activated, and is inactive, should first let the parent request to get activated, before changing its own status to active.\n3. Any node that requests to get activated, if any sibling is still active, should let that sibling request to get deactivated first.\n4. Any node that requests to get deactivated, but which is not active, should do nothing.\n5. Any node that requests to get deactivated, and is active, should first let any active child request to get deactivated, before changing its own status to inactive.\n\nNote that since the tree must be valid at any step in the activations / deactivations, this will constrain the order of the output array. You should be able to figure out the correct order of steps from the above rules and behaviors.\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Data Structures</summary>\n\n**Tree**\n\nA tree represents a hierarchical tree structure with a set of connected nodes. In this kata, there is no specific data structure for a tree. The root node (topmost node) will act as the tree.\n\n**Node**\n\nEach node in the tree can be connected to zero, one or more children, but must be connected to exactly one parent, except for the root node, which has no parent. In this kata, a node is connected to its parent using property <code>up</code>, its siblings using properties <code>left</code> and <code>right</code>, and its first child using property <code>down</code>. To get all children, call <code>down</code> and keep calling <code>right</code> until reaching a null pointer. Each node will also have a unique <code>name</code> (lowercase letters and/or numbers) and a flag indicating its <code>status</code> ( active = <code>1</code>, inactive = <code>0</code> ).\n\n*Tree Depiction*\n\nIn this kata, a tree gets displayed as follows. The root node at the top, forking out to its children, and further to grandchildren and other successors. The name, although always consisting of lowercase letters and numbers, will be shown in lowercase for inactive nodes and uppercase for active nodes in all examples used in this kata. In the examples below, the following nodes are active in the left tree: <code>a -> aa -> aab</code>, and the following in the right tree: <code>a -> ab</code>.\n\n```\n             A                                A\n             |                                |\n       AA ---+--- ab                    +-----+-----+\n       |          |                     |     |     |\naaa ---+--- AAB   |                     aa    AB    ac\n                  |                           |\n           aba ---+--- abb             aba ---+--- abb\n```\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Input Constraints</summary>\n\nThe reference solution is able to solve all test cases in +-1 second, so I don't expect too much problems with user solutions timing out. The following random tests are provided:\n\n```\n● 50 random tests with 1 <= depth <= 5 and 2 <= breadth <= 4\n● 5 random tests with 3 <= depth <= 8 and 1 <= breadth <= 10\n● 5 random tests with 10 <= depth <= 13 and 1 <= breadth <= 2\n```\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Debugging Tools</summary>\n\nYou can call<code>console.dir(printTree(node), {depth: null})</code> to inspect a node. Calling this on the root node renders the entire tree. For bigger trees, you may want to use an IDE to inspect the object.\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Examples</summary>\n\n**Examples: Valid Trees**\n\n*Example Tree*\n\nA tree with an active node all the way through the descendants of the root up to reaching a leaf node <code>a -> aa -> aab</code>.\n\n```\n             A\n             |\n       AA ---+--- ab\n       |          |\naaa ---+--- AAB   |\n                  |\n           aba ---+--- abb       \n```\n\n*Example Tree*\n\nA tree with an active node through the descendants of the root up to an internal node <code>a -> aa</code>.\n\n```\n             A\n             |\n       AA ---+--- ab\n       |          |\naaa ---+--- aab   |\n                  |\n           aba ---+--- abb       \n```\n\n*Example Tree*\n\nA tree with no active nodes.\n\n```\n             a\n             |\n       aa ---+--- ab\n       |          |\naaa ---+--- aab   |\n                  |\n           aba ---+--- abb       \n```\n\n**Examples: Invalid Trees**\n\n*Example Tree breaking rules #1 and #2*\n\n1. <code>aa</code> and <code>aab</code> can not be active, because their predecessor <code>a</code> is inactive.\n2. <code>a</code> cannot be inactive, because its successors <code>aa</code> and <code>aab</code> are active.\n\n```\n             a\n             |\n       AA ---+--- ab\n       |          |\naaa ---+--- AAB   |\n                  |\n           aba ---+--- abb       \n```\n\n*Example Tree breaking rule #3*\n\n3. <code>aa</code> or <code>ab</code> can be active, but not both.\n\n```\n             A\n             |\n       AA ---+--- AB\n       |          |\naaa ---+--- AAB   |\n                  |\n           ABA ---+--- abb       \n```\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Sample Tests</summary>\n\nThe following examples are all available in the sample tests. They should give a good idea about the expected behavior for more complex trees.\n\n<small>(*) is used to show which node we want to activate</small>\n\n*Example: Node already active*\n\n\n```\nrequest activation(aa)      = []              // node aa is already active\n\n              A\n              |\n       *AA ---+--- ab\n        |          |\n aaa ---+--- AAB   |\n                   |\n            aba ---+--- abb       \n```\n\n*Example: Parent active*\n\n\n```\nrequest activation(aaa)     = [               \n                                [\"aaa\",1]     // aaa gets activated\n                              ]\n\n              A\n              |\n        AA ---+--- ab\n        |          |\n*aaa ---+--- aab   |\n                   |\n            aba ---+--- abb       \n```\n\n*Example: No active node yet*\n\n\n```\nrequest activation(aaa)     = [               \n                                [\"a\",1],      // root a needs to be activated first\n                                [\"aa\",1],     // parent aa needs to be activated after\n                                [\"aaa\",1]     // aaa is activated\n                              ]\n\n              a\n              |\n        aa ---+--- ab\n        |          |\n*aaa ---+--- aab   |\n                   |\n            aba ---+--- abb       \n```\n\n*Example: Sibling active*\n\n\n```\nrequest activation(aaa)     = [               \n                                [\"aab\",0],    // sibling aab needs to be deactivated first\n                                [\"aaa\",1]     // node aaa gets activated\n                              ]\n\n              A\n              |\n        AA ---+--- ab\n        |          |\n*aaa ---+--- AAB   |\n                   |\n            aba ---+--- abb       \n```\n\n*Example: Uncle active*\n\n\n```\nrequest activation(aaa)     = [               \n                                [\"ab\",0],     // uncle ab needs to be deactivated first\n                                [\"aa\",1],     // parent aa needs to be activated after\n                                [\"aaa\",1]     // node aaa gets activated\n                              ]\n\n              A\n              |\n        aa ---+--- AB\n        |          |\n*aaa  ---+--- aab  |\n                   |\n            aba ---+--- abb       \n```\n\n*Example: Cousin active*\n\n\n```\nrequest activation(aaa)     = [               \n                                [\"abb\",0],    // cousin abb needs to be deactivated first\n                                [\"ab\",0],     // uncle ab needs to be deactivated after\n                                [\"aa\",1],     // parent aa needs to be activated after\n                                [\"aaa\",1]     // node aaa gets activated\n                              ]\n\n              A\n              |\n        aa ---+--- AB\n        |          |\n*aaa ---+--- aab   |\n                   |\n            aba ---+--- ABB       \n```\n\n*Example: Nephew active*\n\n\n```\nrequest activation(aa)      = [               \n                                [\"abb\",0],    // nephew abb needs to be deactivated first\n                                [\"ab\",0],     // sibling ab needs to be deactivated after\n                                [\"aa\",1]      // node aa gets activated\n                              ]\n\n             A\n             |\n      *aa ---+--- AB\n       |          |\naaa ---+--- aab   |\n                  |\n           aba ---+--- ABB       \n```\n\n</details>\n\n<details>\n  <summary style=\"\n    padding: 3px;\n    width: 100%;\n    border: none;\n    font-size: 18px;\n    box-shadow: 1px 1px 2px #bbbbbb; \n    cursor: pointer;\">\n  Glossary</summary>\n\n```\n● root node: a node with no parent, representing a tree\n● internal node: a node with a parent and at least one child\n● leaf node: a node without any children\n● ancestors: the node self and any ancestor of the parent\n● predecessors: the parent node and any predecessor of the parent\n● descendants: the node self and any descendant of the children\n● successors: the children and any successor of the children\n```\n\n</details>\n\n",
  "totalAttempts": 241,
  "totalCompleted": 30,
  "totalStars": 17,
  "voteScore": 28,
  "tags": [
    "Trees",
    "Algorithms",
    "Graphs",
    "Graph Theory",
    "Data Structures",
    "Recursion"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}