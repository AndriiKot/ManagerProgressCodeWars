{
  "id": "6294a4d0eb816e36363b9079",
  "name": "Networking 101/5: Access Control using a Wildcard mask",
  "slug": "networking-101-slash-5-access-control-using-a-wildcard-mask",
  "category": "reference",
  "publishedAt": "2022-05-31T12:42:02.569Z",
  "approvedAt": "2022-06-05T01:24:49.538Z",
  "languages": [
    "c",
    "python"
  ],
  "url": "https://www.codewars.com/kata/6294a4d0eb816e36363b9079",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2022-05-30T11:04:48.445Z",
  "createdBy": {
    "username": "bitcanon",
    "url": "https://www.codewars.com/users/bitcanon"
  },
  "approvedBy": {
    "username": "donaldsebleung",
    "url": "https://www.codewars.com/users/donaldsebleung"
  },
  "description": "### Introduction\n\nIn this kata we are going to take a look at how IPv4 packet filtering works using **A**ccess **C**ontrol **L**ists (ACL), specifically using a technique called **wildcard masks** to match based on an IP address or a range of addresses.\n\nA wildcard mask is the **inverse** of the subnet mask:\n```\n255.255.255.0  = 11111111.11111111.11111111.00000000 (subnet mask)\n0.0.0.255      = 00000000.00000000.00000000.11111111 (wildcard mask)\n```\n\nUsing the wildcard mask we can decide which bits to look at in the IPv4 address when filtering packets. If a bit in the mask is:\n* A zero (`0`), that same bit **must match exactly** between the *IPv4 address* **and** the *network address*.\n* A one (`1`),  that bit can be **either a one or a zero** in the *IPv4 address* compared to the *network address*.\n\n### Example\n\nLet's look at an example:\n```\npermit 192.168.0.0 0.0.0.255\n```\nThis is an entry in an **A**ccess **C**ontrol **L**ist (ACL) telling us to permit packets from `192.168.0.0-255`.\n```\n192.168.0.0    = 11000000.10101000.00000000.00000000 (network address)\n0.0.0.255      = 00000000.00000000.00000000.11111111 (wildcard mask)\n```\nAgain, the zeros (0) must **match exactly** and the ones (1) can be **anything**, so:\n```\n192.168.0.0    = 11000000.10101000.00000000.00000000 (match)\n192.168.0.1    = 11000000.10101000.00000000.00000001 (match)\n192.168.0.254  = 11000000.10101000.00000000.11111110 (match)\n192.168.0.255  = 11000000.10101000.00000000.11111111 (match)\n192.168.1.1    = 11000000.10101000.00000001.00000001 (mismatch)\n192.168.1.254  = 11000000.10101000.00000001.11111110 (mismatch)\n128.168.0.1    = 10000000.10101000.00000000.00000001 (mismatch)\n193.168.0.1    = 11000001.10101000.00000000.00000001 (mismatch)\n```\n**Hint:** Using **bitwise operators** might be helpful here.\n\n### The Assignment\n~~~if:c\nYour task is to implement a function `bool match(const char *net_addr, const char *wc_mask, const char *ipv4_addr)` which takes in a network address `net_addr`, a wildcard mask `wc_mask`, an IPv4 address `ipv4_addr` and determines if the IPv4 address is a match or mismatch. The function returns `true` if it's a match and `false` if it's a mismatch.\n~~~\n~~~if:python\nYour task is to implement a function `match(net_addr: str, wc_mask: str, ipv4_addr: str) -> bool` which takes in a network address `net_addr`, a wildcard mask `wc_mask`, an IPv4 address `ipv4_addr` and determines if the IPv4 address is a match or mismatch. The function returns `True` if it's a match and `False` if it's a mismatch.\n\n~~~\n### Testing\n\nThe tests will challenge your function with addresses and masks in the full 32-bit range (`0.0.0.0 - 255.255.255.255`) and ***nothing else***.\n\n### Links\nCheck out these links for more information:\n* https://en.wikipedia.org/wiki/IPv4#Addressing\n* https://en.wikipedia.org/wiki/Binary_number\n* https://community.cisco.com/t5/networking-documents/access-control-lists-acl-explained/ta-p/4182349\n",
  "totalAttempts": 500,
  "totalCompleted": 133,
  "totalStars": 13,
  "voteScore": 44,
  "tags": [
    "Networks",
    "Bits",
    "Fundamentals",
    "Binary"
  ],
  "contributorsWanted": false,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}