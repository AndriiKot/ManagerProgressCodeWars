{
  "id": "5b9ecec33c5b95e2b00000ba",
  "name": "Chess - checkmate with rook in 16 moves",
  "slug": "chess-checkmate-with-rook-in-16-moves",
  "category": "algorithms",
  "publishedAt": "2018-09-16T22:25:19.673Z",
  "approvedAt": "2023-08-16T13:45:16.526Z",
  "languages": [
    "javascript",
    "python",
    "rust"
  ],
  "url": "https://www.codewars.com/kata/5b9ecec33c5b95e2b00000ba",
  "rank": {
    "id": -2,
    "name": "2 kyu",
    "color": "purple"
  },
  "createdAt": "2018-09-16T21:44:35.928Z",
  "createdBy": {
    "username": "user6793616",
    "url": "https://www.codewars.com/users/user6793616"
  },
  "approvedBy": {
    "username": "lachesism",
    "url": "https://www.codewars.com/users/lachesism"
  },
  "description": "One of the basic [chess endgames](https://en.wikipedia.org/wiki/Chess_endgame) is where only three pieces remain on the board: the two kings and one rook. By 1970 it was proved that the player having the rook can win the game in at most 16 moves. Can you write code that plays this endgame that well?\n\n# Short Overview\n\nYour code will play as white and the testing code will play as black.\n\nEach test case provides you with an initial game setup, consisting of the positions of three pieces: the white king, the white rook, and the black king. Then you will get a valid move for the black king, to which you must reply with a move with a white piece. You will then get another black move for which you should reply with the next white move, ...etc. The testing code will stop this exchange of moves once the game ends, the rook is lost, or an invalid move is made.\n\nYour code must be able to give a checkmate within 16 moves. \n\nAt the end of this description you'll find the relevant rules of chess.\n\n# Details of the Task\n\nWrite a class `WhitePlayer` with:\n\n* A constructor taking a string as argument, listing the positions of the three pieces in the format `Kxy,Rxy - Kxy` where `xy` are coordinates in [algebraic notation](https://en.wikipedia.org/wiki/Algebraic_notation_(chess%29) and the other characters are literal. \n\n Examples of such strings are `Kf8,Rd5 - Ke3` and `Kb6,Rc5 - Kb3`.\n\n The coordinates will always appear in this order and format, and will always be valid. \n They define the positions of the white king, the white rook, and the black king in that order. \n \n In all provided positions it is black's turn to play a move.<p>\n\n* A method `play`, which takes a string as argument and returns a string.\n \n The testing code will call this method to pass as argument a legal black king move. Examples are `Kf3`, `Kb2`, ... always starting with `K` followed by the new position of the black king.\n\n The method should return the move that white will make in response to this black move. It should have the same format. For example: `Rd7`, or `Kb5`. The method should update the state of the game, reflecting that both the given black move and the produced white move have been played. The next call of this method will provide a black move applicable to that modified game state. \n\nThe testing code will keep calling the method with a next black move until one of the following happens (assuming no exceptions are raised):\n\n- the method returns a value that does not represent a valid move (e.g. wrong data type, wrong format, or violating chess rules): the test fails.\n- black can capture the rook: the test fails. The capturing move is mentioned in the failure message with an additional \"x\", like `Kxb4`.\n- black cannot make a valid move. There are three possibilities:\n    - Checkmate after at most 16 white moves: the test succeeds.\n    - Checkmate after more than 16 white moves: the test fails. Note that the test is not interrupted after 16 white moves so at least you can see how many moves it took.\n    - Stalemate: the test fails.\n- The [threefold position](https://en.wikipedia.org/wiki/Threefold_repetition) or [50-move](https://en.wikipedia.org/wiki/Fifty-move_rule) rule applies: the test fails.\n\n### Tests\n\nThe *example* test cases can be finished with one move. If somehow your code takes up to 16 moves for a mate, the tests will pass. But it seems reasonable that your code should detect mate-in-one positions.\n\nThe full tests include around 40 fixed tests with differing levels of difficulty.\n```if:javascript\nThere are 1 000 random tests.\n```\n```if:python\nThere are 500 random tests.\n```\n```if:rust\nThere are 500 random tests.\n```\n\n# Example\n\nHere is an example position:\n\n<table style=\"width: 340px; margin: 0 auto;border-collapse: collapse;font-size: 20px;text-align: center;border-width:0\">\n<tbody>\n<tr><td style=\"height: 40px; width: 20px;border-right:1px solid;\">8</td><td style=\"border-top: 1px solid;background: #cc6; width: 40px;\"></td><td style=\"border-top: 1px solid;background: brown; width: 40px;\"></td><td style=\"border-top: 1px solid #ddd;background: #cc6; width: 40px; font-size: 40px; padding: 0px; line-height:100%;color: #333; text-shadow: -1px 0 #ddd, 0 1px #ddd, 1px 0 #ddd, 0 -1px #ddd;\">♚</td><td style=\"border-top: 1px solid;background: brown; width: 40px;\"></td><td style=\"border-top: 1px solid;background: #cc6; width: 40px; font-size: 40px; padding: 0px; line-height:100%;color: #eee; text-shadow: -1px 0 #333, 0 1px #333, 1px 0 #333, 0 -1px #333;\">♚</td><td style=\"border-top: 1px solid;background: brown; width: 40px;\"></td><td style=\"border-top: 1px solid;background: #cc6; width: 40px;\"></td><td style=\"border-top: 1px solid;border-right:1px solid;background: brown; width: 40px;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">7</td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;font-size: 40px; padding: 0px; line-height:100%;border-right:1px solid;color: #eee; text-shadow: -1px 0 #333, 0 1px #333, 1px 0 #333, 0 -1px #333;\">♜</td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">6</td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;border-right:1px solid;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">5</td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;border-right:1px solid;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">4</td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;border-right:1px solid;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">3</td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;border-right:1px solid;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">2</td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;border-right:1px solid;\"></td></tr>\n<tr><td style=\"height: 40px;border-right:1px solid;\">1</td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;\"></td><td style=\"background: brown;\"></td><td style=\"background: #cc6;border-right:1px solid;\"></td></tr>\n</tbody>\n<tfoot>\n<tr><td style=\"height: 20px;\"></td><td style=\"border-top:1px solid;text-align:center\">a</td><td style=\"border-top:1px solid;text-align:center\">b</td><td style=\"border-top:1px solid;text-align:center\">c</td><td style=\"border-top:1px solid;text-align:center\">d</td><td style=\"border-top:1px solid;text-align:center\">e</td><td style=\"border-top:1px solid;text-align:center\">f</td><td style=\"border-top:1px solid;text-align:center\">g</td><td style=\"border-top:1px solid;text-align:center\">h</td></tr>\n</tfoot>\n</table>\n\nThis position would be passed to the constructor as `Ke8,Rh7 - Kc8`.\n\nBlack has only one valid move here, `Kb8`, so that is what the testing code will call your method with. The game could proceed like this:\n\n```javascript\nconst whitePlayer = new WhitePlayer(\"Ke8,Rh7 - Kc8\");\nconst whiteMove = whitePlayer.play(\"Kb8\"); \n// Your code will determine what the return value is, let's assume it's \"Kd8\";\n//   then black has again only one possible move:\nwhiteMove = whitePlayer.play(\"Ka8\");\n// Maybe you decided to return \"Kc7\"? Good choice!\nwhiteMove = whitePlayer.play(\"Ka7\");\n// Maybe you returned \"Rh6\" so that black can only return back to square a8\nwhiteMove = whitePlayer.play(\"Ka8\");\n// If your code is good, it will certainly return \"Ra6\" here, \n//   at which moment you pass the test... it is a checkmate.\n```\n```python\nwhiteplayer = WhitePlayer(\"Ke8,Rh7 - Kc8\")\nwhitemove = whiteplayer.play(\"Kb8\")\n# Your code will determine what the return value is, let's assume it's \"Kd8\";\n#   then black has again only one possible move:\nwhitemove = whiteplayer.play(\"Ka8\")\n# Maybe you decided to return \"Kc7\"? Good choice!\nwhitemove = whiteplayer.play(\"Ka7\")\n# Maybe you returned \"Rh6\" so that black can only return back to square a8\nwhitemove = whiteplayer.play(\"Ka8\")\n# If your code is good, it will certainly return \"Ra6\" here, \n#   at which moment you pass the test... it is a checkmate.\n```\n```rust\nlet mut white_player = WhitePlayer::new(\"Ke8,Rh7 - Kc8\");\nlet mut white_move = white_player.play(\"Kb8\");\n// Your code will determine what the return value is, let's assume it's \"Kd8\";\n//   then black has again only one possible move:\nwhite_move = white_player.play(\"Ka8\");\n// Maybe you decided to return \"Kc7\"? Good choice!\nwhite_move = whiteplayer.play(\"Ka7\");\n// Maybe you returned \"Rh6\" so that black can only return back to square a8\nwhite_move = whiteplayer.play(\"Ka8\");\n// If your code is good, it will certainly return \"Ra6\" here, \n//   at which moment you pass the test... it is a checkmate.\n```\n\n# The real challenge: not more than 16 moves\n\nThe black king must be checkmated *in 16 white moves* or less. The black king will use some simple (imperfect) [heuristic](https://en.wikipedia.org/wiki/Heuristic) to delay that fate for as long as possible.\n\nThe last bunch of tests generate positions that are known to need 16 white moves with perfect play. Although black does not always play the best move, the random nature of the tests and their number provide a high probability that black will happen to play a perfect defense in a few tests. Consequently your code must aim to play the best moves for white as well. Often there are multiple best moves in one position, so there is a little leeway.\n\nSeveral possibilities are in front of you: maybe you can think of a smart [evaluation function](https://en.wikipedia.org/wiki/Evaluation_function), [alpha beta pruning](https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning), [killer moves](https://en.wikipedia.org/wiki/Killer_heuristic), and some other optimisations. Or, maybe you'll go for a purely data driven approach by first building a comprehensive [tablebase](https://en.wikipedia.org/wiki/Endgame_tablebase) or a variation on that. Or maybe you'll go for a combination of these approaches. There is probably more than one good way to go about this; just be prepared that there are many random tests and you only have 12 seconds to finish all those games with checkmate, each within 16 moves.\n\nThere are also resources online that will provide you the best move in any given position of these three pieces. See for example [this Chess Endgame Database](https://www.shredderchess.com/online/endgame-database.html).\n\nGood luck!\n\n# Appendix\n\n## 1. Chess Rules\n\nChess is played on a 8x8 board, with two players: one plays with the white pieces, the other with the black ones. They take turns in playing a move. The pieces we need for this kata are:\n\n* **King**: a [king](https://en.wikipedia.org/wiki/King_(chess%29) can move to an adjacent square, either horizontally, vertically or diagonally, in any direction. There are always two kings in a game: a white one and a black one. They may never come within eachother's reach. There must be at least one empty square between them. The king may never move to a square where it could be captured by an opponent piece. Therefore, kings can never be captured.\n* **Rook**: a [rook](https://en.wikipedia.org/wiki/Rook_(chess%29) may only move horizontally or vertically, but possibly more than one square at a time, so it can even go from one side of the board to the other end. It may however not jump over another piece, nor occupy a square with a piece of the same color. In this kata there will only be one, white rook. The rook should be placed carefully, as the black king can potentially capture it when it is right next to it. In that case the rook is taken off the board, and the black king takes its position. \n\nIf after white's move the rook attacks the black king, the black king is [\"in check\"](https://en.wikipedia.org/wiki/Check_(chess%29). In that case, the black king must move away. If there is no place for the king to go where it is no longer attacked, then it is a [checkmate](https://en.wikipedia.org/wiki/Checkmate): white wins. \n\nIf the black king is not attacked, but it cannot move anywhere, black is in a so-called [\"stalemate\"](https://en.wikipedia.org/wiki/Stalemate). In that case the game ends without a winner; it is a draw. In this kata you should avoid bringing black into stalemate; you must win!\n\nA player can claim a draw when:\n\n* both players played 50 moves without capturing a piece or without pawn move (there are no pawns in this kata). This is the [50-move](https://en.wikipedia.org/wiki/Fifty-move_rule) rule. \n\n* a position is arrived at that already occurred twice before. This is the [threefold repetition](https://en.wikipedia.org/wiki/Threefold_repetition) rule. \n\nIn this kata the black player (the testing code) will claim a draw when possible.\n\n## 2. Algabraic Notation\n\nSee [Wikipedia](https://en.wikipedia.org/wiki/Algebraic_notation_(chess%29): The letter part (a-h) determines the column and the number part (1-8) the row as depicted in the image above. \"K\" refers to the king, and \"R\" to the rook. \"Rh1\" means the rook moves to the bottom-right square of the board.\n\n## 3. Strategy\n\nA common strategy in this particular endgame, is to use the rook to confine the black king to a box as it cannot cross the vertical and horizontal lines of the rook's attack, and to reduce that box as the game progresses. Defend the rook with the king, or when that is not possible, move the rook into safety without giving up (too much of) that space restriction. The king is necessary to assist in forcing the black king backwards and to defend the rook. Eventually the black king is pressed against the edge of the board, and once the white king is moved straight in front of it (with one square in between), the rook can give the checkmate.\n\nFor more about strategies for this endgame see for example the articles on [WikiBooks](https://en.wikibooks.org/wiki/Chess/The_Endgame/King_and_Rook_vs._King), [Chess.StackExchange](https://chess.stackexchange.com/questions/4886/how-do-you-checkmate-with-a-rook), [Chess Corner](http://www.chesscorner.com/tutorial/basic/r_k_mate/r_k_mate.htm), or [Regency Chess](https://www.regencychess.co.uk/blog/2012/10/chess-noob-17-mating-with-a-king-and-rook/). Be aware though that such strategies may lead to a move sequence that is longer than accepted in this kata.\n\n",
  "totalAttempts": 2997,
  "totalCompleted": 55,
  "totalStars": 82,
  "voteScore": 22,
  "tags": [
    "Games",
    "Performance",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 1
  }
}