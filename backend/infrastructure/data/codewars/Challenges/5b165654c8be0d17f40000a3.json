{
  "id": "5b165654c8be0d17f40000a3",
  "name": "Simple number divisibility",
  "slug": "simple-number-divisibility",
  "category": "reference",
  "publishedAt": "2018-06-05T09:23:13.934Z",
  "approvedAt": "2018-06-08T09:47:20.143Z",
  "languages": [
    "javascript",
    "python",
    "ruby",
    "haskell",
    "cpp",
    "csharp",
    "java"
  ],
  "url": "https://www.codewars.com/kata/5b165654c8be0d17f40000a3",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2018-06-05T09:22:28.526Z",
  "createdBy": {
    "username": "KenKamau",
    "url": "https://www.codewars.com/users/KenKamau"
  },
  "approvedBy": {
    "username": "ZED.CWT",
    "url": "https://www.codewars.com/users/ZED.CWT"
  },
  "description": "In this Kata, you will be given a number and your task will be to rearrange the number so that it is divisible by `25`, but without leading zeros. Return the minimum number of digit moves that are needed to make this possible. If impossible, return `-1` ( `Nothing` in Haskell ).\n\nFor example:\n```c\nsolve(521) = 3 because:\n    a) Move the digit '1' to the front: 521 -> 512 -> 152. The digit '1' is moved two times.\n    b) Move '5' to the end: 152 -> 125. The digit '5' is moved one time, so total movement = 3.\nOf all the ways to accomplish this, the least digit moves = 3.\n\nsolve(100) = 0. Number already divisible by 25.\nsolve(1) = -1. Not possible to make number divisible by 25.\n\nsolve(0) is not tested.\n```\n\nMore examples in test cases.\n\nGood luck!",
  "totalAttempts": 4417,
  "totalCompleted": 199,
  "totalStars": 45,
  "voteScore": 64,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 1
  }
}