{
  "id": "54fb853b2c8785dd5e000957",
  "name": "Chain me",
  "slug": "chain-me",
  "category": "reference",
  "publishedAt": "2015-03-07T23:16:21.495Z",
  "approvedAt": "2015-03-19T05:13:27.819Z",
  "languages": [
    "javascript",
    "ruby",
    "csharp",
    "c",
    "haskell",
    "julia",
    "python",
    "factor",
    "ocaml",
    "nasm",
    "prolog",
    "rust"
  ],
  "url": "https://www.codewars.com/kata/54fb853b2c8785dd5e000957",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2015-03-07T23:09:47.564Z",
  "createdBy": {
    "username": "nrgarg",
    "url": "https://www.codewars.com/users/nrgarg"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "~~~if-not:prolog\n## Write a generic function chainer\n\nWrite a generic function chainer that takes a starting value, and an array of functions to execute on it (array of symbols for Ruby).\n\nThe input for each function is the output of the previous function (except the first function, which takes the starting value as its input). Return the final value after execution is complete.\n~~~\n~~~if:prolog\n## Write a generic predicate chainer\n\nWrite a generic predicate chainer that takes a starting value, and an array of atoms to execute on it.\n\nThe first input for each predicate is the output of the previous predicate (except the first predicate, which takes the starting value as its input). Return the final value after execution is complete.\n~~~\n\n```javascript\nfunction add(num) {\n  return num + 1;\n}\n\nfunction mult(num) {\n  return num * 30;\n}\n\nchain(2, [add, mult]);\n// returns 90;\n```\n```haskell\nadd = (+ 1)\nmul = (* 30)\n\nchain 2 [add, mult] -> 90\n```\n```ruby\ndef add num\n  num + 1\nend\n\ndef mult num\n  num * 30 \nend\n\nchain(2, [:add, :mult])\n#=> returns 90\n```\n```csharp\ndouble input = 2;\n\npublic static double add(double x) {\n  return x + 1;\n}\n\npublic static double mul(double x) {\n   return x * 30;\n}\nKata.Chain( input , new[] { (Func<double, double>)add, mul });\n//=> returns 90\n```\n\n```c\nint add10 (int x) { return x + 10; }\nint mul30 (int x) { return x * 30; }\n\ntypedef int (*funcptr) (int);\n\nchain(50, 2, (funcptr[2]) {add10, mul30});\n// returns 1800\n```\n\n```python\ndef add10(x): return x + 10\ndef mul30(x): return x * 30\n\nchain(50, [add10, mul30])\n# returns 1800\n```\n```factor\n: add10 ( x -- r ) 10 + ;\n: mul30 ( x -- r ) 30 * ;\n\n50 { [ add10 ] [ mul30 ] } chain\n! returns 1800\n```\n```ocaml\nlet add n = n + 1 in\nlet mult n = n * 30 in\n\nchain 2 [add; mult] (* -> 90 *)\n```\n```prolog\nadd(X,R):-R is X+1.\nmul(X,R):-R is X*30.\n\n?- chain(2,[add,mul],Result). % Result = 90.\n```\n```rust\nfn add10(x) { x + 10 }\nfn mul30(x) { x + 30 }\n\nchain(50, &[&add10, &mul30]) //=> returns 1800\n```",
  "totalAttempts": 24590,
  "totalCompleted": 7952,
  "totalStars": 134,
  "voteScore": 720,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 3,
    "suggestions": 1
  }
}