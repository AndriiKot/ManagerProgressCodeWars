{
  "id": "564871e795df155582000013",
  "name": "Fill in the gaps in my timesheet.",
  "slug": "fill-in-the-gaps-in-my-timesheet",
  "category": "algorithms",
  "publishedAt": "2015-11-15T13:05:27.275Z",
  "approvedAt": "2016-01-29T05:24:13.793Z",
  "languages": [
    "ruby",
    "javascript",
    "haskell",
    "python"
  ],
  "url": "https://www.codewars.com/kata/564871e795df155582000013",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2015-11-15T11:52:07.531Z",
  "createdBy": {
    "username": "Insti",
    "url": "https://www.codewars.com/users/Insti"
  },
  "approvedBy": {
    "username": "joh_pot",
    "url": "https://www.codewars.com/users/joh_pot"
  },
  "description": "### Background: \n\nAt work I need to keep a timesheet, by noting which project I was working on every 15 minutes. \nI have an timer that beeps every 15 minutes to prompt me to note down what I was working on at that point, but sometimes when I'm away from my desk or working continuously on one project, I don't note anything down and these get recorded as `null`.\n\n### Task:\n\nHelp me populate my timesheet by replacing any `null` values in the array with the correct project name which is given by surrounding matching values.\n\n### Examples:\n\n```ruby\nfill_gaps([1,nil,1]) -> [1,1,1]   # Replace nill values surrounded by matching values\nfill_gaps([1,nil,nil,nil,1]) -> [1,1,1,1,1]  # There may be multiple nils\nfill_gaps([1,nil,1,2,nil,2]) -> [1,1,1,2,2,2]  # There may be multiple replacements required\nfill_gaps([1,nil,2,nil,2,nil,1]) -> [1,nil,2,2,2,nil,1]  # No nesting.\nfill_gaps([1,nil,2]) -> [1,nil,2] # No replacement if ends don't match\nfill_gaps([nil,1,nil]) -> [nil,1,nil] # No replacement if ends don't match off the ends of the array\nfill_gaps(['codewars', nil, nil, 'codewars', 'real work', nil, nil, 'real work']) -> [\"codewars\", \"codewars\", \"codewars\", \"codewars\", \"real work\", \"real work\", \"real work\", \"real work\"] # Works with strings too\n```\n```javascript\nfill_gaps([1,null,1]) -> [1,1,1]   # Replace nulll values surrounded by matching values\nfill_gaps([1,null,null,null,1]) -> [1,1,1,1,1]  # There may be multiple nulls\nfill_gaps([1,null,1,2,null,2]) -> [1,1,1,2,2,2]  # There may be multiple replacements required\nfill_gaps([1,null,2,null,2,null,1]) -> [1,null,2,2,2,null,1]  # No nesting.\nfill_gaps([1,null,2]) -> [1,null,2] # No replacement if ends don't match\nfill_gaps([null,1,null]) -> [null,1,null] # No replacement if ends don't match off the ends of the array\nfill_gaps(['codewars', null, null, 'codewars', 'real work', null, null, 'real work']) -> [\"codewars\", \"codewars\", \"codewars\", \"codewars\", \"real work\", \"real work\", \"real work\", \"real work\"] # Works with strings too\n```\n```haskell\n-- Replace null values surrounded by matching values\nfillGaps [Just 1,  Nothing, Just 1] ->\n         [Just 1,  Just 1,  Just 1]\n-- There may be multiple nulls\nfillGaps [Just 1,  Nothing, Nothing, Nothing, Just 1] ->\n         [Just 1,  Just 1,  Just 1,  Just 1,  Just 1] \n-- There may be multiple replacements required\nfillGaps [Just 1,  Nothing, Just 1,  Just 2,  Nothing, Just 2] ->\n         [Just 1,  Just 1,  Just 1,  Just 2,  Just 2,  Just 2]\n-- No nesting\nfillGaps [Just 1,  Nothing, Just 2,  Nothing, Just 2,  Nothing,  Just 1] ->\n         [Just 1,  Nothing, Just 2,  Just 2,  Just 2,  Nothing,  Just 1]\n -- No replacement if ends don't match\nfillGaps [Just 1,  Nothing, Just 2] ->\n         [Just 1,  Nothing, Just 2]\n-- No replacement if ends don't match off the ends of the array\nfillGaps [Nothing, Just 1,  Nothing] ->\n         [Nothing, Just 1,  Nothing]\n```\n```python\nfill_gaps([1,None,1]) -> [1,1,1]   # Replace None values surrounded by matching values\nfill_gaps([1,None,None,None,1]) -> [1,1,1,1,1]  # There may be multiple Nones\nfill_gaps([1,None,1,2,None,2]) -> [1,1,1,2,2,2]  # There may be multiple replacements required\nfill_gaps([1,None,2,None,2,None,1]) -> [1,None,2,2,2,None,1]  # No nesting.\nfill_gaps([1,None,2]) -> [1,None,2] # No replacement if ends don't match\nfill_gaps([None,1,None]) -> [None,1,None] # No replacement if ends don't match off the ends of the array\nfill_gaps(['codewars', None, None, 'codewars', 'real work', None, None, 'real work']) -> [\"codewars\", \"codewars\", \"codewars\", \"codewars\", \"real work\", \"real work\", \"real work\", \"real work\"] # Works with strings too\n```\n\n### Input:\n\nAn array of values some of which will be `null`\n\n### Output:\n\nAn array with any consecutive `null` elements surrounded by equal values replaced by that value.\n\n### Note: \n\n`null` is language specific, for Ruby it will be `nil`, for Python `None`\n\nInput will always be a valid array.  \nThe original array should not be modified.   \t\nThe output array might still contain `null` values.\nThe values in the array can be of different data types, but as long as they are `==` they can be considered the same.\nIn Haskell `Maybe Int` is used, hence numbers only and `Nothing` as an empty value\n\nSometimes I forget to note when I stopped working on a project and started on a new one. In this case there will still be `null`s in the resulting array. In this case I'll need to manually resolve the problem by checking my git logs or message timestamps for clues as to when I changed task.\nBut that's not something you need to worry about in this kata.",
  "totalAttempts": 7299,
  "totalCompleted": 678,
  "totalStars": 59,
  "voteScore": 150,
  "tags": [
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 1
  }
}