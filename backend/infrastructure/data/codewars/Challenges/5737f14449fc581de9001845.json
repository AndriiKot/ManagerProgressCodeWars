{
  "id": "5737f14449fc581de9001845",
  "name": "Inner Calls In Recursion I",
  "slug": "inner-calls-in-recursion-i",
  "category": "reference",
  "publishedAt": "2016-05-15T19:57:38.880Z",
  "approvedAt": "2017-06-28T02:55:55.762Z",
  "languages": [
    "python",
    "javascript",
    "ruby"
  ],
  "url": "https://www.codewars.com/kata/5737f14449fc581de9001845",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-05-15T03:47:16.522Z",
  "createdBy": {
    "username": "raulbc777",
    "url": "https://www.codewars.com/users/raulbc777"
  },
  "approvedBy": {
    "username": "Voile",
    "url": "https://www.codewars.com/users/Voile"
  },
  "description": "For a certain simulation, a group of students have to produce numbers close to ```2``` in a certain order. Their instructor guide them explaining an algorithm useful for that task.\n\nAn array of integers, arr, is received.\n\narr = [n1, n2, ....,nk]\n\nThe array should be transformed, doing the following steps:\n\n- each value of the array, ```ni```, will be substituted by the value ```(ni + μ) / μ```\n\n\n```μ = (Σ ni) / k  (mean of the array)```\n\nAfter doing this process recursively, it will be seen that the final array will trend to this final one: ```[2.0, 2.0, .....2.0]```\n\nLet's start with this one: ```[12, 7, 23]```\n```\narray                                               μ                             transformed array                        number of calls\n[12, 7, 23]                                        14.0             [1.8571428571428572, 1.5, 2.642857142857143]                1\n[1.8571428571428572, 1.5, 2.642857142857143]        2.0             [1.9285714285714286, 1.75, 2.321428571428571]               2\n[1.9285714285714286, 1.75, 2.321428571428571]       2.0             [1.9642857142857144, 1.875, 2.1607142857142856]             3\n.............................................       ....             ............................................               ...\n.............................................       ....             ............................................               ...\n[2.0, 2.0, 2.0]                                     2.0             [2.0, 2.0, 2.0]                                            54\n```\nAfter certain number of recursive steps, the difference between ```2``` and the obtained values is so small that cannot be detected by the programming language system.\n\nIn order to estimate the amount of generated values, they need to determine the number of recursive calls for this process.\n\nDo you want to help them?\n\nThey need the function ```simul_close_to2()``` that receives a certain array, and a minimum absolute error, ```abs_error```. The function will output the inner calls.\n\nThe recursion should stop when ```|arr[i] - arr[i + 1]| ≤ abs_error``` for all ```i``` of the array. For that purpose we need a helper function ```are_contigElemen_closeEnough()``` that receives an array and the abs_error and outputs True when this condition is fulfilled and False when not.\n\nLet's see the above case for different absolute errors:\n```python\nsimul_close_to2([12, 7, 23], pow(10, -5)) == 18 # final array [1.9999989100864957, 1.9999961853027344, 2.00000490461077]\n\nsimul_close_to2([12, 7, 23], pow(10, -8)) == 28 # final array [1.9999999989356314, 1.9999999962747097, 2.000000004789659]\n\nsimul_close_to2([12, 7, 23], pow(10, -12)) == 42 # final array [1.9999999999999352, 1.9999999999997726, 2.000000000000292]\n```\n\nThe tests for the function will have the following features:\n```\nN < 250 (N, number of tests)\n3 ≤ L ≤ 5000 (L, length of the array)\n1 ≤ ni ≤ 10000000 (arr = [n1, n2,..., ni, ..., nk])\n10^(-17) ≤ abs_error ≤ 0.001\n```\nEnjoy it!",
  "totalAttempts": 632,
  "totalCompleted": 175,
  "totalStars": 23,
  "voteScore": 47,
  "tags": [
    "Fundamentals",
    "Data Structures",
    "Algorithms",
    "Mathematics",
    "Recursion"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 1
  }
}