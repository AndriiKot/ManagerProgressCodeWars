{
  "id": "54554846126a002d5b000854",
  "name": "A Gift Well Spent",
  "slug": "a-gift-well-spent",
  "category": "algorithms",
  "publishedAt": "2014-11-03T11:42:51.180Z",
  "approvedAt": "2014-11-19T01:23:07.885Z",
  "languages": [
    "haskell",
    "javascript",
    "coffeescript",
    "python",
    "cobol"
  ],
  "url": "https://www.codewars.com/kata/54554846126a002d5b000854",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2014-11-01T20:53:26.809Z",
  "createdBy": {
    "username": "bkaes",
    "url": "https://www.codewars.com/users/bkaes"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Note: This kata has been inspired by [GCJ 2010's \"Store credit\"](https://code.google.com/codejam/contest/351101/dashboard#s=p0), where one also has to parse the actual input. If you solved this kata, try that one too. Note that GCJ's version always has a solution, whereas this kata might not.\n\n### Story\nYou got a gift card for your local store. It has some credit you can use to buy things, but it may be used only for up to two items, and any credit you don't use is lost. You want something for a friend and yourself. Therefore, you want to buy two items which add up the entire gift card value.\n\n### Task\nYou will get the value of the gift card `c` and a finite list of item values. You should return a pair of indices that correspond to values that add up to `c`:\n\n```haskell\nbuy 2 [1,1]       = Just (0,1)\nbuy 3 [1,1]       = Nothing\nbuy 5 [5,2,3,4,5] = Just (1,2)\n```\n```javascript\nbuy(2,[1,1])       = [0,1]\nbuy(3,[1,1])       = null\nbuy(5,[5,2,3,4,5]) = [1,2]\n```\n```python\nbuy(2,[1,1])       = [0,1]\nbuy(3,[1,1])       = None\nbuy(5,[5,2,3,4,5]) = [1,2]\n```\n```coffeescript\nbuy 2, [1,1]       = [0,1]\nbuy 3, [1,1]       = null\nbuy 5, [5,2,3,4,5] = [1,2]\n```\n```cobol\n      buy 2, [1,1]       = [1, 2]\n      buy 3, [1,1]       = [0, 0]\n      buy 5, [5,2,3,4,5] = [2, 3]\n```\n    \nThe indices start at `0` (`1` in COBOL). The first index should always be smaller than the second index. If there are multiple solutions, return the minimum (lexicographically):\n\n```haskell\nbuy 5 [1,2,3,4,5] = Just (0,3) -- the values at (1,2) also adds up to five, but (0,3) < (1,2)\n```\n```javascript\nbuy(5,[1,2,3,4,5]) = [0,3] // the values at [1,2] also adds up to five, but [0,3] < [1,2]\n```\n```python\nbuy(5,[1,2,3,4,5]) = [0,3] # the values at [1,2] also adds up to five, but [0,3] < [1,2]\n```\n```coffeescript\nbuy 5, [1,2,3,4,5] = [0,3] # the values at [1,2] also adds up to five, but [0,3] < [1,2]\n```\n```cobol\n      buy 5, [1, 2, 3, 4, 5] = [1, 4]\n      * the values at [2, 3] also adds up to five, but [1, 4] < [2, 3]\n```\n",
  "totalAttempts": 9582,
  "totalCompleted": 2244,
  "totalStars": 56,
  "voteScore": 335,
  "tags": [
    "Lists",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 2
  }
}