{
  "id": "5b65c47cbedf7b69ab00066e",
  "name": "Build a Trie",
  "slug": "build-a-trie",
  "category": "reference",
  "publishedAt": "2018-08-04T15:21:32.753Z",
  "approvedAt": "2018-08-05T15:07:20.848Z",
  "languages": [
    "python",
    "ruby",
    "groovy",
    "javascript",
    "coffeescript",
    "java",
    "haskell"
  ],
  "url": "https://www.codewars.com/kata/5b65c47cbedf7b69ab00066e",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2018-08-04T15:21:45.325Z",
  "createdBy": {
    "username": "suic",
    "url": "https://www.codewars.com/users/suic"
  },
  "approvedBy": {
    "username": "docgunthrop",
    "url": "https://www.codewars.com/users/docgunthrop"
  },
  "description": "The goal of this kata is to implement [trie](https://en.wikipedia.org/wiki/Trie) (or prefix tree) using dictionaries (aka hash maps or hash tables), where:\n\n1. the dictionary keys are the prefixes\n2. the value of a leaf node is `None` in Python, `nil` in Ruby, `null` in Groovy, JavaScript and Java, and `Nothing` in Haskell.\n3. the value for empty input is `{}` in Python, Ruby, Javascript and Java (empty map), `[:]` in Groovy, and `Trie []` in Haskell.\n\n**Examples:**\n\n```python\n>>> build_trie()\n{}\n>>> build_trie(\"\")\n{}\n>>> build_trie(\"trie\")\n{'t': {'tr': {'tri': {'trie': None}}}}\n>>> build_trie(\"tree\")\n{'t': {'tr': {'tre': {'tree': None}}}}\n>>> build_trie(\"A\",\"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\")\n{'A': None, 't': {'to': None, 'te': {'tea': None, 'ted': None, 'ten': None}}, 'i': {'in': {'inn': None}}}\n>>> build_trie(\"true\", \"trust\")\n{'t': {'tr': {'tru': {'true': None, 'trus': {'trust': None}}}}}\n```\n\n```ruby\n>> build_trie()\n=> {}\n>> build_trie(\"\")\n=> {}\n>> build_trie(\"trie\")\n=> {\"t\" => {\"tr\" => {\"tri\" => {\"trie\" =>  nil}}}}\n>> build_trie(\"tree\")\n=> {\"t\" => {\"tr\" => {\"tre\" => {\"tree\" =>  nil}}}}\n>> build_trie(\"trie\", \"trie\")\n=> {\"t\" => {\"tr\" => {\"tri\" => {\"trie\" =>  nil}}}}\n>> build_trie(\"A\",\"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\")\n=> {\"A\" =>  nil, \"t\" => {\"to\" =>  nil, \"te\" => {\"tea\" =>  nil, \"ted\" =>  nil, \"ten\" =>  nil}}, \"i\" => {\"in\" => {\"inn\" =>  nil}}}\n>> build_trie(\"true\", \"trust\")\n=> {\"t\" => {\"tr\" => {\"tru\" => {\"true\" =>  nil, \"trus\" => {\"trust\" =>  nil}}}}}\n```\n\n```groovy\nKata.buildTrie() == [:]\nKata.buildTrie(\"\") == [:]\nKata.buildTrie(\"trie\") == [\"t\": [\"tr\": [\"tri\": [\"trie\": null]]]]\nKata.buildTrie(\"tree\") == [\"t\": [\"tr\": [\"tre\": [\"tree\": null]]]]\nKata.buildTrie(\"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\") == [\"A\": null, \"t\": [\"to\": null, \"te\": [\"tea\": null, \"ted\": null, \"ten\": null]], \"i\": [\"in\": [\"inn\": null]]]\nKata.buildTrie(\"true\", \"trust\") == [\"t\": [\"tr\": [\"tru\": [\"true\": null, \"trus\": [\"trust\": null]]]]]\n```\n\n```haskell\n-- Note that the trie format is a standard assoclist, but `newtype`d because of type recursion.\n-- This type is Preloaded, and its Eq instance does not require equal ordering for equality.\n\nbuildTrie [] -> Trie []\nbuildTrie [\"\"] -> Trie []\nbuildTrie [\"trie\"] -> Trie [(\"t\",Just (Trie [(\"tr\",Just (Trie [(\"tri\",Just (Trie [(\"trie\",Nothing)]))]))]))]\nbuildTrie [\"tree\"] -> Trie [(\"t\",Just (Trie [(\"tr\",Just (Trie [(\"tre\",Just (Trie [(\"tree\",Nothing)]))]))]))]\nbuildTrie [\"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\"] -> Trie [ (\"A\",Nothing), (\"t\",Just (Trie [ (\"to\",Nothing), (\"te\",Just (Trie [ (\"tea\",Nothing), (\"ted\",Nothing), (\"ten\",Nothing) ])) ])), (\"i\",Just (Trie [ (\"in\",Just (Trie [ (\"inn\",Nothing) ])) ])) ]\nbuildTrie [\"true\", \"trust\"] -> Trie [(\"t\",Just (Trie [(\"tr\",Just (Trie [(\"tru\",Just (Trie [(\"true\",Nothing),(\"trus\",Just (Trie [(\"trust\",Nothing)]))]))]))]))]\n```\n\n```javascript\nbuildTrie() => {}\nbuildTrie(\"\") => {}\nbuildTrie(\"trie\") => {'t': {'tr': {'tri': {'trie': null}}}}\nbuildTrie(\"tree\") => {'t': {'tr': {'tre': {'tree': null}}}}\nbuildTrie(\"A\",\"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\") => {'A': null, 't': {'to': null, 'te': {'tea': null, 'ted': null, 'ten': null}}, 'i': {'in': {'inn': null}}}\nbuildTrie(\"true\", \"trust\") => {'t': {'tr': {'tru': {'true': null, 'trus': {'trust': null}}}}}\n```\n\n```coffeescript\nbuildTrie() => {}\nbuildTrie(\"\") => {}\nbuildTrie(\"trie\") => {'t': {'tr': {'tri': {'trie': null}}}}\nbuildTrie(\"tree\") => {'t': {'tr': {'tre': {'tree': null}}}}\nbuildTrie(\"\") => {'A': null, 't': {'to': null, 'te': {'tea': null, 'ted': null, 'ten': null}}, 'i': {'in': {'inn': null}}}\nbuildTrie(\"true\", \"trust\") => {'t': {'tr': {'tru': {'true': null, 'trus': {'trust': null}}}}}\n```\n\n```java\nSolution.buildTrie().toString() == \"{}\";\nSolution.buildTrie(\"\").toString() == \"{}\";\nSolution.buildTrie(\"trie\").toString() == \"{t={tr={tri={trie=null}}}}\";\nSolution.buildTrie(\"tree\").toString() == \"{t={tr={tre={tree=null}}}}\";\nSolution.buildTrie(\"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", \"inn\").toString() == \"{A=null, t={te={tea=null, ted=null, ten=null}, to=null}, i={in={inn=null}}}\";\nSolution.buildTrie(\"true\", \"trust\").toString() == \"{t={tr={tru={true=null, trus={trust=null}}}}}\";\n```\n\nHappy coding! :)",
  "totalAttempts": 4012,
  "totalCompleted": 545,
  "totalStars": 64,
  "voteScore": 126,
  "tags": [
    "Data Structures",
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}