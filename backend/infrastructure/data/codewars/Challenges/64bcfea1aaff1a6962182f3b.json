{
  "id": "64bcfea1aaff1a6962182f3b",
  "name": "Calculate Available Time (overlaps are possible)",
  "slug": "calculate-available-time-overlaps-are-possible",
  "category": "reference",
  "publishedAt": "2023-07-23T11:06:26.956Z",
  "approvedAt": "2024-02-22T09:56:57.853Z",
  "languages": [
    "sql"
  ],
  "url": "https://www.codewars.com/kata/64bcfea1aaff1a6962182f3b",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2023-07-23T10:19:13.802Z",
  "createdBy": {
    "username": "bornForThis",
    "url": "https://www.codewars.com/users/bornForThis"
  },
  "approvedBy": {
    "username": "dfhwze",
    "url": "https://www.codewars.com/users/dfhwze"
  },
  "description": "In the online tutoring platform, tutors set their availability by specifying a start and end time for each slot. These slots, spanning from 1970 to 2999, can overlap. Your task is to write a performant PostgreSQL query that calculates the total availability time for a specific tutor (e.g., user_id= 777) over their entire record. The query should efficiently handle a large dataset, merging overlapping intervals to compute the total distinct availability in minutes.\n\nThe `availability` table in your PostgreSQL database has the following schema:\n\n* `id` (integer) - The unique identifier for each availability entry.\n* `user_id` (integer) - The unique identifier for the user (tutor).\n* `avail_start` (timestamp) - The start time of the availability slot.\n* `avail_end` (timestamp) - The end time of the availability slot.\n\nWrite a PostgreSQL query that calculates the total availability time for the user with `user_id`= 777. The total availability time should be the sum of the durations of all distinct (non-overlapping) availability slots. The result should be given in minutes as a column `total_minutes` of integer type. The overlapping intervals should be merged. For example, if there is one interval from 16:00 to 17:00 and another from 16:30 to 17:30, the total availability should be considered as 90 minutes, not 120.\n\nLet's provide a concrete example:\n\n```\n| id | user_id | avail_start         | avail_end           |\n+----+---------+---------------------+---------------------+\n| 1  | 777     | 2023-07-24 16:00:00 | 2023-07-24 17:00:00 |\n| 2  | 777     | 2023-07-24 16:00:00 | 2023-07-24 16:50:00 |\n| 3  | 777     | 2023-07-24 18:00:00 | 2023-07-24 18:30:00 |\n| 4  | 777     | 2023-07-24 17:30:00 | 2023-07-24 18:10:00 |\n| 5  | 777     | 2023-07-24 16:00:00 | 2023-07-24 17:10:00 |\n| 6  | 777     | 2023-07-24 16:00:00 | 2023-07-24 16:50:00 |\n```\n\nThe result should be:\n\n```\n| total_minutes |\n+---------------+\n| 130           |\n```\n\nHere is the breakdown:\n\n* '2023-07-24 16:00' to '2023-07-24 17:00' (id=1) contributes 60 minutes.\n* '2023-07-24 16:00' to '2023-07-24 16:50' (id=2) falls within id=1, so it contributes 0 minutes.\n* '2023-07-24 18:00' to '2023-07-24 18:30' (id=3) is a completely distinct interval, so it contributes 30 minutes.\n* '2023-07-24 17:30' to '2023-07-24 18:10' (id=4) overlaps 10 minutes with id=3 (18:00 to 18:10), so the unique time contribution of this interval is from 17:30 to 18:00, which is 30 minutes.\n* '2023-07-24 16:00' to '2023-07-24 17:10' (id=5) overlaps completely with id=1 but extends 10 minutes beyond it, so it contributes 10 minutes.\n* '2023-07-24 16:00' to '2023-07-24 16:50' (id=6) falls within id=1, so it contributes 0 minutes.\n\nAdding these up: 60 + 0 + 30 + 30 + 10 + 0 equals 130 minutes.\n\nGLHF!\n\nNotes:\n\n* It is ensured that the start time is always before the end time\n* It is possible that slots start in one day and end in another",
  "totalAttempts": 1034,
  "totalCompleted": 72,
  "totalStars": 9,
  "voteScore": 30,
  "tags": [
    "SQL",
    "Databases"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}