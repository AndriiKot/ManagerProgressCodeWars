{
  "id": "5b3e3ca99c9a75a62400016d",
  "name": "Mid-Endian numbers",
  "slug": "mid-endian-numbers",
  "category": "algorithms",
  "publishedAt": "2018-07-06T14:07:29.970Z",
  "approvedAt": "2018-07-13T11:38:22.109Z",
  "languages": [
    "javascript",
    "python",
    "ruby",
    "crystal",
    "cpp",
    "csharp"
  ],
  "url": "https://www.codewars.com/kata/5b3e3ca99c9a75a62400016d",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2018-07-05T15:43:38.131Z",
  "createdBy": {
    "username": "GiacomoSorbi",
    "url": "https://www.codewars.com/users/GiacomoSorbi"
  },
  "approvedBy": {
    "username": "lechevalier",
    "url": "https://www.codewars.com/users/lechevalier"
  },
  "description": "While most devs know about [big/little-endianness](https://en.wikipedia.org/wiki/Endianness), only a selected few know the secret of real hard core coolness with mid-endians.\n\nYour task is to take a number and return it in its mid-endian format, putting the most significant couple of bytes in the middle and all the others around it, alternating left and right.\n\nFor example, consider the number `9999999`, whose hexadecimal representation would be `98967F` in big endian (the classic you get converting); it becomes `7F9698` in little-endian and `96987F` in mid-endian.\n\nWrite a function to do that given a positive integer (in base 10) and remembering that you need to pad with `0`s when you get a single hex digit!",
  "totalAttempts": 910,
  "totalCompleted": 201,
  "totalStars": 16,
  "voteScore": 68,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 1
  }
}