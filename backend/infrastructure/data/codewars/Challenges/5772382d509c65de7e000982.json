{
  "id": "5772382d509c65de7e000982",
  "name": "Fibo akin",
  "slug": "fibo-akin",
  "category": "reference",
  "publishedAt": "2016-06-28T08:41:26.879Z",
  "approvedAt": "2016-12-12T06:40:53.868Z",
  "languages": [
    "ruby",
    "python",
    "java",
    "csharp",
    "elixir",
    "clojure",
    "javascript",
    "coffeescript",
    "typescript",
    "haskell",
    "cpp",
    "php",
    "fsharp",
    "c",
    "crystal",
    "ocaml",
    "rust",
    "swift",
    "go",
    "r",
    "shell",
    "kotlin",
    "fortran",
    "groovy",
    "julia",
    "scala",
    "powershell",
    "nim",
    "reason",
    "lua",
    "pascal",
    "perl",
    "cobol",
    "d",
    "erlang"
  ],
  "url": "https://www.codewars.com/kata/5772382d509c65de7e000982",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-06-28T08:41:17.777Z",
  "createdBy": {
    "username": "g964",
    "url": "https://www.codewars.com/users/g964"
  },
  "approvedBy": {
    "username": "narayanswa30663",
    "url": "https://www.codewars.com/users/narayanswa30663"
  },
  "description": "Be u(n) a sequence beginning with:\n```\nu[1]  = 1,  u[2]  = 1,  u[3]  = 2,  u[4]  = 3,  u[5]  = 3,  u[6] = 4,\n\nu[7]  = 5,  u[8]  = 5,  u[9]  = 6,  u[10] = 6,  u[11] = 6,  u[12] = 8,\n\nu[13] = 8,  u[14] = 8,  u[15] = 10, u[16] = 9,  u[17] = 10, u[18] = 11,\n\nu[19] = 11, u[20] = 12, u[21] = 12, u[22] = 12, u[23] = 12 etc...\n\n```\n- How is`u[8]` calculated?\n\nWe have `u[7] = 5` and `u[6] = 4`. These numbers tell us that we have to go backwards from index `8` to index `8 - 5 = 3` and to index `8 - 4 = 4` so to index `3` and `4`.\n\n``` u[3] = 2``` and ```u[4] = 3```  hence ```u[8] = u[3] + u[4] = 2 + 3 = 5```.\n\n- Another example: let us calculate `u[13]`. At indexes `12` and `11` we have `8` and `6`. Going backwards of `8` and `6` from `13` we get indexes `13 - 8 = 5` and `13 - 6 = 7`. \n\n``` u[5] = 3```  and ``` u[7] = 5```  so ``` u[13] = u[5] + u[7] = 3 + 5 = 8``` .\n\n#### Task\n- 0) Express u(n) as a function of n, u[n - 1], u[n - 2]. (not tested).\n\n\n- 1) Given two numbers `n, k (integers > 2)` write the function `length_sup_u_k(n, k) or lengthSupUK or length-sup-u-k` returning the number of terms `u[i] >= k` with `1 <= i <= n`. \nIf we look above we can see that between `u[1]` and `u[23]` we have four `u[i]` greater or equal to `12`: `length_sup_u_k(23, 12) => 4`\n\n\n- 2) Given `n (integer > 2)` write the function `comp(n)` (`cmp` in COBOL) returning the number of times where a term of `u` is less than its **predecessor** up to and including u[n]. \n\n#### Examples:\n\n```\nu(900) => 455 (not tested)\nu(90000) => 44337 (not tested)\n\nlength_sup_u_k(23, 12) => 4\nlength_sup_u_k(50, 10) => 35\nlength_sup_u_k(500, 100) => 304\n\ncomp(23) => 1 (since only u(16) < u(15))\ncomp(100) => 22\ncomp(200) => 63\n```\n\n#### Note: Shell\nShell tests only `lengthSupUk`",
  "totalAttempts": 5480,
  "totalCompleted": 2031,
  "totalStars": 179,
  "voteScore": 270,
  "tags": [
    "Algorithms",
    "Recursion"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 4,
    "suggestions": 3
  }
}