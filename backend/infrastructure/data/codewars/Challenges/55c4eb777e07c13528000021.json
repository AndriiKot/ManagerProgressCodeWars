{
  "id": "55c4eb777e07c13528000021",
  "name": "Factorial tail",
  "slug": "factorial-tail",
  "category": "algorithms",
  "publishedAt": "2015-08-09T03:53:24.278Z",
  "approvedAt": "2016-01-16T00:02:37.170Z",
  "languages": [
    "javascript",
    "haskell",
    "python",
    "ruby",
    "cpp",
    "c",
    "csharp",
    "php",
    "objc",
    "coffeescript",
    "typescript",
    "rust",
    "d",
    "go",
    "factor",
    "java"
  ],
  "url": "https://www.codewars.com/kata/55c4eb777e07c13528000021",
  "rank": {
    "id": -4,
    "name": "4 kyu",
    "color": "blue"
  },
  "createdAt": "2015-08-07T17:31:35.974Z",
  "createdBy": {
    "username": "kirilloid",
    "url": "https://www.codewars.com/users/kirilloid"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "### The problem\n\nHow many zeroes are at the **end** of the [factorial](https://en.wikipedia.org/wiki/Factorial) of `10`? 10! = 36288<u>00</u>, i.e. there are `2` zeroes.\n16! (or 0x10!) in [hexadecimal](https://en.wikipedia.org/wiki/Hexadecimal) would be 0x130777758<u>000</u>, which has `3` zeroes.\n\n### Scalability\n\nUnfortunately, machine integer numbers has not enough precision for larger values. Floating point numbers drop the tail we need. We can fall back to arbitrary-precision ones - built-ins or from a library, but calculating the full product isn't an efficient way to find just the _tail_ of a factorial. Calculating `100'000!` in compiled language takes around 10 seconds. `1'000'000!` would be around 10 minutes, even using efficient [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm)\n\n### Your task\n\nis to write a function, which will find the number of zeroes at the end of `(number)` factorial in arbitrary [radix](https://en.wikipedia.org/wiki/Radix) = `base` for larger numbers.\n\n- `base` is an integer from 2 to 256\n- `number` is an integer from 1 to 1'000'000\n\n<u>**Note**</u> Second argument: number is always declared, passed and displayed as a regular _decimal_ number. If you see a test described as `42! in base 20` it's 42<sub>10</sub> **not** 42<sub>20</sub> = 82<sub>10</sub>.\n",
  "totalAttempts": 37908,
  "totalCompleted": 3339,
  "totalStars": 592,
  "voteScore": 508,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 3
  }
}