{
  "id": "54ce6115975ca685dd0005d5",
  "name": "Move-To-Front Encoding",
  "slug": "move-to-front-encoding",
  "category": "algorithms",
  "publishedAt": "2015-02-01T17:31:19.146Z",
  "approvedAt": "2017-03-13T00:53:28.549Z",
  "languages": [
    "haskell",
    "javascript"
  ],
  "url": "https://www.codewars.com/kata/54ce6115975ca685dd0005d5",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2015-02-01T17:23:33.830Z",
  "createdBy": {
    "username": "muesli4",
    "url": "https://www.codewars.com/users/muesli4"
  },
  "approvedBy": {
    "username": "kazk",
    "url": "https://www.codewars.com/users/kazk"
  },
  "description": "Motivation\n---------\nThe goal of data compression is to remove redundancy from an input. Some of you already know run-length-encoding, where elements get encoded with their number of consecutive occurences. But what if elements are not directly consecutive but just close to each other?\n\n(This is especially important for the Burrows-Wheeler-Transformation, which creates a permutation of the input, where equal symbols are close to each other. There is also a [kata](http://www.codewars.com/kata/burrows-wheeler-transformation/) about that from me.)\n\nMove To Front Encoding\n--------------------\nIn this encoding we use a prioritized and changing alphabet for our input. As the name suggests, when encoding a symbol from our alphabet, we look up the index of that symbol in our alphabet. This is our representation for that symbol, and then change the alphabet, by moving the symbol to the front. Example with the alphabet `['a', 'b', 'c']`:\n```haskell\nencode \"abc\" \"ccc\"    == Just [2, 0, 0]\nencode \"abc\" \"acacac\" == Just [0, 2, 1, 1, 1, 1]\nencode \"aab\" \"b\"      == Just [2]\n```\n```javascript\nencode(\"abc\", \"ccc\")    === [2, 0, 0]\nencode(\"abc\", \"acacac\") === [0, 2, 1, 1, 1, 1]\nencode(\"aab\", \"b\")      === [2]\n```\nAs you can see the numbers get smaller the more often symbols occur in proximity, and smaller numbers can be represented in less space.\n\nDecoding works in the exact same direction, just that we look up the index in the alphabet, instead of the actual element.\n\nGoal\n----\nWrite `encode` and `decode` for the Move-To-Front-Encoding.\n```if:haskell\nNote: Both can fail, and alphabets can be infinite in size!\n```\n```if:javascript\nReturn `null` if encoding or decoding fails.  \nAlso note alphabets can have repeating characters, and can be quite large.  \nThe alphabet may be an Array of Numbers or a String; `encode`'s second argument will be this same type, and `decode`'s return value must be this same type.  \nInputs must not be modified.\n```",
  "totalAttempts": 2706,
  "totalCompleted": 195,
  "totalStars": 43,
  "voteScore": 68,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 2
  }
}