{
  "id": "6152be7b9aa70a0033906a18",
  "name": "Simple Hash",
  "slug": "simple-hash",
  "category": "algorithms",
  "publishedAt": "2021-09-28T16:53:52.266Z",
  "approvedAt": "2021-12-06T17:42:31.871Z",
  "languages": [
    "javascript"
  ],
  "url": "https://www.codewars.com/kata/6152be7b9aa70a0033906a18",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2021-09-28T07:04:27.498Z",
  "createdBy": {
    "username": "lpabst",
    "url": "https://www.codewars.com/users/lpabst"
  },
  "approvedBy": {
    "username": "JohanWiltink",
    "url": "https://www.codewars.com/users/JohanWiltink"
  },
  "description": "# Quick and Dirty Explanation:\nIf you don't want to read the entire novel below, here is a quick explanation of what we're trying to accomplish. Write the function simpleHash(word, salt, iterations) {...} so that the passed in word gets salted, and then hashed x number of times, where x = iterations.\n\nThe salt should be added to the word by alternating each letter of the word, then the salt, in the order: `word[0] + salt[0] + word[1] + salt[1] + etc` until all letters of both the word and the salt have been used. If the word is longer than the salt, then once the salt runs out of letters, just continue adding letters from the word, and vice versa if the salt is longer. The salt should only be added to the original word on the first iteration, subsequent iterations should just hash the hash from the previous iteration without salting them again\n    \nHashing is done by summing the ASCII character codes (decimal) to get a new character code. If the sum is larger than the range of printable character codes (32-127), then wrap back around until you find a valid character code. For example, a sum of 128 would use characterCode 32, which gives us the character \" \" and a sum of 129 would use characterCode of 33 which gives us the character \"!\", etc. \n* So hash[i] will be the character equal to the characterCode of the sum of wordSaltCombo[i] + wordSaltCombo[i+1]. \n* The last character of wordSaltCombo will be summed with the first character to get the last character of the hash. See the detailed explanation and/or the full example below for clarification if needed\n    \nOnce all iterations of the hash have been performed, base64Encode the final hash and return that value\n\nNOTES:\n- All test inputs will be valid: `word` will be a valid string with length > 1, `salt` will be a valid string with length > 1, `iterations` will be a valid integer > 0\n\n*** ***\n\n# General Info:\n## What is a hash?\nA hash is a one way encryption technique that gives us a unique output for different words. But how can an algorithm only be one way? How can you encrypt something without being able to decrypt it back if you know the algorithm? Real-life, cryptographically secure hash algorithms are incredibly complex, at least more complex than I care to read about, so this is a simple version that illustrates how you can perform a one way encryption that can't be decrypted!\n\n## What is a salt?\nA salt is a random string that is added to the word you want to hash before you begin hashing it. This randomizes things so that the original word doesn't always hash to the same string. If it did, it makes it too easy for hackers to learn what a word hashes to, which ruins the purpose of hashing. Using a salt randomizes things a bit! Hashing the word 'password' with 2 different salts will give you 2 different outcomes.\n\n*** ***\n\n# Instructions for this kata\n### Using character codes to hash a string\nEach printable character on the keyboared has an ASCII character code. In decimal format, the character codes for printable characters range from 32-127. https://www.ascii-code.com/ gives an example of a table that lists the character codes for those characters. Imagine taking any 2 characters and adding their character codes together to get a new number. \n* For instance, Uppercase A (65) and lowercase t (116) when added together equals 181 if my math is correct (and it always is. movie reference anyone?). Now if we can use that number 181 to generate a new character, that is irreversible, or undecryptable, in the sense that those are not the only 2 characters that could be summed to equal 181. Uppercase B (66) and lowercase s (115) also sum to 181. Uppercase C (67) and lowercase r (114) do as well, etc. \n\nSo with our new character, we don't know what original 2 characters were used to give us this new character.\n\nHow do we generate a new character from 181? Well, imagine that the prinatable character codes are arranged in a circle so that after you pass 127 you come back around to 32, 33, 34, etc. so 181 would be 54 characters past 127 (181 - 127 = 54), so starting back at 32, we would count out 54 characters and end up at the characterCode 85, which is an Uppercase \"U\" \n\n## How to implement the salt\nFor this kata, adding the salt to the original word will be done by alternating every other letter of the word, then the salt, in the format `word[0]+salt[0]+word[1]+salt[1]+etc`. The salt will only be added to the original word before hashing begins, and will not be added to previous hashes during subsequent iterations. For example: \n* for simpleHash('word', 'salt') the combination would be 'wsoarldt' \n* for simpleHash('hello world', 'salty') the combination would be 'hseallltoy world'\n* for simpleHash('hi', 'j3ue89s') the combination would be 'hji3ue89s'. \n\n## Number of iterations\nIn this kata, the number of iterations will indicate how many times you should run the word through the hash algorithm. So iterations 1 would mean you hash the word+salt combination one time. Iterations 2 would mean that you hash the word+salt combination, then hash that hash.. This continues until iterationsPerformed is equal to iterationsRequested. \n* hash1 = hash(word+salt), hash2 = hash(hash1), hash3 = hash(hash2), etc\n\n## The hashing algorithm\nThe hashing algorithm itself will build on the principle we discussed above. We will sum up the character codes of char0 & char1 of the word+salt combo, and that will give us the character code for char0 for the hash. Sum up char1 & char2 and we get char1 for the hash. **The very last character of the word+salt combo will be summed with the first character of the word+salt combo to give us the last character of the hash.** On your second iteration, you would sum up char0 & char1 of hash1 to get char0 for hash2 \n* see examples below for additional clarification if needed. \n\n## Base64 encode the final hash\nThe final thing we want to do is base64 encode the result of our final hash. So if iterations === 3, we would return base64Encode(hash3). This just makes the result look pretty and avoids any funky characters to make it nice to store in a DB or pass in a network call, etc\n\n*** ***\n\n## A Full Example:\n    1. simpleHash('hi', 'salt', 1)\n        - we would have a word+salt combo of hsialt\n        - character codes for those chars would be: 104 115 105 97 108 116\n            - char0 of the hash would be 104+115 = 219 (charCode 123) = character `{`\n            - char1 would be 115+105 = 220 (charCode 124) = `|`\n            - char2 would be 105+97 = 202 (charCode 106) = `j`\n            - char3 would be 97+108 = 205 (charCode 109) = `m`\n            - char4 would be 108+116 = 224 (charCode 32) = ` ` \n              *note that we wrapped around the ASCII code 'circle' twice here\n            - char5 would be 116+104 = 220 (charCode 124) = `|` \n              *note1: we summed the last charCode 116 and first charCode 104\n              *note2: we ended up with the same `|` hash character twice in this hash even though the original letters were different in  both cases!\n            - all of this gives us a hash of: {|jm |\n        - base64Encode \"{|jm |\" for the final result of e3xqbSB8\n        \n## Other Examples (with less detailed explanation):\n    1. simpleHash('hi','salt', 2)\n        - we would have a word+salt combo of hsialt\n        - character codes would be: 104 115 105 97 108 116\n        - hash1 = {|jm |\n        - hash1 would get hashed again, character codes would be: 123 124 106 109 32 124\n        - hash2 = 7&w-<7\n        - return base64Encode(\"7&w-<7\") which gives us the expected result: NyZ3LTw3\n    2. simpleHash('hello world', 'some-long-salt-for-awesome-randomization', 1)\n        - word+salt combo = `hseolmleo- lwoonrgl-dsalt-for-awesome-randomization`\n        - charCodes = 104 115 101 111 108 109 108 101 111 45 32 108 119 111 111 110 114 103 108 45 100 115 97 108 116 45 102 111 114 45 97 119 101 115 111 109 101 45 114 97 110 100 111 109 105 122 97 116 105 111 110\n        - hash1 = {xt{yyqt<M,#&~} ys91wtm A3u!?.x|x\"|r2?sors|v#{u}x}v\n        - base64Encode that for a final result of e3h0e3l5cXQ8TSwjJn59IHlzOTF3dG0gQTN1IT8ueHx4InxyMj9zb3JzfHYje3V9eH12\n    3. simpleHash('myPassword-12$$', 'Azh1qYBqIio73UfLj1z2YLuxiWObWzVa', 10)\n        - word+salt combo = mAyzPha1sqsYwBoqrIdi-o1723$U$fLj1z2YLuxiWObWzVa\n        - hash1 = NZ3jXi2D$$lpYQ #[Mm6<@hieWyy*RV;KL+Ea-!`FQYqpWn\n        - hash2 = H-=ba;vhH0|iJqC~HZCr|Hqn\\p2C|H1&7wpF.N!F7Jj!ge\\\n        - hash3 = uj?c<Q~PxL%S[TafB=U.dYjlBu_dyW]N'Vt|og}!T+(laD\n        - hash4 = IB?-onhdqxNOUgH2#2]x)vNWtc}pTKu}j0+v$>uS4mEY\n        - hash5 = h+!l<}vlu)f=D\\OgQUU/uA?dEkw -d?`2':[A:bS4r'AR>x\n        - hash6 = 3L-HY3\"!>/C!@KVXFJ$DV CIP\"7M1C?2Ya5<{<U'F9h30V\n        - hash7 = yuA,UC_mrda+AN>0nh:vc,9rY$~t\"q+Z6qWW1|mA;c&vS\n        - hash8 = 8.Vm!8Blve,l/,n>vBPy/eKk}B263<%0GhN(M),`|>)<ir\n        - hash9 = f$c.YzN+5{18;[:LTX2iH4PV(_thioaUwOVvuvU,|ZgeE{J\n        - hash10 = *'1'shy`PLis65&@L*;Q|$F~'s|qxpVlfEl++k!HvalJ`eP\n        - final result = KicxJ3NoeWBQTGlzNjUmQEwqO1F8JEZ+J3N8cXhwVmxmRWwrK2shSHZhbEpgZVA=",
  "totalAttempts": 229,
  "totalCompleted": 54,
  "totalStars": 12,
  "voteScore": 30,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 1
  }
}