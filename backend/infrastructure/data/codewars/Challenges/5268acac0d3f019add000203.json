{
  "id": "5268acac0d3f019add000203",
  "name": "Design a Simple Automaton (Finite State Machine)",
  "slug": "design-a-simple-automaton-finite-state-machine",
  "category": "algorithms",
  "publishedAt": "2013-10-25T21:43:39.733Z",
  "approvedAt": "2014-02-17T02:06:30.255Z",
  "languages": [
    "javascript",
    "python",
    "coffeescript",
    "cpp",
    "c",
    "nasm",
    "ruby",
    "haskell",
    "prolog"
  ],
  "url": "https://www.codewars.com/kata/5268acac0d3f019add000203",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2013-10-24T05:14:20.190Z",
  "createdBy": {
    "username": "Ban-Ath",
    "url": "https://www.codewars.com/users/Ban-Ath"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Create a finite automaton that has three states. Finite automatons are the same as finite state machines for our purposes.\n\nOur simple automaton, accepts the language of `A`, defined as `{0, 1}` and should have three states: `q1`, `q2`, and `q3`. Here is the description of the states:\n\n* `q1` is our start state, we begin reading commands from here\n* `q2` is our accept state, we return `true` if this is our last state\n\nAnd the transitions:\n\n* `q1` moves to `q2` when given a `1`, and stays at `q1` when given a `0`\n* `q2` moves to `q3` when given a `0`, and stays at `q2` when given a `1`  \n* `q3` moves to `q2` when given a `0` or `1`\n\nThe automaton should return whether we end in our accepted state (`q2`), or not (`true`/`false`).\n\n\n## Your task\n\nYou will have to design your state objects, and how your Automaton handles transitions. Also make sure you set up the three states, `q1`, `q2`, and `q3` for the myAutomaton instance. The test fixtures will be calling against myAutomaton.\n\nAs an aside, the automaton accepts an array of strings, rather than just numbers, or a number represented as a string, because the language an automaton can accept isn't confined to just numbers. An automaton should be able to accept any 'symbol.'\n\nHere are some resources on DFAs (the automaton this Kata asks you to create):\n\n* http://en.wikipedia.org/wiki/Deterministic_finite_automaton  \n* http://www.cs.odu.edu/~toida/nerzic/390teched/regular/fa/dfa-definitions.html  \n* http://www.cse.chalmers.se/~coquand/AUTOMATA/o2.pdf  \n\n\n## Example\n\n\n```javascript\nvar a = new Automaton();\na.readCommands([\"1\", \"0\", \"0\", \"1\", \"0\"]);  ==> false\n```\n```python\na = Automaton()\na.read_commands([\"1\", \"0\", \"0\", \"1\", \"0\"])  ==> False\n```\n```ruby\na = Automaton.new\na.read_commands([\"1\", \"0\", \"0\", \"1\", \"0\"])  ==> false\n```\n```coffeescript\na = new Automaton()\na.readCommands [\"1\", \"0\", \"0\", \"1\", \"0\"]  ==> false\n```\n```c++\na = Automaton()\na.read_commands({'1', '0', '0', '1', '0'});   ==> false\n```\n```c\nread_commands(\"10010\");  ==> false\n```\n```haskell\nreadCommands \"10010\" --> False\n```\n\n\n\nWe make these transitions:\n```\ninput: [\"1\", \"0\", \"0\", \"1\", \"0\"]\n\n1: q1 -> q2\n0: q2 -> q3\n0: q3 -> q2\n1: q2 -> q2\n0: q2 -> q3\n```\n\nWe end in `q3` which is **not** our accept state, so we return `false`\n\n",
  "totalAttempts": 27924,
  "totalCompleted": 6385,
  "totalStars": 482,
  "voteScore": 568,
  "tags": [
    "State Machines",
    "Artificial Intelligence",
    "Algorithms",
    "Object-oriented Programming"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 4,
    "suggestions": 5
  }
}