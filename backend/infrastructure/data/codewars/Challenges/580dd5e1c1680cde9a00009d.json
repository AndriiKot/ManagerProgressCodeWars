{
  "id": "580dd5e1c1680cde9a00009d",
  "name": "Arrays and Procs #1",
  "slug": "arrays-and-procs-number-1",
  "category": "reference",
  "publishedAt": "2016-10-24T10:36:13.789Z",
  "approvedAt": "2017-11-03T07:50:26.658Z",
  "languages": [
    "ruby"
  ],
  "url": "https://www.codewars.com/kata/580dd5e1c1680cde9a00009d",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-10-24T09:35:29.139Z",
  "createdBy": {
    "username": "narayanswa30663",
    "url": "https://www.codewars.com/users/narayanswa30663"
  },
  "approvedBy": {
    "username": "smile67",
    "url": "https://www.codewars.com/users/smile67"
  },
  "description": "Functions like the one below can be invoked on values as shown:\n```ruby\ndef func(a)\n  a + a\nend\n\nfunc(1) #=> 2\nfunc(“str”) #=> “strstr”\nfunc(21) #=> 42\n```\nProcs like the one below have a slightly different syntax. For more on that syntax, see the [Ruby Proc docs](https://ruby-doc.org/core-2.3.0/Proc.html). \n```ruby\nfunc = proc { | a | a + a }\nfunc.call(1) #=> 2\n```\n\n#### Task:\nYour job here is to implement a function (named `array_procs`) that will take an array, `arr`, and a variable number of procs, `procs`, and apply each proc, in order, to every single element in the array `arr`. Up to nine procs may be inputted. Your function should not modify the input array. Note that `Proc#call` is **_disabled_**, so neither of the following will work:\n\n```ruby\nx = proc { | i | i + 2 }\nx.(2)\nx.call(2)\n```\n\n#### How the function will be called:\n```ruby\narray_procs(an_array, any_number_of_procs1, any_number_of_procs2,...)\n```\n\n#### Some examples:\n```ruby\narr = [1, 2, 4, 6]\nproc1 = proc { | i | i * 2 }\t\nproc2 = proc { | i | i + 1 }\narray_procs(arr, proc1, proc2) #=> \n  [(1 * 2) + 1, (2 * 2) + 1, (4 * 2) + 1, (6 * 2) + 1]\n  [          3,           5,           9,          13]\narray_procs(arr, proc2, proc1) #=> \n  [(1 + 1) * 2, (2 + 1) * 2, (4 + 1) * 2, (6 + 1) * 2]\n  [          4,           6,          10,          14]\narray_procs(arr, proc2) #=> \n  [(1 + 1), (2 + 1), (4 + 1), (6 + 1)]\n  [      2,       3,       5,       7]\narray_procs(arr) #=> \n  [1, 2, 4, 6] since there are no procs to apply on the elements\n```\n\nAlso, whenever one of the tests fails, the procs applied will be printed to the console. This is because it is difficult to print the source code for procs, and so the string values of the failed inputs would help.\n\nAll input procs will take only one argument, but some procs may take an argument and not use it (for example, `proc { | i | 0 + 2 + 22 }` is valid, and should change every value in the array to 24). There will also be no need to ensure that the first argument is an array or that the rest of the arguments are proc functions. And again, `Proc#call` is disabled.\n\nIf you see issues or have any suggestions/ideas at all, please don't hesitate to comment. Otherwise, please rank and mark as ready!\n\n### When you're done here, try the next kata in the series:\n[Arrays and Procs #2](https://www.codewars.com/kata/arrays-and-procs-number-2)\n\n### Also check out my other creations:\n[Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose) \n\n[Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose)",
  "totalAttempts": 295,
  "totalCompleted": 94,
  "totalStars": 5,
  "voteScore": 32,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}