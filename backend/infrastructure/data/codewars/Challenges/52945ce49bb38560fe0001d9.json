{
  "id": "52945ce49bb38560fe0001d9",
  "name": "Pascal's Triangle #2",
  "slug": "pascals-triangle-number-2",
  "category": "algorithms",
  "publishedAt": "2013-11-26T08:37:22.665Z",
  "approvedAt": "2014-01-10T01:36:10.881Z",
  "languages": [
    "javascript",
    "ruby",
    "python",
    "java",
    "clojure",
    "scala",
    "csharp",
    "haskell",
    "lambdacalc",
    "julia"
  ],
  "url": "https://www.codewars.com/kata/52945ce49bb38560fe0001d9",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2013-11-26T08:33:40.202Z",
  "createdBy": {
    "username": "Jeroko",
    "url": "https://www.codewars.com/users/Jeroko"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Here you will create the classic [Pascal's triangle](https://en.wikipedia.org/wiki/Pascal%27s_triangle).  \nYour function will be passed the depth of the triangle and your code has to return the corresponding Pascal's triangle up to that depth.\n\nThe triangle should be returned as a nested array. For example:\n\n    pascal(5) -> [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ]\n\nTo build the triangle, start with a single `1` at the top, for each number in the next row you just take the two numbers above it and add them together, except for the edges, which are all `1`. e.g.:\n\n          1\n        1   1\n      1   2   1\n    1   3   3   1\n\n~~~if:lambdacalc\n### Encodings\n\n`purity: LetRec`  \n`numEncoding: BinaryScott`  \nexport `foldr` for your `List` encoding\n\n### Performance\n\n`20` tests with inputs up to `40`\n~~~",
  "totalAttempts": 18549,
  "totalCompleted": 5893,
  "totalStars": 223,
  "voteScore": 567,
  "tags": [
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 1
  }
}