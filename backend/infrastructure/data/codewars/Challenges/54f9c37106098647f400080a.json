{
  "id": "54f9c37106098647f400080a",
  "name": "The dropWhile Function",
  "slug": "the-dropwhile-function",
  "category": "algorithms",
  "publishedAt": "2015-03-06T15:31:01.181Z",
  "approvedAt": "2015-03-19T05:11:35.201Z",
  "languages": [
    "javascript",
    "haskell",
    "coffeescript",
    "cpp",
    "csharp",
    "python",
    "c",
    "ruby",
    "lambdacalc",
    "ocaml",
    "factor",
    "lua"
  ],
  "url": "https://www.codewars.com/kata/54f9c37106098647f400080a",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2015-03-06T15:10:41.712Z",
  "createdBy": {
    "username": "jgdodson",
    "url": "https://www.codewars.com/users/jgdodson"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Yet another staple for the functional programmer. You have a sequence of values and some predicate for those values. You want to remove the longest prefix of elements such that the predicate is true for each element. We'll call this the dropWhile function. It accepts two arguments. The first is the sequence of values, and the second is the predicate function. The function does not change the value of the original sequence. \n\n```python\ndef isEven(num):\n  return num % 2 == 0\n\narr = [2,4,6,8,1,2,5,4,3,2]\n\ndropWhile(arr, isEven) == [1,2,5,4,3,2] # True\n```\n```javascript\nfunction isEven(num) {\n  return num % 2 === 0;\n}\nvar seq = [2,4,6,8,1,2,5,4,3,2];\n\ndropWhile(seq, isEven) // -> [1,2,5,4,3,2]\n```\n```haskell\ndropWhile [2,4,6,8,1,2,5,4,3,2] even -- -> [1,2,5,4,3,2]\n```\n```cpp\nauto isEven = [](int value) -> bool { return abs(value) % 2 == 0; };\n\ndropWhile({ 2, 4, 6, 8, 1, 2, 5, 4, 3, 2 }, isEven) // -> { 1, 2, 5, 4, 3, 2 }\n```\n```csharp\nFunc<int, bool> isEven = (value) => value % 2 == 0;\n\ndropWhile(new int[] { 2, 4, 6, 8, 1, 2, 5, 4, 3, 2 }, isEven) // -> { 1, 2, 5, 4, 3, 2 }\n```\n```lambdacalc\ndrop-while [2,4,6,8,1,2,5,4,3,2] even  -->  [1,2,5,4,3,2]\n```\n```lua\nlocal function is_even(x)\n  return x%2==0\nend\n\ndrop_while({2,4,6,8,1,2,5,4,3,2}, is_even)  -->  [1,2,5,4,3,2]\n```\n```ocaml\nlet is_even n = n mod 2 = 0 in\ndrop_while [2; 4; 6; 8; 1; 2; 5; 4; 3; 2] is_even\n  (* -> [1; 2; 5; 4; 3; 2] *)\n```\n```c\nbool isEven (int n) { return (n % 2) == 0; }\nsize_t count;\nint *result = dropWhile((int[]) {2, 4, 5, 7, 8, 10 }, 6, isEven, &count);\n// result = { 5, 7, 8, 10 }; count = 4\n```\n\nYour task is to implement the dropWhile function. If you've got a [span function](http://www.codewars.com/kata/the-span-function) lying around, this is a one-liner! Alternatively, if you have a [takeWhile function](http://www.codewars.com/kata/the-takewhile-function) on your hands, then combined with the dropWhile function, you can implement the span function in one line. This is the beauty of functional programming: there are a whole host of useful functions, many of which can be implemented in terms of each other.\n\n~~~if:lambdacalc\n### Encodings\n\npurity: `LetRec`  \nnumEncoding: `BinaryScott`  \nexport constructors `nil, cons` and deconstructor `foldl` for your `List` encoding  \nexport constructors `False, True` for your `Boolean` encoding  \n~~~",
  "totalAttempts": 11758,
  "totalCompleted": 3532,
  "totalStars": 86,
  "voteScore": 421,
  "tags": [
    "Functional Programming",
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}