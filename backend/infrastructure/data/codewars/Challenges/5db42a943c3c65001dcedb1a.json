{
  "id": "5db42a943c3c65001dcedb1a",
  "name": "LZ78 compression",
  "slug": "lz78-compression",
  "category": "algorithms",
  "publishedAt": "2019-10-26T15:02:48.824Z",
  "approvedAt": "2019-10-26T20:00:02.519Z",
  "languages": [
    "python",
    "ruby",
    "javascript",
    "cpp",
    "java"
  ],
  "url": "https://www.codewars.com/kata/5db42a943c3c65001dcedb1a",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2019-10-26T11:14:28.354Z",
  "createdBy": {
    "username": "Avanta",
    "url": "https://www.codewars.com/users/Avanta"
  },
  "approvedBy": {
    "username": "Blind4Basics",
    "url": "https://www.codewars.com/users/Blind4Basics"
  },
  "description": "In this kata, you need to make a (simplified) LZ78 encoder and decoder.\n[LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ78) is a dictionary-based compression method created in 1978. You will find a  detailed explanation about how it works below.\n\nThe input parameter will always be a non-empty string of upper case alphabetical characters. The maximum decoded string length is 1000 characters.\n\n\n# Instructions\n\n*If anyone has any ideas on how to make the instructions shorter / clearer, that would be greatly appreciated.*\n\nIf the below explanation is too confusing, just leave a comment and I'll be happy to help.\n\n---\n\nThe input is looked at letter by letter.\nEach letter wants to be matched with the longest dictionary substring at that current time.\n\nThe output is made up of tokens.\nEach token is in the format `<index, letter>`\nwhere `index` is the index of the longest dictionary value that matches the current substring\nand `letter` is the current letter being looked at.\n\n\nHere is how the string `'ABAABABAABAB'` is encoded:\n\n\n* First, a dictionary is initialised with the 0th item pointing to an empty string:\n\n```md\nDictionary      Input             Output\n0  |  ''        ABAABABAABAB\n```\n\n* The first letter is `A`. As it doesn't appear in the dictionary, we add `A` to the next avaliable index.\nThe token `<0, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A>\n1  |  A         ^\n```\n\n* The second letter is `B`. It doesn't appear in the dictionary, so we add `B` to the next avaliable index.\nThe token `<0, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B>\n1  |  A          ^\n2  |  B\n```\n\n* The third letter is `A` again: it already appears in the dictionary at position `1`. We add the next letter which is also `A`. `AA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<1, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A>\n1  |  A           ^^\n2  |  B\n3  |  AA\n```\n\n* The next letter is `B` again: it already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<2, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A>\n1  |  A             ^^\n2  |  B\n3  |  AA\n4  |  BA\n```\n\n* The next letter is `B`: it already appears in the dictionary and at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `A`. `BAA` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, A>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A>\n1  |  A               ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n```\n\n* The next letter is `B`. It already appears in the dictionary at position `2`. We add the next letter which is `A`. `BA` already appears in the dictionary at position `4`. We add the next letter which is `B`. `BAB` doesn't appear in the dictionary, so we add it to the next avaliable index.\nThe token `<4, B>` is added to the output:\n\n```md\nDictionary      Input             Output\n\n0  |  ''        ABAABABAABAB      <0, A> <0, B> <1, A> <2, A> <4, A> <4, B>\n1  |  A                  ^^^\n2  |  B\n3  |  AA\n4  |  BA\n5  |  BAA\n6  |  BAB\n```\n\n* We have now reached the end of the string. We have the output tokens: `<0, A> <0, B> <1, A> <2, A> <4, A> <4, B>`.\nNow we just return the tokens without the formatting: `'0A0B1A2A4A4B'`\n\n**Note:**\n\nIf the string ends with a match in the dictionary, the last token should only contain the index of the dictionary. For example, `'ABAABABAABABAA'` (same as the example but with `'AA'` at the end) should return `'0A0B1A2A4A4B3'` (note the final `3`).\n\nTo decode, it just works the other way around.\n\n\n# Examples\n\nSome more examples:\n```\nDecoded                               Encoded\n\nABBCBCABABCAABCAABBCAA                0A0B2C3A2A4A6B6\nAAAAAAAAAAAAAAA                       0A1A2A3A4A\nABCABCABCABCABCABC                    0A0B0C1B3A2C4C7A6\nABCDDEFGABCDEDBBDEAAEDAEDCDABC        0A0B0C0D4E0F0G1B3D0E4B2D10A1E4A10D9A2C\n```\n\n\nGood luck :)\n",
  "totalAttempts": 1840,
  "totalCompleted": 278,
  "totalStars": 43,
  "voteScore": 87,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}