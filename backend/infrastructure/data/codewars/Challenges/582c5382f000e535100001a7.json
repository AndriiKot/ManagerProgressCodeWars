{
  "id": "582c5382f000e535100001a7",
  "name": "Parse a linked list from a string",
  "slug": "parse-a-linked-list-from-a-string",
  "category": "algorithms",
  "publishedAt": "2016-11-16T13:29:48.633Z",
  "approvedAt": "2017-03-13T19:56:24.303Z",
  "languages": [
    "php",
    "javascript",
    "csharp",
    "swift",
    "c",
    "cpp",
    "objc",
    "fortran",
    "scala",
    "haskell",
    "python",
    "cobol",
    "java"
  ],
  "url": "https://www.codewars.com/kata/582c5382f000e535100001a7",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-11-16T12:39:35.324Z",
  "createdBy": {
    "username": "donaldsebleung",
    "url": "https://www.codewars.com/users/donaldsebleung"
  },
  "approvedBy": {
    "username": "smile67",
    "url": "https://www.codewars.com/users/smile67"
  },
  "description": "# Parse a linked list from a string\n\n## Related Kata\n\nAlthough this Kata is not part of an official Series, you may want to complete [this Kata](https://www.codewars.com/kata/convert-a-linked-list-to-a-string) before attempting this one as these two Kata are deeply related.\n\n## Preloaded\n\nPreloaded for you is a class, struct or derived data type `Node` ( depending on the language ) used to construct linked lists in this Kata:\n\n```php\nclass Node {\n  public $data, $next;\n  public function __construct($data, $next = NULL) {\n    $this->data = $data;\n    $this->next = $next;\n  }\n}\n```\n```javascript\nclass Node {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n```\n```csharp\npublic class Node : Object\n{\n  public int Data;\n  public Node Next;\n  \n  public Node(int data, Node next = null)\n  {\n    this.Data = data;\n    this.Next = next;\n  }\n  \n  public override bool Equals(Object obj)\n  {\n    // Check for null values and compare run-time types.\n    if (obj == null || GetType() != obj.GetType()) { return false; }\n  \n    return this.ToString() == obj.ToString();\n  }\n  \n  public override string ToString()\n  {\n    List<int> result = new List<int>();\n    Node curr = this;\n    \n    while (curr != null)\n    {\n      result.Add(curr.Data);\n      curr = curr.Next;\n    }\n    \n    return String.Join(\" -> \", result) + \" -> null\";\n  }\n}\n```\n```swift\nclass Node {\n    var data : Int\n    var next : Node?\n    init(_ data:Int) {\n        self.data = data\n        self.next = nil\n    }\n    init(_ data:Int, _ next: Node?) {\n        self.data = data\n        self.next = next\n    }\n}\n```\n```c\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n```\n```cpp\nclass Node {\n  public:\n    int data;\n    Node *next;\n    Node(int data, Node *next = nullptr): data(data), next(next) {}\n};\n```\n```objc\ntypedef struct node {\n  int data;\n  struct node *next;\n} Node;\n```\n```fortran\ntype Node\n  integer :: data\n  type(Node), pointer :: next\nend type Node\n```\n```scala\ncase class Node(data: Int, next: Node = null)\n```\n```haskell\n-- use regular lists, which are already singly-linked\ndata [a] = [] | a : [a]\n```\n```python\nclass Node:\n    def __init__(self, data, next=None): \n        self.data = data\n        self.next = next\n```\n```cobol\n       01  node.\n           05 val     pic 9(4).\n           05 nxt     usage pointer.\n```\n```java\nfinal class Node {\n  public final int data;\n  public Node next;\n  public Node(int data) {\n    this(data, null);\n  }\n  public Node(int data, Node next) {\n    this.data = data;\n    this.next = next;\n  }\n}\n```\n\n~~~if:c\n*NOTE: In C, the* `Node` *struct is placed on top of your main solution because otherwise the compiler complains about not recognizing the struct (even if it is defined in the Preloaded section).  Attempts to modify it (e.g. to cheat the tests in some way) will likely result in a test crash so it is not recommended for you to modify that section ;)*\n~~~\n\n~~~if:objc\n*NOTE: In Objective-C, the* `Node` *struct is placed on top of your main solution because there is a \"double-import\" bug in the Preloaded section at the time of writing that cannot be fixed on my end.  Attempts to modify it (e.g. to cheat the tests in some way) will likely result in a test crash so it is not recommended for you to modify that section ;)*\n~~~\n\n~~~if:cobol\nUse the preallocated table `nodesTable` in linkage-section to store the nodes of the linked list.\n~~~\n\n## Prerequisites\n\nThis Kata assumes that you are already familiar with the idea of a linked list.  If you do not know what that is, you may want to read up on [this article on Wikipedia](https://en.wikipedia.org/wiki/Linked_list).  Specifically, the linked lists this Kata is referring to are **singly linked lists**, where the value of a specific node is stored in its `data` / `$data`/`Data` property, the reference to the next node is stored in its `next` / `$next` / `Next` property and the terminator for a list is `null` / `NULL` / `nil` / `nullptr` / `null()` / `[]`.\n\nAdditionally, this Kata assumes that you have basic knowledge of Object-Oriented Programming ( or a similar concept ) in the programming language you are undertaking.  If you have not come across Object-Oriented Programming in your selected language, you may want to try out an online course or read up on some code examples of OOP in your selected language up to ( but not necessarily including ) Classical Inheritance.\n\n*Specifically, if you are attempting this Kata in PHP and haven't come across OOP, you may want to try out the first 4 Kata in [this Series](https://www.codewars.com/collections/object-oriented-php).*\n\n## Task\n\nCreate a function `parse` which accepts exactly one argument `string` / `$string` / `s` / `strrep` ( or similar, depending on the language ) which is a string representation of a linked list.  Your function must return the corresponding linked list, constructed from instances of the `Node` class/struct/type.  The string representation of a list has the following format: the value of the node, followed by a whitespace, an arrow and another whitespace (`\" -> \"`), followed by the rest of the linked list.  Each string representation of a linked list will end in `\"null\"` / `\"NULL\"` / `\"nil\"` / `\"nullptr\"` / `\"null()\"` depending on the language you are undertaking this Kata in.  For example, given the following string representation of a linked list:\n\n```javascript\n\"1 -> 2 -> 3 -> null\"\n```\n```php\n\"1 -> 2 -> 3 -> NULL\"\n```\n```c\n\"1 -> 2 -> 3 -> NULL\"\n```\n```swift\n\"1 -> 2 -> 3 -> nil\"\n```\n```cpp\n\"1 -> 2 -> 3 -> nullptr\"\n```\n```objc\n@\"1 -> 2 -> 3 -> NULL\"\n```\n```fortran\n\"1 -> 2 -> 3 -> null()\"\n```\n```cobol\n      \"1 -> 2 -> 3 -> null\"\n```\n\n... your function should return:\n\n<!-- unlisted languages use the top block -- please keep javascript up top -->\n\n```javascript\nnew Node(1, new Node(2, new Node(3)))\n```\n```swift\nNode(1, Node(2, Node(3)))\n```\n```c\n// Code example not applicable to C - the Node struct does not have a constructor function\n```\n```objc\n// Code example not applicable to Objective-C - the Node struct does not have a constructor function\n```\n```fortran\ntype(Node), pointer :: list\n! Where:\n! list%data == 1\n! list%next%data == 2\n! list%next%next%data == 3\n! list%next%next%next => null()\n```\n```scala\nNode(1, Node(2, Node(3)))\n```\n```haskell\n[ 1, 2, 3 ]\n```\n\nNote that due to the way the constructor for `Node` is defined, if a second argument is not provided, the `next` / `$next` / `Next` field is automatically set to `null` / `NULL` / `nil` / `nullptr` ( or equivalent in your language ).  That means your function could also return the following ( if it helps you better visualise what is actually going on ):\n\n<!-- unlisted languages use the top block -- please keep javascript up top -->\n\n```javascript\nnew Node(1, new Node(2, new Node(3, null)))\n```\n```php\nnew Node(1, new Node(2, new Node(3, NULL)))\n```\n```swift\nNode(1, Node(2, Node(3, nil)))\n```\n```c\n// In C the Node struct does not have a constructor function - please return a dynamically allocated version of the list displayed below:\n\n&((Node){\n  .data = 1,\n  .next = &((Node){\n    .data = 2,\n    .next = &((Node){\n      .data = 3,\n      .next = NULL\n    })\n  })\n})\n```\n```cpp\nnew Node(1, new Node(2, new Node(3, nullptr)))\n```\n```objc\n// In Objective-C the Node struct does not have a constructor function - please return a dynamically allocated version of the list displayed below:\n\n&((Node){\n  .data = 1,\n  .next = &((Node){\n    .data = 2,\n    .next = &((Node){\n      .data = 3,\n      .next = NULL\n    })\n  })\n})\n```\n```fortran\n! Code example not applicable to Fortran - there is no constructor for `Node`\n```\n```haskell\nthis section is not applicable to Haskell\n```\n```cobol\n      * Code example not applicable to COBOL\n```\n\nAnother example: given the following string input:\n\n<!-- unlisted languages use the top block -- please keep javascript up top -->\n\n```javascript\n\"0 -> 1 -> 4 -> 9 -> 16 -> null\"\n```\n```php\n\"0 -> 1 -> 4 -> 9 -> 16 -> NULL\"\n```\n```c\n\"0 -> 1 -> 4 -> 9 -> 16 -> NULL\"\n```\n```swift\n\"0 -> 1 -> 4 -> 9 -> 16 -> nil\"\n```\n```cpp\n\"0 -> 1 -> 4 -> 9 -> 16 -> nullptr\"\n```\n```objc\n@\"0 -> 1 -> 4 -> 9 -> 16 -> NULL\"\n```\n```fortran\n\"0 -> 1 -> 4 -> 9 -> 16 -> null()\"\n```\n\n... your function should return:\n\n<!-- unlisted languages use the top block -- please keep javascript up top -->\n\n```javascript\nnew Node(0, new Node(1, new Node(4, new Node(9, new Node(16)))))\n```\n```swift\nNode(0, Node(1, Node(4, Node(9, Node(16)))))\n```\n```c\n&((Node){\n  .data = 0,\n  .next = &((Node){\n    .data = 1,\n    .next = &((Node){\n      .data = 4,\n      .next = &((Node){\n        .data = 9,\n        .next = &((Node){\n          .data = 16,\n          .next = NULL\n        })\n      })\n    })\n  })\n})\n```\n```objc\n&((Node){\n  .data = 0,\n  .next = &((Node){\n    .data = 1,\n    .next = &((Node){\n      .data = 4,\n      .next = &((Node){\n        .data = 9,\n        .next = &((Node){\n          .data = 16,\n          .next = NULL\n        })\n      })\n    })\n  })\n})\n```\n```fortran\ntype(Node), pointer :: list\n! Where:\n! list%data == 0\n! list%next%data == 1\n! list%next%next%data == 4\n! list%next%next%next%data == 9\n! list%next%next%next%next%data == 16\n! list%next%next%next%next%next => null()\n```\n```haskell\n[ 0, 1, 4, 9, 16 ]\n```\n\nIf the input string is just `\"null\"` / `\"NULL\"` / `\"nil\"` / `\"nullptr\"` / `\"null()\"`, return `null` / `NULL` / `nil` / `nullptr` / `null()` / `[]` ( or equivalent ).\n\nFor the simplicity of this Kata, the values of the nodes in the string representation will always ever be **non-negative integers**, so the following would **not** occur: `\"Hello World -> Goodbye World -> 123 -> null\"` / `\"Hello World -> Goodbye World -> 123 -> NULL\"` / `\"Hello World -> Goodbye World -> 123 -> nil\"` / `\"Hello World -> Goodbye World -> 123 -> nullptr\"` ( depending on the language ).  This also means that the values of each `Node` must also be **non-negative integers** so keep that in mind when you are parsing the list from the string.\n\n~~~if:fortran\nFurthermore, if you are attempting this Kata in Fortran, you may assume that the string input will never contains leading and/or trailing whitespace.\n~~~\n\nEnjoy, and don't forget to check out my other Kata Series :D\n",
  "totalAttempts": 10958,
  "totalCompleted": 2785,
  "totalStars": 149,
  "voteScore": 431,
  "tags": [
    "Linked Lists",
    "Recursion",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}