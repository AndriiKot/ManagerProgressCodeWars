{
  "id": "5174a4c0f2769dd8b1000003",
  "name": "Sort Numbers",
  "slug": "sort-numbers",
  "category": "reference",
  "publishedAt": "2013-04-22T03:04:16.990Z",
  "approvedAt": null,
  "languages": [
    "javascript",
    "coffeescript",
    "ruby",
    "python",
    "csharp",
    "rust",
    "haskell",
    "typescript",
    "r",
    "cpp",
    "clojure",
    "julia",
    "php",
    "go",
    "cobol",
    "c",
    "lambdacalc",
    "scala",
    "crystal"
  ],
  "url": "https://www.codewars.com/kata/5174a4c0f2769dd8b1000003",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2013-04-22T02:47:28.567Z",
  "createdBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Finish the solution so that it sorts the passed in array of numbers. If the function passes in an empty array or null/nil value then it should return an empty array.\n\nFor example:\n\n```r\nsolution(c(1, 2, 3, 10, 5)) # should return c(1, 2, 3, 5, 10)\nsolution(NULL)              # should return NULL\n```\n```php\nsolution([1, 2, 10, 50, 5]); // should return [1,2,5,10,50]\nsolution(null); // should return []\n```\n```javascript\nsolution([1, 2, 10, 50, 5]); // should return [1,2,5,10,50]\nsolution(null); // should return []\n```\n```typescript\nsolution([1, 2, 10, 50, 5]); // should return [1, 2, 5, 10, 50]\nsolution([]); // should return []\n```\n```coffeescript\nsolution([1, 2, 10, 50, 5]) # should return [1,2,5,10,50]\nsolution(null) # should return []\n```\n```ruby\nsolution([1, 2, 10, 50, 5]) # should return [1,2,5,10,50]\nsolution(nil) # should return []\n```\n```python\nsolution([1,2,3,10,5]) # should return [1,2,3,5,10]\nsolution(None) # should return []\n```\n```julia\nsolution([1, 2, 10, 50, 5]) # should return [1,2,5,10,50]\nsolution(nothing) # should return []\n```\n```csharp\nSortNumbers(new int[] { 1, 2, 10, 50, 5 }); // should return new int[] { 1, 2, 5, 10, 50 }\nSortNumbers(null); // should return new int[] { }\n```\n```rust\nsort_numbers(&vec![1, 2, 3, 10, 5]); // should return vec![1, 2, 3, 5, 10]\nsort_numbers(&vec![]); // should return !vec[]\n```\n```haskell\nsortNumbers [1, 2, 10, 50, 5] = Just [1, 2, 5, 10, 50]\nsortNumbers [] = Nothing\n```\n```lambdacalc\n# (Note in Lambda Calculus we have lists instead of arrays.)\nnums = cons 1 (cons 2 (cons 10 (cons 50 (cons 5 nil))))\nsort nums # cons 1 (cons 2 (cons 5 (cons 10 (cons 50 nil))))\n```\n```cpp\nsortNumbers({1, 2, 10, 50, 5}) // sholud return {1, 2, 5, 10, 50}\nsortNumbers({}) // should return {}\n```\n```c\nint array[5] = {1, 2, 10, 50, 5};\nsort_ascending(5, array); // array is now {1, 2, 5, 10, 50}\nsort_ascending(0, NULL); // nothing to do for empty array\n```\n```cobol\n      SortNumbers([1, 2, 10, 50, 5])\n      *  -> res = [1, 2, 5, 10, 50]\n      SortNumbers([])\n      *  -> res = []\n```\n```scala\nsol(List(0, 3, 2, 5, 4, 1)) // returns List(0, 1, 2, 3, 4, 5)\nsol(List()) // returns List()\n```\n```crystal\nsolution([1, 2, 10, 50, 5]) # should return [1,2,5,10,50]\nsolution(nil) # should return [] of Int32\n```\n~~~if:lambdacalc\n## Lambda Calculus\n\n- Purity: LetRec\n- Num encoding: BinaryScott\n- For LC, there won't be `null` inputs.\n- Instead of arrays, we have cons lists. Define the following, which the tests will use to construct inputs and test outputs:\n  - `nil : List a` (empty list)\n  - `cons : a -> List a -> List a` (add to head)\n  - `foldr : (a -> b -> b) -> b -> List a -> b` (right-associative fold / reduce)\n\n### Optional Performance Check\n\nBy default the tests are lenient with respect to performance. If you would like to demonstrate that your solution is fast, you can opt in to a stricter test suite ( more lists, longer lists, higher numbers ). Just change `perf-tests = Low` to `perf-tests = High`.\n~~~",
  "totalAttempts": 182136,
  "totalCompleted": 67138,
  "totalStars": 390,
  "voteScore": 3561,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 4
  }
}