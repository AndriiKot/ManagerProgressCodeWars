{
  "id": "5be350bcce5afad8020000d6",
  "name": "Word Segmentation: MaxMatch",
  "slug": "word-segmentation-maxmatch",
  "category": "algorithms",
  "publishedAt": "2018-11-07T22:29:02.346Z",
  "approvedAt": "2018-11-09T02:41:07.559Z",
  "languages": [
    "javascript",
    "haskell",
    "java",
    "python",
    "ruby",
    "kotlin"
  ],
  "url": "https://www.codewars.com/kata/5be350bcce5afad8020000d6",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2018-11-07T20:53:16.434Z",
  "createdBy": {
    "username": "ewingsa",
    "url": "https://www.codewars.com/users/ewingsa"
  },
  "approvedBy": {
    "username": "cliffstamp",
    "url": "https://www.codewars.com/users/cliffstamp"
  },
  "description": "Some languages like Chinese, Japanese, and Thai do not have spaces between words. However, most natural languages processing tasks like part-of-speech tagging require texts that have segmented words. A simple and reasonably effective algorithm to segment a sentence into its component words is called \"MaxMatch\".\n\n## MaxMatch\nMaxMatch starts at the first character of a sentence and tries to find the longest valid word starting from that character. If no word is found, the first character is deemed the longest \"word\", regardless of its validity. In order to find the rest of the words, MaxMatch is then recursively invoked on all of the remaining characters until no characters remain. A list of all of the words that were found is returned.\n\nSo for the string `\"happyday\"`, `\"happy\"` is found because `\"happyday\"` is not a valid word, nor is `\"happyda\"`, nor `\"happyd\"`. Then, MaxMatch is called on `\"day\"`, and `\"day\"` is found. The output is the list `[\"happy\", \"day\"]` in that order.\n\n## The Challenge\n\n```if:javascript\nWrite `maxMatch`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns an `Array` of all the words found, in the order they were found.\n**All valid words are in the** `Set` `VALID_WORDS`, which only contains around 500 English words.\n```\n```if:haskell\nWrite `maxMatch`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns a `[String]` of all the words found, in the order they were found. All valid words are in the `[String]` `validWords`, which only contains around 500 English words.\n```\n```if:java\nWrite `maxMatch`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns a `List` of `String`s which are all the words found, in the order they were found. All valid words are in the `Set` `Preloaded.VALID_WORDS`, , which only contains around 500 English words.\n```\n```if:python\nWrite `max_match`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns a `List` of `String`s of all the words found, in the order they were found. **All valid words are in the** `Set` `VALID_WORDS`, which only contains around 500 English words.\n```\n```if:ruby\nWrite `max_match`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns an `Array` of `String`s of all the words found, in the order they were found. All valid words are in the `Array` `VALID_WORDS`, which only contains around 500 English words.\n```\n```if:kotlin\nWrite `maxMatch`, which takes an alphanumeric, spaceless, lowercased `String` as input and returns a `List` of `String`s which are all the words found, in the order they were found. All valid words are in the `Set` `VALID_WORDS`, which only contains around 500 English words.\n```\n**Note:** This algorithm is simple and operates better on Chinese text, so accept the fact that some words will be segmented wrongly.\n\nHappy coding :)",
  "totalAttempts": 4665,
  "totalCompleted": 798,
  "totalStars": 66,
  "voteScore": 187,
  "tags": [
    "Parsing",
    "Recursion",
    "Strings",
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}