{
  "id": "577a6e90d48e51c55e000217",
  "name": "Collatz Conjecture (3n+1)",
  "slug": "collatz-conjecture-3n-plus-1",
  "category": "algorithms",
  "publishedAt": "2016-07-04T14:11:39.172Z",
  "approvedAt": "2016-07-11T16:51:02.661Z",
  "languages": [
    "cpp",
    "javascript",
    "python",
    "elixir",
    "clojure",
    "csharp",
    "c",
    "java",
    "ruby",
    "nasm"
  ],
  "url": "https://www.codewars.com/kata/577a6e90d48e51c55e000217",
  "rank": {
    "id": -8,
    "name": "8 kyu",
    "color": "white"
  },
  "createdAt": "2016-07-04T14:11:29.274Z",
  "createdBy": {
    "username": "Goncalerta",
    "url": "https://www.codewars.com/users/Goncalerta"
  },
  "approvedBy": {
    "username": "donaldsebleung",
    "url": "https://www.codewars.com/users/donaldsebleung"
  },
  "description": "The Collatz conjecture (also known as 3n+1 conjecture) is a conjecture that applying the following algorithm to any number we will always eventually reach one:\n\n```\n[This is writen in pseudocode]\nif(number is even) number = number / 2\nif(number is odd) number = 3*number + 1\n```\n\n#Task\n\nYour task is to make a function ```hotpo``` that takes a positive ```n``` as input and returns the number of times you need to perform this algorithm to get ```n = 1```.\n\n#Examples\n\n```\nhotpo(1) returns 0\n(1 is already 1)\n\nhotpo(5) returns 5\n5 -> 16 -> 8 -> 4 -> 2 -> 1\n\nhotpo(6) returns 8\n6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1\n\nhotpo(23) returns 15\n23 -> 70 -> 35 -> 106 -> 53 -> 160 -> 80 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1\n```\n\n#References\n- Collatz conjecture wikipedia page: https://en.wikipedia.org/wiki/Collatz_conjecture",
  "totalAttempts": 31638,
  "totalCompleted": 15516,
  "totalStars": 224,
  "voteScore": 1438,
  "tags": [
    "Fundamentals",
    "Algorithms",
    "Mathematics"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 4,
    "suggestions": 3
  }
}