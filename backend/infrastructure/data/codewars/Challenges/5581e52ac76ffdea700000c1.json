{
  "id": "5581e52ac76ffdea700000c1",
  "name": "Rule 30",
  "slug": "rule-30",
  "category": "games",
  "publishedAt": "2015-06-17T21:31:29.347Z",
  "approvedAt": "2015-09-13T18:53:12.750Z",
  "languages": [
    "python",
    "javascript",
    "ruby",
    "haskell",
    "cobol",
    "lambdacalc",
    "c",
    "rust",
    "csharp"
  ],
  "url": "https://www.codewars.com/kata/5581e52ac76ffdea700000c1",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2015-06-17T21:22:51.124Z",
  "createdBy": {
    "username": "MircoT",
    "url": "https://www.codewars.com/users/MircoT"
  },
  "approvedBy": {
    "username": "GiacomoSorbi",
    "url": "https://www.codewars.com/users/GiacomoSorbi"
  },
  "description": "Rule 30 is a one-dimensional binary cellular automaton. You can have some information here: https://en.wikipedia.org/wiki/Rule_30\n\nComplete the function that takes as input an array of `0`s and `1`s and a non-negative integer `n` that represents the number of iterations. This function has to perform the n<sup>th</sup> iteration of **Rule 30** with the given input.\n\nThe rule to derive a cell from itself and its neigbour is:\n\nCurrent cell  | 000 | 001 | 010 | 011 | 100 | 101 | 110 | 111\n:-------------|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:\n **New cell** |  0  |  1  |  1  |  1  |  1  |  0  |  0  |  0 \n\nAs you can see the new state of a certain cell depends on his neighborhood. In *Current cell* you have the *nth* cell with its left and right neighbor, for example the first configuration is **000**:\n\n* left neighbor = 0\n* current cell = 0\n* right neighbor = 0\n\nThe result for the current cell is **0**, as reported in the **New cell** row.\n\nYou also have to pay attention to the following things:\n\n* the borders of the list are always 0\n* you have to return an array of 0 and 1\n\nHere a small example step by step, starting from the list **[1]** and iterating 5 times:\n\n* We have only one element so first of all we have to follow the rules adding the border, so the result will be **[0, 1, 0]**\n* Now we can apply the rule 30 to all the elements and the result will be **[1, 1, 1]** (first iteration)\n* Then, after continuing this way for 4 times, the result will be **[1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1]**\n\n\n~~~if:python\nIn Python you can also use a support function to print the sequence named `printRule30`. This function takes as parameters the current list of 0 and 1 to print, the max level that you can reach (number of iterations) and the length of initial array.\n\n```python\ndef printRule30(list_, maxLvl, startLen):\n  ...\n```\n\nThe last two parameters are optional and are useful if you are printing each line of the iteration to center the result like this:\n\n░░▓░░  -> step 1  \n░▓▓▓░  -> step 2  \n▓▓░░▓  -> step 3  \n\nIf you pass only the array of 0 and 1 the previous result for each line will be like this:\n\n▓ -> step 1   \n▓▓▓ -> step 2  \n▓▓░░▓ -> step 3 \n\n**Note:** the function can print only the current list that you pass to it, so you have to use it in the proper way during the interactions of the rule 30.\n~~~\n~~~if:lambdacalc\n#### Encodings\n\n`purity: LetRec`  \n`numEncoding: Scott`  \nexport constructors `nil, cons` and deconstructor `foldr` for your `List` encoding  \n~~~\n\n~~~if:csharp\nIf you need to debug your solution you can use the method `string CellsToString(IEnumerable<byte> cells)` of the preloaded class `Helper`\n```csharp\nbyte[] cells = { 1, 1, 0, 0, 1 };\nConsole.WriteLine(Helper.CellsToString(cells));\n// output: \"▓▓░░▓\"\n```\n~~~",
  "totalAttempts": 5640,
  "totalCompleted": 952,
  "totalStars": 89,
  "voteScore": 138,
  "tags": [
    "Lists",
    "Arrays",
    "Binary",
    "Puzzles"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 5
  }
}