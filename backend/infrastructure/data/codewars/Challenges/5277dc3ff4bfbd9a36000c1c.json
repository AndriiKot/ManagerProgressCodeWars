{
  "id": "5277dc3ff4bfbd9a36000c1c",
  "name": "ASCII85 Encoding & Decoding",
  "slug": "ascii85-encoding-and-decoding",
  "category": "algorithms",
  "publishedAt": "2013-11-04T18:48:45.667Z",
  "approvedAt": "2014-02-17T02:17:46.550Z",
  "languages": [
    "javascript",
    "haskell",
    "python",
    "typescript",
    "c",
    "cpp",
    "swift",
    "ruby",
    "java",
    "csharp"
  ],
  "url": "https://www.codewars.com/kata/5277dc3ff4bfbd9a36000c1c",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2013-11-04T17:41:19.833Z",
  "createdBy": {
    "username": "delfuego",
    "url": "https://www.codewars.com/users/delfuego"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "ASCII85 is a binary-to-ASCII encoding scheme that's used within PDF and Postscript, and which provides data-size savings over base 64. Your task is to extend the String object with two new methods, ```toAscii85``` (```to_ascii85``` in ruby) and ```fromAscii85``` (```from_ascii85``` in ruby), which handle encoding and decoding ASCII85 strings.\n\nAs Python does not allow modifying the built-in string class, for Python the task is to provide functions ```toAscii85(data)``` and ```fromAscii85(ascii85)```, which handle encoding and decoding ASCII85 strings (instead of string object methods).\n\nAs Swift strings are very picky about character encodings (and don't take kindly to storing binary data), in Swift, extend Data with a ```toAscii85``` method and String with a ```fromAscii85``` method.\n\nThe ```toAscii85``` method should take no arguments and must encode the value of the string to ASCII85, without any line breaks or other whitespace added to the native ASCII85-encoded value.\n\nExample:\n\n* ```'easy'.toAscii85()``` should return ```<~ARTY*~>```\n* ```'moderate'.toAscii85()``` should return ```<~D/WrrEaa'$~>```\n* ```'somewhat difficult'.toAscii85()``` should return ```<~F)Po,GA(E,+Co1uAnbatCif~>```\n\nThe ```fromAscii85``` method should take no arguments and must decode the value of the string (which is presumed to be ASCII85-encoded text).\n\nExample:\n\n* ```'<~ARTY*~>'.fromAscii85()``` should return ```easy```\n* ```'<~D/WrrEaa\\'$~>'.fromAscii85()``` should return ```moderate```\n* ```'<~F)Po,GA(E,+Co1uAnbatCif~>'.fromAscii85()``` should return ```somewhat difficult```\n\nYou can [learn all about ASCII85 here](http://en.wikipedia.org/wiki/Ascii85). And remember, this is a binary-to-ASCII encoding scheme, so the input isn't necessarily always a readable string! A brief summary of the salient points, however, is as follows:\n\n1. In general, four binary bytes are encoded into five ASCII85 characters.\n2. The character set that ASCII85 encodes into is the 85 characters between ASCII 33 (```!```) and ASCII 117 (```u```), as well as ASCII 122 (```z```), which is used for data compression (see below).\n3. In order to encode, four binary bytes are taken together as a single 32-bit number (you can envision concatenating their binary representations, which creates a 32-bit binary number). You then serially perform division by 85, and add 33 to the remainder of each division to get the ASCII character value for the encoded value; the first division and addition of 33 is the rightmost character in the encoded five-character block, etc. (This is all represented well is [the visualization in the Wikipedia page's example](http://en.wikipedia.org/wiki/Ascii85#Example).)\n4. If the last block to be encoded contains less than four bytes, it's padded with nulls to a total length of four bytes, and then after encoding, the same number of characters are removed as were added in the padding step.\n5. If a block to be encoded contains all nulls, then that block is encoded as a simple ```z``` (ASCII 122) rather than the fully-encoded value of ```!!!!!```.\n6. The final encoded value is surrounded by ```<~``` at the start and ```~>``` at the end. In the wild, whitespace can be inserted as needed (e.g., line breaks for mail transport agents); in this kata, **whitespace shouldn't be added to the final encoded value** for the sake of checking the fidelity of the encoding. \n7. Decoding applies the above in reverse; each block of five encoded characters is taken as its ASCII character codes, multiplied by powers of 85 according to the position in the block of five characters (again, see the Wikipedia example visualization), and then broken into four separate bytes to determine the corresponding binary values.\n8. If a block to be decoded contains less than five characters, it is padded with ```u``` characters (ASCII 117), decoded appropriately, and then the same number of characters are removed from the end of the decoded block as ```u```s were added.\n9. All whitespace in encoded values is ignored (as in, it's removed from the encoded data before the data is broken up into the five-character blocks to be decoded).\n\n<br>\n\nTo make your testing easier, two functions are preloaded for your use if you wish:\n\n* ```generateRandomReadableStrings(num, len)```: generates an array of *num* strings of length *len* containing only readable ASCII characters\n* ```generateRandomBinaryData(num, len)```: generates an array of *num* strings of length *len* containing binary data (ASCII code 0â€”255)\n",
  "totalAttempts": 49169,
  "totalCompleted": 1369,
  "totalStars": 343,
  "voteScore": 263,
  "tags": [
    "Binary",
    "Strings",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 7,
    "suggestions": 2
  }
}