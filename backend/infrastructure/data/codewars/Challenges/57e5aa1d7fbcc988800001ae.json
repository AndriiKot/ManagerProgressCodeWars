{
  "id": "57e5aa1d7fbcc988800001ae",
  "name": "Unflatten a list (Harder than easy)",
  "slug": "unflatten-a-list-harder-than-easy",
  "category": "algorithms",
  "publishedAt": "2016-09-24T10:31:53.137Z",
  "approvedAt": "2017-01-28T13:13:20.490Z",
  "languages": [
    "csharp",
    "java",
    "javascript",
    "typescript",
    "python",
    "ruby",
    "coffeescript"
  ],
  "url": "https://www.codewars.com/kata/57e5aa1d7fbcc988800001ae",
  "rank": {
    "id": -4,
    "name": "4 kyu",
    "color": "blue"
  },
  "createdAt": "2016-09-23T22:18:06.314Z",
  "createdBy": {
    "username": "user5036852",
    "url": "https://www.codewars.com/users/user5036852"
  },
  "approvedBy": {
    "username": "smile67",
    "url": "https://www.codewars.com/users/smile67"
  },
  "description": "# Unflatten a list (Harder than easy)\n\nThis is the harder version of [Unflatten a list (Easy)](https://www.codewars.com/kata/57e2dd0bec7d247e5600013a)\n\nSo you have again to build a method, that creates new arrays, that can be flattened!\n\n# Shorter: You have to unflatten a list/an array.\n\nYou get an array of integers and have to unflatten it by these rules:\n```\n- You have to do several runs. The depth is the number of runs, you have to do.\n- In every run you have to switch the direction. First run from left, next run from right. Next left...\nEvery run has these rules:\n- You start at the first number (from the direction).\n- Take for every number x the remainder of the division by the number of still available elements (from \n  this position!) to have the number for the next decision.\n- If the remainder-value is smaller than 3, take this number x (NOT the remainder-Value) direct\n  for the new array and continue with the next number.\n- If the remainder-value (e.g. 3) is greater than 2, take the next remainder-value-number (e.g. 3)\n  elements/numbers (inclusive the number x, NOT the remainder-value) as a sub-array in the new array.\n  Continue with the next number/element AFTER this taken elements/numbers.\n- Every sub-array in the array is independent and is only one element for the progress on the array. \n  For every sub-array you have to follow the same rules for unflatten it.\n  The direction is always the same as the actual run.\n```\n\nSounds complicated? Yeah, thats why, this is the harder version...\nMaybe an example will help.\n\n```\n Array: [4, 5, 1, 7, 1] Depth: 2 -> [[ 4, [ 5, 1, 7 ] ], 1]\n \nSteps: \nFirst run: (start from left side!)\n1. The first number is 4. The number is smaller than the number of remaining elements, so it is the remainder-value (4 / 5 -> remainder 4).\n   So 4 numbers (4, 5, 1, 7) are added as sub-array in the new array.\n2. The next number is 1. It is smaller than 3, so the 1 is added direct to the new array.\nNow we have --> [[4, 5, 1, 7], 1]\n\nSecond run: (start from right side!)\n1. The last number (first from other side) is 1. So the 1 is added direct to the new array.\n2. The next element is the sub-array. So we use the rules for this.\n2a.The last number is 7. There are 4 elements in the array. So for the next decision you have to\n   take the remainder from 7 / 4 -> 3. So 3 numbers (5, 1, 7) are added as sub-array in the \n   new array.\n2b.Now there is the 4 and only one element last in this array. 4 / 1 -> remainder 0. It is smaller\n   than 3. So the 4 is added direct to the new array.\nNow we have --> [[ 4, [ 5, 1, 7 ] ], 1]\n```\n\nThe given array will always contain numbers. There will only be numbers > 0.\n\n\nHave fun coding it and please don't forget to vote and rank this kata! :-) \n\nI have created other katas. Have a look if you like coding and challenges.",
  "totalAttempts": 2381,
  "totalCompleted": 327,
  "totalStars": 84,
  "voteScore": 82,
  "tags": [
    "Mathematics",
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": false,
  "unresolved": {
    "issues": 1,
    "suggestions": 0
  }
}