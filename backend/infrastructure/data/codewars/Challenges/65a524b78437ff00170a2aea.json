{
  "id": "65a524b78437ff00170a2aea",
  "name": "Surviving the Bloody Enterprise: A Time-Travel Adventure with Running Totals",
  "slug": "surviving-the-bloody-enterprise-a-time-travel-adventure-with-running-totals",
  "category": "reference",
  "publishedAt": "2024-01-16T11:42:57.331Z",
  "approvedAt": "2024-02-29T09:36:57.426Z",
  "languages": [
    "sql"
  ],
  "url": "https://www.codewars.com/kata/65a524b78437ff00170a2aea",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2024-01-15T12:27:35.815Z",
  "createdBy": {
    "username": "bornForThis",
    "url": "https://www.codewars.com/users/bornForThis"
  },
  "approvedBy": {
    "username": "dfhwze",
    "url": "https://www.codewars.com/users/dfhwze"
  },
  "description": "##### Background Story:\n\nDuring your job interview, the air was thick with buzzwords like \"innovation,\" \"cutting-edge technology,\" and \"modern design principles.\" They asked you about SOLID principles, quizzed you on the latest design patterns, and you even had a lively debate about the merits of microservices versus monoliths. You left the interview feeling like you were about to join a tech utopia, ready to code in harmony with the latest trends and technologies.\n\nFast forward to your first day: Welcome to the real world of \"bloody enterprise\" tech! Instead of the shiny new tools you expected, you're handed a metaphorical shovel and a map to the tech equivalent of an archaeological site. Your tools? Java SE 6, a version so loyal to the past it might as well come with its own time capsule, and PostgreSQL 8.3, a database that's blissfully unaware of the wonders of window functions.\n\nAs you navigate through lines of Java code that feel like historical documents, and SQL queries that remind you of a simpler, pre-window function era, you can't help but chuckle. The innovative project you were pitched is more of a time travel experience to the golden days of 2008. But hey, who needs the latest and greatest when you've got the charm of legacy systems and the adventure of making them work? After all, there's a unique joy in keeping the digital relics running, like a tech world Indiana Jones, minus the hat and the whip. ü§†üíæüîç\n\n##### Task Description\n\nYou are working with a legacy sales database on PostgreSQL 8.3. The database contains a table named `sales` that records every sale:\n\n* `sales_id` (int, primary key)\n* `sales_dt` (datetime)\n* `customer_id` (int)\n* `item_id` (int)\n* `cnt` (int)\n* `price_per_item` (float)\n\n\nYou need to calculate and display in each row:\n1) The total count of all items sold in the dataset.\n2) `running_total`: A cumulative sum of the cnt (count) column for each `customer_id`, ordered by `customer_id`.\n3) `running_total_unique`: A cumulative sum of the cnt column across all customers, maintaining a continuous total as it moves from one customer to the next, ordered by `customer_id` and `sales_id`.\n\nSince PostgreSQL 8.3 does not support window functions, you cannot use the `OVER()` clause to easily calculate the running total like that:\n\n```sql\nselect sales_id, customer_id, cnt, \nsum(cnt) over () as total,\nsum(cnt) over (order by customer_id) as running_total,\nsum(cnt) over (order by customer_id, sales_id) as running_total_unique\nfrom sales\norder by customer_id, sales_id;\n```\n\nTherefore, you need to find an alternative method to achieve this.\n\nThe query should produce a result set with the following columns:\n\n1) `sales_id`: The ID of the sale.\n2) `customer_id`: The ID of the customer.\n3) `cnt`: The count of items sold in the transaction.\n4) `total`: The total count of all items sold.\n5) `running_total`: The cumulative count of items sold up to the current `customer_id`.\n6) `running_total_unique`: The cumulative count of items sold across all customers, in the order of `customer_id` and `sales_id`.\n\nA result set should be ordered by at first by `customer_id` and then by `sales_id` - both in ascending order.\n\nRestrictions:\n1) No Window Functions: The use of window functions, particularly the OVER clause.\n2) No Dynamic SQL: To ensure the integrity of the challenge, the use of dynamic SQL (e.g., using EXECUTE, FORMAT, concatenation operations to construct SQL queries) is not allowed.\n\n#### Desired Output\n\nThe desired output should look like this:\n\n<table><!----><tr><th>sales_id</th><th>customer_id</th><th>cnt</th><th>total</th><th>running_total</th><th>running_total_unique</th></tr><tr><td>1</td><td>100</td><td>2</td><td>24</td><td>12</td><td>2</td></tr><tr><td>2</td><td>100</td><td>1</td><td>24</td><td>12</td><td>3</td></tr><tr><td>3</td><td>100</td><td>1</td><td>24</td><td>12</td><td>4</td></tr><tr><td>4</td><td>100</td><td>5</td><td>24</td><td>12</td><td>9</td></tr><tr><td>6</td><td>100</td><td>1</td><td>24</td><td>12</td><td>10</td></tr><tr><td>8</td><td>100</td><td>1</td><td>24</td><td>12</td><td>11</td></tr><tr><td>10</td><td>100</td><td>1</td><td>24</td><td>12</td><td>12</td></tr><tr><td>5</td><td>150</td><td>1</td><td>24</td><td>20</td><td>13</td></tr><tr><td>7</td><td>150</td><td>2</td><td>24</td><td>20</td><td>15</td></tr><tr><td>11</td><td>150</td><td>5</td><td>24</td><td>20</td><td>20</td></tr><tr><td>9</td><td>170</td><td>3</td><td>24</td><td>24</td><td>23</td></tr><tr><td>12</td><td>170</td><td>1</td><td>24</td><td>24</td><td>24</td></tr></table>\n\nGLHF!",
  "totalAttempts": 576,
  "totalCompleted": 72,
  "totalStars": 9,
  "voteScore": 28,
  "tags": [
    "SQL",
    "Databases",
    "Restricted",
    "Refactoring"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}