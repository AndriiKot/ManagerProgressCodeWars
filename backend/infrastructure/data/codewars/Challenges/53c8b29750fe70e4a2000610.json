{
  "id": "53c8b29750fe70e4a2000610",
  "name": "Haskell List  Dot Notation",
  "slug": "haskell-list-dot-notation",
  "category": "algorithms",
  "publishedAt": "2014-07-18T06:05:06.156Z",
  "approvedAt": "2014-09-13T14:07:26.829Z",
  "languages": [
    "javascript"
  ],
  "url": "https://www.codewars.com/kata/53c8b29750fe70e4a2000610",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2014-07-18T05:37:28.059Z",
  "createdBy": {
    "username": "surtich",
    "url": "https://www.codewars.com/users/surtich"
  },
  "approvedBy": {
    "username": "xcthulhu",
    "url": "https://www.codewars.com/users/xcthulhu"
  },
  "description": "I would like to mimic some of the amazing things Haskell can do with lists.\n\nThere are lots of things to do, so I'm going to break the work into several katas.\n\nI'll warn you that perhaps you will have to refactor some parts of the code going forward, so you need to write the cleanest code possible.\n\nHaskell lists are similar to JavaScript arrays.\n\nFor example, this is ok in both programming languages:\n\n```haskell\n[1,-3,4]\n```\n\nBut Haskell allows you to define lists like this:\n\n```haskell\n[1..5] --equivalent to [1,2,3,4,5]\n```\n\nOr this way:\n\n```haskell\n[1,4..11] --equivalent to [1,4,7,10]\n```\n\nThis is also valid:\n\n```haskell\n[5,4..2] --equivalent to [5,4,3,2]\n```\n\nA formal definition provided by [nivoliev](http://www.codewars.com/users/nivoliev):\n\n* a list of individual elements : the resulting list is the list made of the individual elements as in classical Javascript\n* a range in the form `start..end` : if `end >= start`, the list is `[start, start+1, start+2, ..., end]` otherwise the result is `[]`\n* a single element a followed by a range : let `step = start - a`\n  * if `start === end` the list is `[a,start]`\n  * if step is positive and `end > start` then the list is `[a, a+step, a+2*step, ...]` as long as `a+k*step <= end`\n  * if step is negative and end < start then the list is `[a, a+step, a+2*step, ...]` as long as `a-k*step >= end`\n* otherwise the list is `[]`\n\nSome clarifying examples:\n\n```haskell\n[2,3,-5,3] -- just like in JavaScript : [2,3,-5,3]\n[1..5] -- goes forward with step 1 : [1,2,3,4,5]\n[1,3..7] -- goes forward with step 2 (3 - 1) : [1,3,5,7]\n[6,5..3] -- goes back with step -1 = (5 - 6) : [6,5,4,3]\n[6,4..0] -- goes back with step -2 = (4 -6) : [6, 4, 2, 0]\n[5..3] -- default step is 1 while the range is decreasing : []\n[10,1..10] -- goes back with step -9 for an increasing range : [10]\n[1,1..10] -- goes forwaed with step is 0 = ( 1 - 1) : infitite list [1,1,...]. Do not worry about this case in this kata for this, we will deal with it in the third part.\n[1..9,12..15] -- invalid since one single range is allowed\n[1,2..20,25] -- invalid since a range has to be the final item\n[1,2,3..20] -- invalid since at most one inidivual element can be provided before a range\n//See the tests for more examples\n```\n\nYour work is to implement something like this in JavaScript.\n\nWith this purpose, I have defined the `ArrayComprehension` function.\n\n```javascript\nfunction ArrayComprehension(options) {\n  \n}\n```\n\nThe `options` parameter is an object with the `generator` key. The generator key is a string with list values:\n\n```javascript\nArrayComprehension({generator: '1,4,-3'}); // returns [1,4,-3]\nArrayComprehension({generator: '1..5'}); // returns [1,2,3,4,5]\nArrayComprehension({generator: '1,3..7'}); // returns [1,3,5,7]\nArrayComprehension({generator: '7,5..2'}); // returns [7,5,3]\n```\n\nIt is assumed that the generator format is always right. Therefore, no need to check it.",
  "totalAttempts": 3274,
  "totalCompleted": 485,
  "totalStars": 59,
  "voteScore": 97,
  "tags": [
    "Functional Programming",
    "Arrays",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 3,
    "suggestions": 2
  }
}