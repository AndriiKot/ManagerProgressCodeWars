{
  "id": "580ee34f2f3779849900003a",
  "name": "Arrays and Procs #2",
  "slug": "arrays-and-procs-number-2",
  "category": "reference",
  "publishedAt": "2016-10-25T04:55:46.785Z",
  "approvedAt": "2018-03-30T14:12:33.424Z",
  "languages": [
    "ruby"
  ],
  "url": "https://www.codewars.com/kata/580ee34f2f3779849900003a",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-10-25T04:45:03.335Z",
  "createdBy": {
    "username": "narayanswa30663",
    "url": "https://www.codewars.com/users/narayanswa30663"
  },
  "approvedBy": {
    "username": "smile67",
    "url": "https://www.codewars.com/users/smile67"
  },
  "description": "### Before you start, try the previous kata in the series:\n[Arrays and Procs #1](https://www.codewars.com/kata/arrays-and-procs-number-1)\n\nFunctions like the one below can be invoked on values as shown:\n```ruby\ndef func(a)\n  a + a\nend\n\nfunc(1) #=> 2\nfunc(“str”) #=> “strstr”\nfunc(21) #=> 42\n```\nProcs like the one below have a slightly different syntax. For more on that syntax, see the [Ruby Proc docs](https://ruby-doc.org/core-2.3.0/Proc.html). \n```ruby\nfunc = proc { | a | a + a }\nfunc.call(1) #=> 2\n```\n\n#### Task:\nYour job here is to implement a function (named `array_procs`) that will take an array, `arr`, and a variable number of procs, `procs`, and apply the procs, in order, to their corresponding index in the array. When you run out of procs to apply and there are still array values without procs applied, go back to the first proc and continue from the start. If there are more procs than array elements, leave out the extra ones (from the end). Up to fifteen procs may be inputted. Note that `Proc#call` is **_disabled_**, so neither of the following will work:\n\n```ruby\nx = proc { | i | i + 2 }\nx.(2)\nx.call(2)\n```\n\n#### How the function will be called:\n```ruby\narray_procs(an_array, any_number_of_procs1, any_number_of_procs2,...)\n```\n\n#### Some examples:\n```ruby\narr = [1, 2, 4, 6, 7, 8]\nproc1 = proc { | i | i * 2 }\t\nproc2 = proc { | i | i + 1 }\narray_procs(arr, proc1, proc2) #=> \n  [(1 * 2), (2 + 1), (4 * 2), (6 + 1), (7 * 2), (8 + 1)]\n  [      2,       3,       8,       7,      14,       9]\narray_procs(arr, proc2, proc1) #=> \n  [(1 + 1), (2 * 2), (4 + 1), (6 * 2), (7 + 1), (8 * 2)]\n  [      2,       4,       5,      12,       8,      16]\narray_procs(arr, proc2) #=> \n  [(1 + 1), (2 + 1), (4 + 1), (6 + 1), (7 + 1), (8 + 1)]\n  [      2,       3,       5,       7,       8,       9]\narray_procs(arr) #=> \n  [1, 2, 4, 6, 7, 8] since there are no procs to apply on the elements\n```\n\nAlso, whenever one of the tests fails, the procs applied will be printed to the console. This is because it is difficult to print the source code for procs, and so the string values of the failed inputs would help.\n\nAll input procs will take only one argument, but some procs may take an argument and not use it (for example, `proc { | i | 0 + 2 + 22 }` is valid, and should change every value applied to 22). There will also be no need to ensure that the first argument is an array or that the rest of the arguments are proc functions. And again, `Proc#call` is disabled.\n\nIf you see issues or have any suggestions/ideas at all, please don't hesitate to comment. Otherwise, please rank and mark as ready!\n\nAlso check out my other creations:\n[Implement String#transpose](https://www.codewars.com/kata/implement-string-number-transpose), and [Implement Array#transpose!](https://www.codewars.com/kata/implement-array-number-transpose)",
  "totalAttempts": 178,
  "totalCompleted": 53,
  "totalStars": 5,
  "voteScore": 25,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}