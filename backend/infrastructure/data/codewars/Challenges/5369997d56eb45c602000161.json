{
  "id": "5369997d56eb45c602000161",
  "name": "Big to Little Endian",
  "slug": "big-to-little-endian",
  "category": "algorithms",
  "publishedAt": "2014-05-07T02:26:04.786Z",
  "approvedAt": "2016-05-24T21:03:51.259Z",
  "languages": [
    "ruby",
    "cobol"
  ],
  "url": "https://www.codewars.com/kata/5369997d56eb45c602000161",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2014-05-07T02:25:01.842Z",
  "createdBy": {
    "username": "maerch",
    "url": "https://www.codewars.com/users/maerch"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Your operating system screwed some things up. It has received some unsigned 32 bit integer from the Internet, but nobody told your OS about the \"network byte order\" and his \"host byte order\".\n\nYour job is to write a function `ntoh` which takes a 32 bit unsigned integer in the Big Endian byte order and returns the correct 32 bit unsigned integer in the Little Endian order.\n\nTo refresh your knowledge about byte order. One byte are 8 bits, so a 32 bit unsigned integer consists of 4 bytes which are ordered the wrong way.\n\n~~~if:ruby\nIf an integer longer than 32 bit is given the function has to raise a nasty exception.\n~~~\n\n~~~if:cobol\nIf an integer longer than 32 bit is given then assign `-1` to `result`.\n~~~\nExample:\n\n```\n* 42949695 => 1063030530\n```\n\n`42949695` as a 32 bit integer is\n\n`00000010 10001111 01011100 00111111` which translates to\n\n`00111111 01011100 10001111 00000010` which is `1063030530`.",
  "totalAttempts": 746,
  "totalCompleted": 142,
  "totalStars": 10,
  "voteScore": 52,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}