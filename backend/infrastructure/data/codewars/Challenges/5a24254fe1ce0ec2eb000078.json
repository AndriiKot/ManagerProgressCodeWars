{
  "id": "5a24254fe1ce0ec2eb000078",
  "name": "Simple string indices",
  "slug": "simple-string-indices",
  "category": "algorithms",
  "publishedAt": "2017-12-04T05:53:48.526Z",
  "approvedAt": "2017-12-04T07:10:54.740Z",
  "languages": [
    "python",
    "javascript",
    "ruby",
    "haskell",
    "cpp",
    "crystal",
    "fortran",
    "java",
    "nasm",
    "go",
    "c",
    "clojure"
  ],
  "url": "https://www.codewars.com/kata/5a24254fe1ce0ec2eb000078",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2017-12-03T16:24:48.423Z",
  "createdBy": {
    "username": "KenKamau",
    "url": "https://www.codewars.com/users/KenKamau"
  },
  "approvedBy": {
    "username": "Voile",
    "url": "https://www.codewars.com/users/Voile"
  },
  "description": "In this Kata, you will be given a string with brackets and an index of an opening bracket and your task will be to return the index of the matching closing bracket.  Both the input and returned index are 0-based **except in Fortran where it is 1-based**. An opening brace will always have a closing brace. Return `-1` if there is no answer (in Haskell, return `Nothing`; in Fortran, return `0`; in Go, return an error)\n\n### Examples\n\n```c\nsolve(\"((1)23(45))(aB)\", 0) = 10 // the opening brace at index 0 matches the closing brace at index 10\nsolve(\"((1)23(45))(aB)\", 1) = 3 \nsolve(\"((1)23(45))(aB)\", 2) = -1 // there is no opening bracket at index 2, so return -1\nsolve(\"((1)23(45))(aB)\", 6) = 9\nsolve(\"((1)23(45))(aB)\", 11) = 14\nsolve(\"((>)|?(*'))(yZ)\", 11) = 14\n```\n\n```python\nsolve(\"((1)23(45))(aB)\", 0) = 10 -- the opening brace at index 0 matches the closing brace at index 10\nsolve(\"((1)23(45))(aB)\", 1) = 3 \nsolve(\"((1)23(45))(aB)\", 2) = -1 -- there is no opening bracket at index 2, so return -1\nsolve(\"((1)23(45))(aB)\", 6) = 9\nsolve(\"((1)23(45))(aB)\", 11) = 14\nsolve(\"((>)|?(*'))(yZ)\", 11) = 14\n```\n\n```haskell\nsolve(\"((1)23(45))(aB)\", 0) = Just 10 -- the opening brace at index 0 matches the closing brace at index 10\nsolve(\"((1)23(45))(aB)\", 2) = Nothing -- there is no opening bracket at index 2, so return \"Nothing\" instead of -1\n```\n```fortran\nsolve(\"((1)23(45))(aB)\", 1) ! => 11 (the opening brace at index 1 matches the closing brace at index 11)\nsolve(\"((1)23(45))(aB)\", 2) ! => 4\nsolve(\"((1)23(45))(aB)\", 3) ! => 0 (there is no opening bracket at index 3, so return 0)\nsolve(\"((1)23(45))(aB)\", 7) ! => 10\nsolve(\"((1)23(45))(aB)\", 12) ! => 15\nsolve(\"((>)|?(*'))(yZ)\", 12) ! => 15\n```\n\nInput will consist of letters, numbers and special characters, but no spaces. The only brackets will be `(` and `)`. \n\nMore examples in the test cases. \n\nGood luck!\n\n~~~if:fortran\n*NOTE: In Fortran, you may assume that the input string will not contain any leading/trailing whitespace.*\n~~~",
  "totalAttempts": 8737,
  "totalCompleted": 2506,
  "totalStars": 62,
  "voteScore": 483,
  "tags": [
    "Strings",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 1,
    "suggestions": 1
  }
}