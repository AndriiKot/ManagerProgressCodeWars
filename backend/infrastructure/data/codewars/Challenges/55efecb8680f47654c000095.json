{
  "id": "55efecb8680f47654c000095",
  "name": "Hero's root",
  "slug": "heros-root",
  "category": "reference",
  "publishedAt": "2015-09-09T08:36:24.479Z",
  "approvedAt": "2015-11-04T04:41:32.734Z",
  "languages": [
    "ruby",
    "python",
    "javascript",
    "haskell",
    "java",
    "csharp",
    "clojure",
    "coffeescript",
    "typescript",
    "cpp",
    "elixir",
    "php",
    "crystal",
    "fsharp",
    "c",
    "shell",
    "ocaml",
    "kotlin",
    "fortran",
    "julia",
    "r",
    "powershell",
    "cobol",
    "go"
  ],
  "url": "https://www.codewars.com/kata/55efecb8680f47654c000095",
  "rank": {
    "id": -7,
    "name": "7 kyu",
    "color": "white"
  },
  "createdAt": "2015-09-09T08:24:25.314Z",
  "createdBy": {
    "username": "g964",
    "url": "https://www.codewars.com/users/g964"
  },
  "approvedBy": {
    "username": "joh_pot",
    "url": "https://www.codewars.com/users/joh_pot"
  },
  "description": "One of the first algorithm used for approximating the integer square root of a positive integer `n` is known as \"Hero's method\", \nnamed after the first-century Greek mathematician Hero of Alexandria who gave the first description\nof the method. Hero's method can be obtained from Newton's method which came 16 centuries after. \n\nWe approximate the square root of a number `n` by taking an initial guess `x`, an error `e` and repeatedly calculating a new approximate *integer* value `x` using: `(x + n / x) / 2`; we are finished when the previous `x` and the `new x` have an absolute difference less than `e`.\n\nWe supply to a function (int_rac) a number `n` (positive integer) and a parameter `guess` (positive integer) which will be our initial `x`. For this kata the parameter 'e' is set to `1`.\n\nHero's algorithm is not always going to come to an exactly correct result! For instance: if n = 25 we get 5 but for n = 26 we also get 5. Nevertheless `5` is the *integer* square root of `26`.\n\nThe kata is to return the count of the progression of integer approximations that the algorithm makes.\n\nReference:\n\n<https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method>\n\nSome examples:\n```\nint_rac(25,1): follows a progression of [1,13,7,5] so our function should return 4.\n\nint_rac(125348,300): has a progression of [300,358,354] so our function should return 3.\n\nint_rac(125348981764,356243): has a progression of [356243,354053,354046] so our function should return 3.\n```\n\n#\n\nYou can use Math.floor (or similar) for each integer approximation.\n \n#\n\nNote for JavaScript, Coffescript, Typescript:\n\nDon't use the double bitwise NOT ~~ at each iteration if you want to have the same results as in the tests and the other languages. \n",
  "totalAttempts": 17354,
  "totalCompleted": 2488,
  "totalStars": 102,
  "voteScore": 308,
  "tags": [
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 1
  }
}