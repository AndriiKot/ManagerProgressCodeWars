{
  "id": "5384df88aa6fc164bb000e7d",
  "name": "Don't Eat the Last Cake!",
  "slug": "dont-eat-the-last-cake",
  "category": "games",
  "publishedAt": "2014-05-27T20:05:54.798Z",
  "approvedAt": "2014-10-06T21:35:45.974Z",
  "languages": [
    "javascript",
    "coffeescript",
    "python",
    "ruby",
    "java",
    "haskell",
    "typescript",
    "php"
  ],
  "url": "https://www.codewars.com/kata/5384df88aa6fc164bb000e7d",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2014-05-27T18:55:04.523Z",
  "createdBy": {
    "username": "SagePtr",
    "url": "https://www.codewars.com/users/SagePtr"
  },
  "approvedBy": {
    "username": "xcthulhu",
    "url": "https://www.codewars.com/users/xcthulhu"
  },
  "description": "<img src=http://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Chickpea_Cakes_-_Kolkata_2011-03-24_2015.JPG/320px-Chickpea_Cakes_-_Kolkata_2011-03-24_2015.JPG>\n\nWelcome Warrior! Let's play a game!\n\nYou've gotten challenged by a lot of kata, now it's time for you to challenge the kata!\n\nIn a room is a table with a pile of cakes. One of these cakes is poisoned. Every turn, we will take cakes from this pile and eat them, leaving the last one to be the poisoned cake. Whoever eats the poisoned cake will die. The poisoned cake is clearly marked, so you do not have to guess. Rather you need to rely on logic to save you.  \n\n<h2>The rules are simple:</h2>\n\n1. Do not eat the last cake. It's obivious that the poisoned cake will be the last to be eaten, so, **DON'T EAT THE LAST CAKE**. Try to make your opponent eat it.\n\n2. When it is your turn, you can only take **one**, **two** or **three** cakes. The same rules apply to your opponent on their turn. You cannot skip your move, so choose wisely how many cakes to eat. Both opponents will be able to see how many cakes the other eats on each turn.\n\n3. You **cannot copy** your opponent's previous move; likewise they cannot copy yours. If your opponent takes one cake, next move you can only choose between two and three. If you take three cakes, your opponent can only choose one or two. This doesn't effect the first move, only subsequent ones.\n\n4. If one of the players has no valid moves (ie. one cake left and previous move was one cake), that player will **skip** their turn. Then the **other** player will be forced to eat the last cake. This is the **ONLY** case of turn skipping.\n\n5. You can choose whether or not to go first. This decision is key to victory, so don't hurry, choose wisely!\n\n<h2>Task of this kata:</h2>\n\nTo solve this kata, you should write class called ``Player``. This class has one constructor and two other functions:\n\n```javascript\nclass Player {\n  // called at the beginning of each game. Parameter: a number of cakes on the table\n  constructor(cakes) {\n  }\n  // called after the constructor. Must return true if you want to move first, false is you want to move after your opponent\n  // Parameter: number of cakes on the table left (same as in constructor)\n  firstmove(cakes) {\n  }\n  // called before each of your moves. First parameter: number of cakes left on the table. Second parameter: amount of cakes took by your opponent last move. Must return 1, 2 or 3 depending of how much cakes you want to take.\n  move(cakes, last) {\n  }\n}\n```\n```typescript\nclass Player {\n  // called at the beginning of each game. Parameter: a number of cakes on the table\n  constructor(cakes: number) {\n  }\n  // called after the constructor. Must return true if you want to move first, false is you want to move after your opponent\n  // Parameter: number of cakes on the table left (same as in constructor)\n  firstmove(cakes: number): boolean {\n  }\n  // called before each of your moves. First parameter: number of cakes left on the table. Second parameter: amount of cakes took by your opponent last move. Must return 1, 2 or 3 depending of how much cakes you want to take.\n  move(cakes: number, last: number): number {\n  }\n}\n```\n```coffeescript\nclass Player\n  # called at the beginning of each game. Parameter: a number of cakes on the table.\n  constructor: (cakes) ->\n  \n  # called after the constructor.\n  # Parameter: number of cakes on the table left (same as in constructor).\n  # Must return true if you want to move first, false is you want to move after your opponent.\n  firstmove: (cakes) -> \n\n  # called before each of your moves.\n  # First parameter: number of cakes left on the table.\n  # Second parameter: amount of cakes took by your opponent last move.\n  # Must return 1, 2 or 3 depending of how much cakes you want to take.\n  move: (cakes, last) ->\n  \n```\n```ruby\nclass Player\n  # called at the beginning of each game. Parameter: a number of cakes on the table.\n  def initialize(cakes)\n  end\n  # called after the constructor.\n  # Parameter: number of cakes on the table left (same as in constructor).\n  # Must return true if you want to move first, false is you want to move after your opponent.\n  def firstmove(cakes)\n  end\n  # called before each of your moves.\n  # First parameter: number of cakes left on the table.\n  # Second parameter: amount of cakes took by your opponent last move.\n  # Must return 1, 2 or 3 depending of how much cakes you want to take.  \n  def move(cakes, last)\n    last == 1 ? 2 : 1 # I'm not greedy\n  end\nend\n```\n```python\nclass Player:\n  # called at the beginning of each game. Parameter: a number of cakes on the table.\n  def __init__(self, cakes):\n  \n  # called after the constructor.\n  # Parameter: number of cakes on the table left (same as in constructor).\n  # Must return true if you want to move first, false is you want to move after your opponent.\n  def firstmove(self, cakes): \n\n  # called before each of your moves.\n  # First parameter: number of cakes left on the table.\n  # Second parameter: amount of cakes took by your opponent last move.\n  # Must return 1, 2 or 3 depending of how much cakes you want to take.\n  def move(self, cakes, last):\n  \n```\n```php\n<?php\nclass Player\n{\n  // Called at the beginning of each game.\n  // Parameter: a number of cakes on the table.\n  function __construct(int $cakes)\n  {\n  }\n  // Called after the constructor.\n  // Parameter: number of cakes on the table left (same as in constructor).\n  // Must return true if you want to move first, false is you want to move after your opponent.\n  public function firstmove(int $cakes): bool\n  {\n  }\n  // Called before each of your moves.\n  // First parameter: number of cakes left on the table.\n  // Second parameter: amount of cakes took by your opponent last move.\n  // Must return 1, 2 or 3 depending of how much cakes you want to take.\n  public function move(int $cakes, int $last): int\n  {\n  }\n}\n```\n```java\npublic class Player {\n  Player(int cakes) {\n    // called at the beginning of each game. Parameter: a number of cakes on the table\n  }\n  \n  boolean firstMove(int cakes){\n    // called after the constructor.\n    // Parameter: number of cakes on the table left (same as in constructor)\n    // Must return true if you want to move first, false is you want to move after your opponent\n  }\n  int move(int cakes, int last){\n    // called before each of your moves.\n    // First parameter: number of cakes left on the table.\n    // Second parameter: amount of cakes took by your opponent last move.\n    // Must return 1, 2 or 3 depending of how much cakes you want to take.\n  }\n}\n```\n```haskell\n-- actually, forget that class, it's useless. just define\n\nfirstMove :: Int -> Bool  -- Must return True if you want to move first, False if you want to move after your opponent\n                          -- Parameter: number of cakes initially on the table\n\nmove :: Int -> Int -> Int -- Must return 1, 2 or 3 depending on how many cakes you want to take\n                          -- First parameter: number of cakes currently on the table\n                          -- Second parameter: number of cakes your opponent took last move ( or 0, only for the very first move of any game )\n```\n\nEach test is a different game and different instance of the `Player` class. You should not worry about calling functions, you should only watch the number of cakes on the table and decide on every move how many to take, and decide who moves first.\n\nWrite your ``Player`` class and beat your opponent! You must figure out a strategy that can guarantee you a victory.\n\nYour implementation should not crash or do invalid moves if used as the second player (without an option to choose the fisrt move). If you are forced to lose, do it with dignity.\n\n<h2>Example:</h2>\n\n```javascript\nclass Player {\n  constructor(cakes) {\n    // Not sure if you need one\n  }\n  // Decide who moves first - player or opponent (true if player)\n  firstmove(cakes) {\n    // I wish to move first\n    return true;\n  }\n  // Decide your next move\n  move(cakes, last) {\n    // I'm not greedy\n    return last == 1 ? 2 : 1;\n  }\n}\n```\n```typescript\nexport class Player {\n  constructor(cakes: number) {\n    // Not sure if you need one\n  }\n  // Decide who moves first - player or opponent (true if player)\n  firstmove(cakes: number): boolean {\n    // I wish to move first\n    return true;\n  }\n  // Decide your next move\n  move(cakes: number, last: number): number {\n    // I'm not greedy\n    return last == 1 ? 2 : 1;\n  }\n}\n```\n```coffeescript\nclass Player\n  constructor: (cakes) ->\n  \n  # Decide who moves first - player or opponent (return true if player)\n  firstmove: (cakes) -> \n    true # I want to move first\n    \n  # Decide your next move (return 1, 2 or 3)\n  move: (cakes, last) ->\n    if last is 1 then 2 else 1 # I'm not greedy\n```\n```ruby\nclass Player\n  # Constructor\n  def initialize(cakes)\n  end\n  # Decide who moves first - player or opponent (return true if player)\n  def firstmove(cakes)\n    true # I want to move first\n  end\n  # Decide your next move (return 1, 2 or 3)\n  def move(cakes, last)\n    last == 1 ? 2 : 1 # I'm not greedy\n  end\nend\n```\n```python\nclass Player:\n    # Constructor\n    def __init__(self, cakes):\n        pass\n    # Decide who moves first\n    def firstmove(self, cakes):\n        # I wish to move first\n        return True\n    # Decide your next move\n    def move(self, cakes, last):\n        #I'm not greedy\n        return 1 if last != 1 else 2\n```\n```php\n<?php\nclass Player\n{\n  // Class constructor\n  function __construct(int $cakes)\n  {\n    // Not sure if you need one\n  }\n  // Decide who moves first - player or opponent (true if player)\n  public function firstmove(int $cakes): bool\n  {\n    // I wish to move first\n    return true;\n  }\n  // Decide your next move\n  public function move(int $cakes, int $last): int\n  {\n    // I'm not greedy\n    return $last == 1 ? 2 : 1;\n  }\n}\n```\n```java\npublic class Player {\n  Player(int cakes) {\n  }\n  // Decide who moves first - player or opponent (return true if player)\n  boolean firstMove(int cakes) {\n    // I wish to move first\n    return true;\n  }\n  // Decide your next move (return 1, 2 or 3)\n  int move(int cakes, int last) {\n    // I'm not greedy\n    return last == 1 ? 2 : 1;\n  }\n}\n```\n```haskell\n-- Decide who moves first - player or opponent (return True if player)\nfirstMove :: Int -> Bool\nfirstMove cakes = True -- I wish to move first\n\n-- Decide your next move (return 1, 2 or 3)\nmove :: Int -> Int -> Int\nmove cakes    1 = 2\nmove cakes last = 1 -- I'm not greedy\n```\n\n<h2>Example of game:</h2>\n\n12 cakes on the table. You decide to move first.\n\nYou eat 1 cake, 11 cakes left.\n\nOpponent eats 3 cakes, 8 cakes left.\n\nYou eat 2 cakes, 6 cakes left.\n\nOpponent eats 1 cake, 5 cakes left.\n\nYou eat 3 cakes, 2 cakes left.\n\nOpponent has no winning choice. If he eats 2 cakes, he will lose. If he eats 1 cake, you will be left in stalemate situation, and he will again eat 1 cake and lose.\n\nYou win.",
  "totalAttempts": 44593,
  "totalCompleted": 1824,
  "totalStars": 653,
  "voteScore": 234,
  "tags": [
    "Puzzles"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 2
  }
}