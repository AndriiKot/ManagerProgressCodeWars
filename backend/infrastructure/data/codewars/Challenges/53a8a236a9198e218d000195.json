{
  "id": "53a8a236a9198e218d000195",
  "name": "Custom attr_accessor",
  "slug": "custom-attr-accessor",
  "category": "refactoring",
  "publishedAt": "2014-06-24T20:17:16.655Z",
  "approvedAt": "2014-11-07T15:41:40.487Z",
  "languages": [
    "ruby"
  ],
  "url": "https://www.codewars.com/kata/53a8a236a9198e218d000195",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2014-06-23T21:55:02.627Z",
  "createdBy": {
    "username": "mcclaskc",
    "url": "https://www.codewars.com/users/mcclaskc"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "Some time ago, you wrote the class ```SuperFoo```.  It has only one attribute, ```data```, which is initialized as a hash:\n```ruby\nclass SuperFoo\n  attr_accessor :data\n\n  def initialize\n    @data = {}\n  end\nend\n```\nNaturally, you put things into the hash from time to time:\n```\nsuper_foo = SuperFoo.new\nsuper_foo.data[:buzz] = \"BUZZ\"\nsuper_foo.data[:buzz]\n#=> \"BUZZ\"\n```\nBut then you got tired of typing hash things, and made some getters and setters to make accessing ```data``` easier.\n```ruby\nclass SuperFoo\n\n  attr_accessor :data\n\n  def initialize\n    @data = {}\n  end\n\n  def buzz\n    @data[:buzz]\n  end\n\n  def buzz=(value)\n    @data[:buzz] = value\n  end\n\nend\n\nsuper_foo = SuperFoo.new\nsuper_foo.buzz = \"BUZZ\"\nsuper_foo.buzz\n#=> \"BUZZ\"\n```\nThat was nice for a while. But now, you have been tasked with making literally dozens of classes that inherit from ```SuperFoo```, each of which will have their own unique variables that will be stored in the ```data``` hash.  You shudder at the thought of writing your getter and setter methods over and over again, especially because you hate repeating code.\n\nYou figure there has to be a way to dynamically generate these methods...\n\nWell, there is!\n\nIn this kata, you must write a class-level method called ```data_accessor```. It will define your \"data getters and setters\" for all names you pass to it. \n\nBasically, you are defining a custom ```attr_accessor``` method, which will let you do this:\n```ruby\nclass SubFoo < SuperFoo\n  data_accessor :fizz, :pi\nend\n\nsub_foo = SubFoo.new\n\nsub_foo.fizz = \"FIZZ\"\nsub_foo.fizz\n#=> \"FIZZ\"\n\nsub_foo.pi = 3.14\nsub_foo.pi\n#=> 3.14\n\nsub_foo.data\n#=> {:fizz => \"FIZZ\", :pi => 3.14}\n\nsub_foo.instance_variables\n#=> [:@data]\n```\n",
  "totalAttempts": 1006,
  "totalCompleted": 355,
  "totalStars": 26,
  "voteScore": 46,
  "tags": [
    "Metaprogramming",
    "Refactoring"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}