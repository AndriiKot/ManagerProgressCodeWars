{
  "id": "5ae71f8c2c5061059e000044",
  "name": "Find X",
  "slug": "find-x",
  "category": "games",
  "publishedAt": "2018-04-30T15:15:14.872Z",
  "approvedAt": "2018-04-30T17:07:24.137Z",
  "languages": [
    "python",
    "javascript",
    "c",
    "nasm",
    "fortran",
    "ruby",
    "haskell",
    "cobol",
    "factor"
  ],
  "url": "https://www.codewars.com/kata/5ae71f8c2c5061059e000044",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2018-04-30T13:52:13.221Z",
  "createdBy": {
    "username": "kodejuice",
    "url": "https://www.codewars.com/users/kodejuice"
  },
  "approvedBy": {
    "username": "Iron Fingers",
    "url": "https://www.codewars.com/users/Iron%20Fingers"
  },
  "description": "Part 2 version [Find X â…¡](https://www.codewars.com/kata/5d339b01496f8d001054887f)\n\nWe have a function that takes in an integer `n`, and returns a number `x`.\n\nLets call this function `findX(n)`/`find_x(n)` (depending on your language):\n\n```python\ndef find_x(n):\n    x = 0\n    for i in range(n):\n        for j in range(2*n):\n            x += j + i\n    return x\n```\n```javascript\nfunction findX(n) {\n  let x = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < 2*n; j++)\n      x += i + j;\n  }\n  return x;\n}\n```\n```c\nlong long find_x(int n) {\n  long long x = 0;\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2*n; j++)\n      x += i + j;\n  }\n  return x;\n}\n```\n```fortran\ninteger(8) pure function findX(n) result(x)\n  integer(8), intent(in) :: n\n  integer(8) :: i, j\n  x = 0\n  do i = 0, n - 1\n    do j = 0, 2 * n - 1\n      x = x + j + i\n    end do\n  end do\nend function findX\n```\n```cobol\n       local-storage section.\n       01 i          pic 9(8).\n       01 j          pic 9(8).\n      \n       linkage section.\n       01 n           pic 9(8).\n       01 result      pic 9(20).\n      \n       procedure division using n result.\n      \n          move 0 to result\n          perform varying i from 0 by 1 until i = n\n            perform varying j from 0 by 1 until j = 2 * n\n              compute result = result + i + j\n            end-perform\n          end-perform\n          \n      \n          goback.\n       end program find-x.\n```\n```factor\n: find-x ( n -- x ) dup 2 * [ [0..b) ] bi@\n  [ + ] cartesian-map [ sum ] map-sum ;\n```\nThe functions loops throught the number `n` and at every iteration, performs a nested loop on `2*n`, at each iteration of this nested loop it increments `x` with the `(nested loop index + parents loop index)`.\n\nThis works well when the numbers are reasonably small.\n\n```python\nfind_x(2) #=> 16\nfind_x(3) #=> 63\nfind_x(5) #=> 325\n```\n```javascript\nfindX(2) //=> 16\nfindX(3) //=> 63\nfindX(5) //=> 325\n```\n```c\nfind_x(2) //=> 16\nfind_x(3) //=> 63\nfind_x(5) //=> 325\n```\n```fortran\nfindX(2) ! => 16\nfindX(3) ! => 63\nfindX(5) ! => 325\n```\n```factor\n2 find-x  ! --> 16\n3 find-x  ! --> 63\n5 find-x  ! --> 325\n```\n\nBut may be slow for numbers > **10<sup>3</sup>**\n\nSo your task is to optimize the function `findX`/`find_x`, so it works well for large numbers.\n\n\n### Input Range\n\n**1 <= n <= 10<sup>6</sup>** (**10<sup>5</sup>** in JS)\n\n*Note: This problem is more about logical reasoning than it is about finding a mathematicial formula, infact there are no complex math formula involved*",
  "totalAttempts": 5878,
  "totalCompleted": 1665,
  "totalStars": 76,
  "voteScore": 324,
  "tags": [
    "Puzzles"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}