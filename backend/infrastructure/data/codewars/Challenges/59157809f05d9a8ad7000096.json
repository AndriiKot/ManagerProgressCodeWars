{
  "id": "59157809f05d9a8ad7000096",
  "name": "Simple Fun #273: Powerset",
  "slug": "simple-fun-number-273-powerset",
  "category": "algorithms",
  "publishedAt": "2017-05-12T09:04:28.985Z",
  "approvedAt": "2017-05-18T09:40:26.127Z",
  "languages": [
    "javascript",
    "ruby",
    "python",
    "crystal"
  ],
  "url": "https://www.codewars.com/kata/59157809f05d9a8ad7000096",
  "rank": {
    "id": -5,
    "name": "5 kyu",
    "color": "yellow"
  },
  "createdAt": "2017-05-12T08:53:30.147Z",
  "createdBy": {
    "username": "myjinxin2015",
    "url": "https://www.codewars.com/users/myjinxin2015"
  },
  "approvedBy": {
    "username": "Voile",
    "url": "https://www.codewars.com/users/Voile"
  },
  "description": "# Task\nFor the given set `S` its powerset is the set of all possible subsets of `S`.\n\nGiven an array of integers nums, your task is to return the powerset of its elements.\n\nImplement an algorithm that does it in a depth-first search fashion. That is, for every integer in the set, we can either choose to take or not take it. At first, we choose `NOT` to take it, then we choose to take it(see more details in exampele).\n\n# Example\n\nFor `nums = [1, 2]`, the output should be `[[], [2], [1], [1, 2]].`\n\nHere's how the answer is obtained:\n```\ndon't take element 1\n----don't take element 2\n--------add []\n----take element 2\n--------add [2]\ntake element 1\n----don't take element 2\n--------add [1]\n----take element 2\n--------add [1, 2]\n```\n\nFor `nums = [1, 2, 3]`, the output should be \n\n`[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]`.\n\n# Input/Output\n\n`[input]` integer array `nums`\n\nArray of positive integers, `1 ≤ nums.length ≤ 10`.\n\n[output] 2D integer array\n\nThe powerset of nums.",
  "totalAttempts": 1037,
  "totalCompleted": 309,
  "totalStars": 28,
  "voteScore": 80,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 3
  }
}