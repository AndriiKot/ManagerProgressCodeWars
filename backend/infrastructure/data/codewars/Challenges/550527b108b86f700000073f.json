{
  "id": "550527b108b86f700000073f",
  "name": "PI approximation ",
  "slug": "pi-approximation",
  "category": "reference",
  "publishedAt": "2015-03-15T06:53:51.134Z",
  "approvedAt": "2015-06-05T16:58:06.840Z",
  "languages": [
    "ruby",
    "csharp",
    "haskell",
    "java",
    "python",
    "javascript",
    "coffeescript",
    "clojure",
    "elixir",
    "typescript",
    "cpp",
    "php",
    "crystal",
    "fsharp",
    "c",
    "ocaml",
    "rust",
    "swift",
    "go",
    "r",
    "shell",
    "julia",
    "scala",
    "powershell",
    "nim",
    "racket",
    "forth",
    "kotlin",
    "groovy",
    "fortran",
    "dart",
    "lua",
    "elm",
    "d",
    "prolog"
  ],
  "url": "https://www.codewars.com/kata/550527b108b86f700000073f",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2015-03-15T06:33:21.162Z",
  "createdBy": {
    "username": "g964",
    "url": "https://www.codewars.com/users/g964"
  },
  "approvedBy": {
    "username": "jhoffner",
    "url": "https://www.codewars.com/users/jhoffner"
  },
  "description": "The aim of the kata is to try to show how difficult it can be to calculate decimals of an irrational number with a certain precision. We have chosen to get a few decimals of the number \"pi\" using\nthe following infinite series (Leibniz 1646â€“1716): \n\nPI / 4 = 1 - 1/3 + 1/5 - 1/7 + ... which gives an approximation of PI / 4.\n\nhttp://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80\n\nTo have a measure of the difficulty we will count how many iterations are needed to calculate PI with a given precision of `epsilon`. \n\nThere are several ways to determine the precision of the calculus but to keep things easy we will calculate `PI` within epsilon of your language Math::PI constant. \n\n*In other words*, given as input a precision of `epsilon` we will stop the iterative process when the absolute value of the difference between our calculation using the Leibniz series and the Math::PI constant of your language is less than `epsilon`.\n\nYour function returns an array or a string or a tuple depending on the language (See sample tests) with \n- your number of iterations\n- your approximation of PI with 10 decimals \n\n```if:clojure\n\nClojure : You can use\n\"round\" (see \"Your solution\") to return PI with 10 decimals\n```\n```if:haskell\n\nHaskell : You can use\n\"trunc10Dble\" (see \"Your solution\") to return PI with 10 decimals\n```\n```if:ocaml\n\nOCaml : You can use\n\"rnd10\" (see \"Your solution\") to return PI with 10 decimals\n```\n```if:rust\n\nRust : You can use\n\"rnd10\" (see \"Your solution\") to return PI with 10 decimals\n```\n```if:scala\n\nScala : \nApproximation of PI with 10 or less decimals without trailing zeroes\n```\n#### Example :\n\nGiven epsilon = 0.001 your function gets an approximation of 3.140592653839794 for PI at the end of 1000 iterations : since you are within `epsilon` of `Math::PI` you return\n\n```\niter_pi(0.001) --> [1000, 3.1405926538]\n```\n\n#### Notes :\n\nUnfortunately, this series converges too slowly to be useful, \nas it takes over 300 terms to obtain a 2 decimal place precision. \nTo obtain 100 decimal places of PI, it was calculated that\none would need to use at least 10^50 terms of this expansion!\n\nAbout PI : http://www.geom.uiuc.edu/~huberty/math5337/groupe/expresspi.html",
  "totalAttempts": 37183,
  "totalCompleted": 5834,
  "totalStars": 306,
  "voteScore": 634,
  "tags": [
    "Arrays",
    "Mathematics",
    "Fundamentals"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 3
  }
}