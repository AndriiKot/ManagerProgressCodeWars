{
  "id": "55b2549a781b5336c0000103",
  "name": "Compare powers",
  "slug": "compare-powers",
  "category": "algorithms",
  "publishedAt": "2015-07-24T20:46:33.876Z",
  "approvedAt": "2015-07-30T10:50:53.007Z",
  "languages": [
    "ruby",
    "javascript",
    "python",
    "coffeescript",
    "haskell",
    "nasm",
    "c",
    "cpp",
    "crystal",
    "csharp",
    "cobol",
    "java",
    "d"
  ],
  "url": "https://www.codewars.com/kata/55b2549a781b5336c0000103",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2015-07-24T15:07:07.257Z",
  "createdBy": {
    "username": "GiacomoSorbi",
    "url": "https://www.codewars.com/users/GiacomoSorbi"
  },
  "approvedBy": {
    "username": "Abbe",
    "url": "https://www.codewars.com/users/Abbe"
  },
  "description": "You certainly can tell which is the larger number between 2<sup>10</sup> and 2<sup>15</sup>.\n\nBut what about, say, 2<sup>10</sup> and 3<sup>10</sup>? You know this one too.\n\nThings tend to get a bit more complicated with **both** different bases and exponents: which is larger between 3<sup>9</sup> and 5<sup>6</sup>?\n\nWell, by now you have surely guessed that you have to build a function to compare powers, returning -1 if the first member is larger, 0 if they are equal, 1 otherwise; powers to compare will be provided in the `[base, exponent]` format:\n```ruby\ncompare_powers([2,10],[2,15])==1\ncompare_powers([2,10],[3,10])==1\ncompare_powers([2,10],[2,10])==0\ncompare_powers([3,9],[5,6])==-1\ncompare_powers([7,7],[5,8])==-1\n```\n```javascript\ncomparePowers([2,10],[2,15])===1\ncomparePowers([2,10],[3,10])===1\ncomparePowers([2,10],[2,10])===0\ncomparePowers([3,9],[5,6])===-1\ncomparePowers([7,7],[5,8])===-1\n```\n```coffeescript\ncomparePowers([2,10],[2,15])==1\ncomparePowers([2,10],[3,10])==1\ncomparePowers([2,10],[2,10])==0\ncomparePowers([3,9],[5,6])==-1\ncomparePowers([7,7],[5,8])==-1\n```\n```python\ncompare_powers([2,10],[2,15])==1\ncompare_powers([2,10],[3,10])==1\ncompare_powers([2,10],[2,10])==0\ncompare_powers([3,9],[5,6])==-1\ncompare_powers([7,7],[5,8])==-1\n```\n```haskell\n-- Haskell results should reflect your usual `compare`\n-- result, e.g. 1 `compare` 2 == LT.\n(2, 10) `comparePowers` (2, 15) `shouldBe` LT\n(1, 10) `comparePowers` (2, 10) `shouldBe` LT\n(2, 10) `comparePowers` (2, 10) `shouldBe` EQ\n(3,  9) `comparePowers` (1,  6) `shouldBe` GT\n(1,  7) `comparePowers` (1,  8) `shouldBe` EQ\n```\n```c\ncompare_powers((int[]){2, 10}, (int[]){2, 15}) == 1;\ncompare_powers((int[]){2, 10}, (int[]){3, 10}) == 1;\ncompare_powers((int[]){2, 10}, (int[]){2, 10}) == 0;\ncompare_powers((int[]){3, 9}, (int[]){5, 6}) == -1;\ncompare_powers((int[]){7, 7}, (int[]){5, 8}) == -1;\n```\n```if:nasm\n<code>int compare_powers(const int n1[2], const int n2[2])</code>\n```\n```nasm\ncompare_powers((int[]){2, 10}, (int[]){2, 15}) == 1;\ncompare_powers((int[]){2, 10}, (int[]){3, 10}) == 1;\ncompare_powers((int[]){2, 10}, (int[]){2, 10}) == 0;\ncompare_powers((int[]){3, 9}, (int[]){5, 6}) == -1;\ncompare_powers((int[]){7, 7}, (int[]){5, 8}) == -1;\n```\n```java\ncomparePowers(new int[]{2, 10}, new int[]{2, 15}) ==  1;\ncomparePowers(new int[]{2, 10}, new int[]{3, 10}) ==  1;\ncomparePowers(new int[]{2, 10}, new int[]{2, 10}) ==  0;\ncomparePowers(new int[]{3,  9}, new int[]{5,  6}) == -1;\ncomparePowers(new int[]{7,  7}, new int[]{5,  8}) == -1;\n```\nOnly positive integers will be tested, including bigger numbers - you are warned now, so be diligent try to implement an efficient solution not to drain too much on CW resources ;)!\n\n\n",
  "totalAttempts": 27177,
  "totalCompleted": 2322,
  "totalStars": 134,
  "voteScore": 323,
  "tags": [
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 2,
    "suggestions": 4
  }
}