{
  "id": "521a849a05dd182a09000043",
  "name": "Hash.flattened_keys",
  "slug": "hash-dot-flattened-keys",
  "category": "algorithms",
  "publishedAt": "2013-08-25T23:40:58.893Z",
  "approvedAt": null,
  "languages": [
    "ruby"
  ],
  "url": "https://www.codewars.com/kata/521a849a05dd182a09000043",
  "rank": {
    "id": -4,
    "name": "4 kyu",
    "color": "blue"
  },
  "createdAt": "2013-08-25T22:26:35.072Z",
  "createdBy": {
    "username": "lunitik",
    "url": "https://www.codewars.com/users/lunitik"
  },
  "description": "For this kata you will be extending the Hash class to support a new method called 'flattened_keys'. The purpose of this method is to return a new  hash that has any nested values flattened so that there is only the single root hash structure. The keys from the nested hash will be merged into the parent, separated by underscores. \n\nBasic example:\n\n```ruby\nunflat = {id: 1, info: {name: 'example'}}.flattened_keys\nunflat.flattened_keys # equals {id: 1, info_name: 'example'}\n# notice the info_name flattened key\n```\n\nThe method should handle any level of nesting. For example:\n\n```ruby\nunflat = {\n  id: 1, \n  info: { \n    name: 'example', \n    more_info: {\n      count: 1\n    }\n  }\n}\n\nflat = unflat.flattened_keys\nflat # equals {id: 1, info_name: 'example', info_more_info_count: 1}\n```\n\nNotice that so far only symbols have been used as hash keys. If at any point in the path one of the keys is a string then the resulting flattened key should be a string as well. \n\nFor example:\n\n```ruby\nunflat = {a: 1, 'b' => 2, info: {id: 1, 'name' => 'example'}}\nflat = unflat.flattened_keys\nflat # equals {a: 1, 'b' => 2, info_id: 1, 'info_name' => 'example'}\n```",
  "totalAttempts": 8822,
  "totalCompleted": 697,
  "totalStars": 46,
  "voteScore": 72,
  "tags": [
    "Recursion",
    "Algorithms"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 1
  }
}