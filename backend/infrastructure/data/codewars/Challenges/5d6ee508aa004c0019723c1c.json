{
  "id": "5d6ee508aa004c0019723c1c",
  "name": "Odder than the rest",
  "slug": "odder-than-the-rest-1",
  "category": "algorithms",
  "publishedAt": "2019-09-03T23:18:14.228Z",
  "approvedAt": "2019-09-10T22:23:49.936Z",
  "languages": [
    "haskell",
    "javascript",
    "python",
    "crystal",
    "coffeescript",
    "ruby",
    "typescript",
    "dart",
    "julia",
    "csharp",
    "factor",
    "lambdacalc"
  ],
  "url": "https://www.codewars.com/kata/5d6ee508aa004c0019723c1c",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2019-09-03T22:11:20.451Z",
  "createdBy": {
    "username": "JohanWiltink",
    "url": "https://www.codewars.com/users/JohanWiltink"
  },
  "approvedBy": {
    "username": "user8436785",
    "url": "https://www.codewars.com/users/user8436785"
  },
  "description": "Integral numbers can be even or odd.\n\nEven numbers satisfy `n = 2m` ( with `m` also integral ) and we will ( completely arbitrarily ) think of odd numbers as `n = 2m + 1`.  \nNow, some odd numbers can be more odd than others: when for some `n`, `m` is more odd than for another's. Recursively. :]  \nEven numbers are just not odd.\n\n# Task\n\nGiven a finite list of integral ( not necessarily non-negative ) numbers, determine the number that is _odder than the rest_.  \nIf there is no single such number, no number is odder than the rest; return `Nothing`, `null` or a similar empty value.\n\n# Examples\n\n```haskell\noddest [1,2] -> Just 1\noddest [1,3] -> Just 3\noddest [1,5] -> Nothing\n```\n```javascript\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => null\n```\n```factor\n{ 1 2 } oddest -> 1\n{ 1 3 } oddest -> 3\n{ 1 5 } oddest -> f\n```\n```julia\noddest([1, 2]) => 1\noddest([1, 3]) => 3\noddest([1, 5]) => nothing\n```\n```csharp\nKata.Oddest(new int[] { 1, 2 }) => 1\nKata.Oddest(new int[] { 1, 3 }) => 3\nKata.Oddest(new int[] { 1, 5 }) => null\n```\n```typescript\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => null\n```\n```dart\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => null\n```\n```crystal\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => nil\n```\n```coffeescript\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => null\n```\n```ruby\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => nil\n```\n```python\noddest([1,2]) => 1\noddest([1,3]) => 3\noddest([1,5]) => None\n```\n```lambdacalc\noddest [1,2] -> Some 1\noddest [1,3] -> Some 3\noddest [1,5] -> None\n```\n\n~~~if:lambdacalc\n# Encodings\n\npurity: `LetRec`  \nnumEncoding: `NegaBinaryScott` ( custom )  \n\nExport constructors `nil, cons` for your `List` encoding, and deconstructor `option` for your `Option` encoding ( see `Initial Code` for signatures ).\n\n`NegaBinaryScott` is just like `BinaryScott`, but the base is `-2` instead of `2`. So in `01$` the `0` means `0 * (-2)^0 = 0 * 1` and the `1` means `1 * (-2)^1 = 1 * -2`, for a total of `-2`. The invariant that the MSB, if present, must be `1` is unchanged ( and, by default, enforced ). Negative number literals can be used.\n~~~\n\n# Hint\n\n<details>\n  <summary>Click here.</summary>\n  How odd is <code>-1</code> ?\n</details>",
  "totalAttempts": 7632,
  "totalCompleted": 363,
  "totalStars": 37,
  "voteScore": 73,
  "tags": [
    "Puzzles",
    "Algorithms",
    "Recursion"
  ],
  "contributorsWanted": false,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}