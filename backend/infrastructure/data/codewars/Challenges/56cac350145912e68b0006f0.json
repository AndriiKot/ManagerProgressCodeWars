{
  "id": "56cac350145912e68b0006f0",
  "name": "up AND down",
  "slug": "up-and-down",
  "category": "reference",
  "publishedAt": "2016-02-22T08:15:25.381Z",
  "approvedAt": "2016-02-23T21:49:47.490Z",
  "languages": [
    "ruby",
    "python",
    "javascript",
    "coffeescript",
    "java",
    "csharp",
    "haskell",
    "clojure",
    "elixir",
    "cpp",
    "php",
    "typescript",
    "crystal",
    "fsharp",
    "c",
    "rust",
    "swift",
    "go",
    "r",
    "shell",
    "ocaml",
    "kotlin",
    "scala",
    "julia",
    "powershell",
    "nim",
    "reason",
    "racket",
    "vb",
    "pascal",
    "lua",
    "perl",
    "elm",
    "d",
    "erlang",
    "prolog"
  ],
  "url": "https://www.codewars.com/kata/56cac350145912e68b0006f0",
  "rank": {
    "id": -6,
    "name": "6 kyu",
    "color": "yellow"
  },
  "createdAt": "2016-02-22T08:14:11.398Z",
  "createdBy": {
    "username": "g964",
    "url": "https://www.codewars.com/users/g964"
  },
  "approvedBy": {
    "username": "joh_pot",
    "url": "https://www.codewars.com/users/joh_pot"
  },
  "description": "*Don't be afraid, the description is rather long but - hopefully - it is in order that the process be well understood*.\n\nYou are given a string `s` made up of substring `s(1), s(2), ..., s(n)` separated by whitespaces.\nExample:\n`\"after be arrived two My so\"`\n\n#### Task\nReturn a string `t` having the following property:\n\n`length t(O) <= length t(1) >= length t(2) <= length t(3) >= length t(4) .... (P)`\n\nwhere the `t(i)` are the substring of `s`;\nyou must respect the following rule:\n\nat each step from left to right, you can only move either already consecutive strings \nor strings that became consecutive after a previous move. The number of moves should be minimum.\n\n#### Let us go with our example:\n\nThe length of \"after\" is greater than the length of \"be\". Let us move them ->`\"be after arrived two My so\"` \n\nThe length of \"after\" is smaller than the length of \"arrived\". Let us move them -> `\"be arrived after two My so\"`\n\nThe length of \"after\" is greater than the length of \"two\" ->`\"be arrived two after My so\"`\n\nThe length of \"after\" is greater than the length of \"My\". Good!\nFinally the length of \"My\" and \"so\" are the same, nothing to do.\nAt the end of the process, the substrings s(i) verify:\n\n`length s(0) <= length s(1) >= length s(2) <= length s(3) >= length (s4) <= length (s5)`\n\nHence given a string s of substrings `s(i)` the function `arrange` **with the previous process**\nshould return a *unique* string `t` having the property (P).\n\nIt is kind of roller coaster or up and down.\nWhen you have property (P), to make the result more \"up and down\" visible t(0), t(2), ... \nwill be lower cases and the others upper cases.\n\n```\narrange(\"after be arrived two My so\") should return \"be ARRIVED two AFTER my SO\"\n```\n\n#### Notes:\n- The string `\"My after be arrived so two\"` has the property (P) but can't be obtained by\nthe **described process** so it won't be accepted as a result. The property (P) \ndoesn't give unicity by itself.\n- Process: go from left to right, move only consecutive strings when needed.\n- For the first fixed tests the needed number of moves to get property (P) \nis given as a comment so that you can know if your process follows the rule.\n",
  "totalAttempts": 17163,
  "totalCompleted": 3371,
  "totalStars": 239,
  "voteScore": 470,
  "tags": [
    "Fundamentals",
    "Strings"
  ],
  "contributorsWanted": true,
  "unresolved": {
    "issues": 0,
    "suggestions": 0
  }
}